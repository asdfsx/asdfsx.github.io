<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on asdfsx</title>
    <link>https://asdfsx.github.io/post/index.xml</link>
    <description>Recent content in Posts on asdfsx</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Sat, 18 Feb 2017 10:12:39 +0800</lastBuildDate>
    <atom:link href="https://asdfsx.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>使用swarm在mac上搭建开发环境</title>
      <link>https://asdfsx.github.io/post/docker/%E4%BD%BF%E7%94%A8swarm%E5%9C%A8mac%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Sat, 18 Feb 2017 10:12:39 +0800</pubDate>
      
      <guid>https://asdfsx.github.io/post/docker/%E4%BD%BF%E7%94%A8swarm%E5%9C%A8mac%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <description>

&lt;h1 id=&#34;源起&#34;&gt;源起&lt;/h1&gt;

&lt;p&gt;docker并不是新技术。作为 golang 社区内的旗舰级的项目，从诞生之初就吸引了很多人的瞩目，甚至可以说是获得了所有 golang 社区的人多瞩目吧。同时对推广 golang 也起了很大的作用。作为从一直关注着 golang 的人，大概2年前就开始尝试使用它了。不过由于其依赖 linux 的多项特性，导致在 mac 上使用必须要借助虚拟机，体验总是要差一点。最近经人提醒发现新的 docker for mac 可以不借助虚拟机就可以在 mac 上提供与 linux 上同样的体验，大喜！遂卸载虚拟机，打算用新软件搭个测试环境玩耍一下。&lt;/p&gt;

&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;

&lt;p&gt;超级简单，照着说明来就好。顺便装上了 kitematic。这个确实也非常好用。&lt;/p&gt;

&lt;h1 id=&#34;目标&#34;&gt;目标&lt;/h1&gt;

&lt;p&gt;将一套以前用 python 实现的 kafka producer程序，移植到 golang 上。测试新程序的异常情况处理（特指连接失败的处理）。
然后就被坑掉了。&lt;/p&gt;

&lt;h1 id=&#34;坑1-网络的问题&#34;&gt;坑1 网络的问题&lt;/h1&gt;

&lt;p&gt;最初只是想通过 docker 启动一个单点的 kafka，程序通过本地网络直接访问就可以了。通过之前安装的 kitematic 从 hub.docker.com 上下载了 spotify/kafka 镜像，并直接启动容器。通过kitematic连接到容器内，各项命令执行正常。但是执行程序的时候却发现，总是第一次连接成功后，后边的所有连接都是失败的。通过日志发现程序在第一次成功连接 kafka 之后，连接地址发生了变更，变成了容器内部的地址（直观的现象就是，端口从 kitematic 随机生成的 12345 变成了 9092）。然后又尝试了手动用 &amp;ndash;net=host 方式启动，结果彻底连不上了。&lt;/p&gt;

&lt;p&gt;在对 github.com/shopify/sarama 简单的分析以后，发现它的连接过程是这样的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首次连接，根据配置信息连接服务器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;连接成功后，从服务器获取broker信息&lt;/li&gt;
&lt;li&gt;根据获得到的broker信息，连接其余的broker&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;问题就出现在最后一步上，服务器返回的broker信息中，网络地址都是容器内部的网络，没有办法从容器网络外部直接连接的。&lt;/p&gt;

&lt;p&gt;通过在github上查 issue， google 上查资料，有了以下不负责任的猜想：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;目前的 docker for mac 使用了自己搞的 github.com/docker/hyperkit 来实现轻量级的虚拟化。从项目的说明可以看到，其基于 github.com/mist64/xhyve，借助了 mac os 自身的 hypervisor.framework 来实现虚拟化。在 developer.apple.com 上可以看到相关的说明和 api refrence。它是 OS X v10.10 新增的一个功能，从 api 上来看，可以实现对 cpu 和 mem 的简单控制
，并没有提供对网络的控制。网络这块是 xhyve 自己通过 virto-net 实现的。这可能也是导致网络这块体验比较差的原因吧。完善网络还需要花不少时间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;测试还是要继续，从外部连接容器网络有问题，那就把测试程序也放到容器环境中去。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;上SWARM吧，骚年！&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;用swarm解决网络问题&#34;&gt;用SWARM解决网络问题&lt;/h1&gt;

&lt;p&gt;业界已有很多容器集群方案：kubernetes、mesos、swarm等。各有优势，选择swarm，主要原因还是方便，直接与docker集成。顺便吐槽，容器的江湖也是乱啊！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;下载测试用到的镜像&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  docker pull nginx
  docker pull spotify/kafka:latest
  docker pull prom/busybox:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在本地创建swarm&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  docker swarm init
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;创建 overlay 网络&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  docker network  create \
    --driver overlay \
    --subnet 10.0.9.0/24 \
    --opt encrypted \
    my-network
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简单测试一下 overlay 网络，以及swarm中的服务发现&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;启动一个 nginx 服务，并挂到 overlay 网络上&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;docker service create \
  --replicas 1 \
  --name my-web \
  --network my-network \
  nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;检查服务&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;docker service ps my-web
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;检查网络&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;docker network inspect my-network
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用busybox检查服务发现，其实就是网络中的dns&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;docker service create \
  --name dnstest \
  --network my-network \
  busybox \
  sleep 3000
  
docker service ps dnstest

docker exec -it dnstest.1.k8pjka8c9ikrpeje6spm6z8b5 sh

nslookup my-web
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动 kafka 服务&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  docker service create \
    --name kafka \
    --network my-network \
    spotify/kafka:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;测试 kafka
用测试 my-web 的方法测试 kafka&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关闭服务&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  docker service rm my-web
  docker service rm kafka
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;测试程序打包&#34;&gt;测试程序打包&lt;/h1&gt;

&lt;p&gt;golang 支持交叉编译，也就是说我在 mac 上就可以直接编译出 linux 上可以使用的可执行程序。这真是极大的方便了开发人员。只需要&lt;code&gt;GOOS=linux GOARCH=amd64 go build ${LDFLAGS} ${PACKAGE}&lt;/code&gt;就可以获得需要的可执行程序。然后简单的打包到镜像中就可以了。然后如愿以偿的掉入&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;坑2-时区的问题&#34;&gt;坑2 时区的问题&lt;/h1&gt;

&lt;p&gt;鉴于 golang 的可执行文件只是依赖 glibc，打包时选择了官方busybox作为基础镜像，好处就是小！小到连时区的支持都缩减到只有 UTC 一个，然后程序执行的时候就悲剧了。找到了最简单的一个解决办法是，设置环境变量&lt;code&gt;TZ&lt;/code&gt;，设为&lt;code&gt;CST-8&lt;/code&gt;表示中国标准时间，设为&lt;code&gt;JST-9&lt;/code&gt;表示日本标准时间。这个对于 date 命令很好使，但是对于编译好的 golang 程序顶个球用。只能选择另外一个办法，换一个带时区支持的 &lt;code&gt;prom/busybox&lt;/code&gt; 镜像，然后在Dockerfile中增加一个命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RUN mv /etc/localtime /etc/localtime.bak &amp;amp;&amp;amp; \
    ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;时区问题搞定，测试顺利进行&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>odoo简化版refrence</title>
      <link>https://asdfsx.github.io/post/odoo/odoo%E7%AE%80%E5%8C%96%E7%89%88refrence/</link>
      <pubDate>Sun, 05 Feb 2017 12:17:22 +0800</pubDate>
      
      <guid>https://asdfsx.github.io/post/odoo/odoo%E7%AE%80%E5%8C%96%E7%89%88refrence/</guid>
      <description>

&lt;p&gt;原文地址：&lt;a href=&#34;https://www.odoo.com/documentation/10.0/index.html&#34;&gt;https://www.odoo.com/documentation/10.0/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;整理一下，捡重点的来弄。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#Odoo Guidelines&#34;&gt;Odoo Guidelines&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#模块结构&#34;&gt;模块结构&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#目录结构&#34;&gt;目录结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#命名规则&#34;&gt;命名规则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#XML files&#34;&gt;XML files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Python&#34;&gt;Python&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#Idiomatics Python Programming&#34;&gt;Idiomatics Python Programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Programming in Odoo&#34;&gt;Programming in Odoo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Module&#34;&gt;Module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Web Controllers&#34;&gt;Web Controllers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ORM API&#34;&gt;ORM API&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#Recordsets&#34;&gt;Recordsets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Environment&#34;&gt;Environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Common ORM methods&#34;&gt;Common ORM methods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Creating Models&#34;&gt;Creating Models&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Compatibility between new API and old API&#34;&gt;Compatibility between new API and old API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Model Reference&#34;&gt;Model Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Method decorators&#34;&gt;Method decorators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Fields&#34;&gt;Fields&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Data Files&#34;&gt;Data Files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#QWeb&#34;&gt;QWeb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Views&#34;&gt;Views&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;Odoo Guidelines&#34;&gt;Odoo Guidelines&lt;/h1&gt;

&lt;h2 id=&#34;模块结构&#34;&gt;模块结构&lt;/h2&gt;

&lt;h3 id=&#34;目录结构&#34;&gt;目录结构&lt;/h3&gt;
主要目录：

* data/ : demo and data xml
* models/ : models definition
* controllers/ : contains controllers (HTTP routes).
* views/ : contains the views and templates
* static/ : contains the web assets, separated into css/, js/, img/, lib/, ...

可选目录：

* wizard/ : regroups the transient models (formerly osv_memory) and their views.
* report/ : contains the reports (RML report [deprecated], models based on SQL views (for reporting) and other complex reports). Python objects and XML views are included in this directory.
* tests/ : contains the Python/YML tests

&lt;h3 id=&#34;命名规则&#34;&gt;命名规则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于视图，将后段的 views 与前端的模版拆成两个不同的文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于模型，将一个商业逻辑切分成为多组模型，每一组选择一个主模型，用主模型的名字来定义这个组。如果只有一个模型，那么这个模型的名字与模块相同。每组定义了&lt;main_model&gt;的模型会创建以下文件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;models/&lt;main_model&gt;.py&lt;/li&gt;
&lt;li&gt;models/&lt;inherited_main_model&gt;.py&lt;/li&gt;
&lt;li&gt;views/&lt;main_model&gt;_templates.xml&lt;/li&gt;
&lt;li&gt;views/&lt;main_model&gt;_views.xml&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举例：sale 模块引入 sale_order 和 sale_order_line，其中 sale_order 是主模型。所以主模型的文件名为：models/sale_order.py 和 views/sale_order_views.py。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于数据，根据目的分为：demo 和 data。文件名是主模型名字加后缀 _data.xml 或 _demo.xml。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于控制器，唯一的控制器被命名为 main.py。如果需要从其他模块中继承已有的控制器，则文件名为 &amp;lt;module_name&amp;gt;.py。与模型不同，每个 controller 类要存放在单独的文件里。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于静态文件，因为资源可能会在不同的context下使用（前端、后端、both），所以会把它们放在同一个 bundle 中。所以 CSS/Less，JavaScript 和 XML 会在文件末尾加bundle类型作为后缀。i.e.: im_chat_common.css，im_chat_common.js for &amp;lsquo;assets_common&amp;rsquo; bundle，and im_chat_backend.css, im_chat_backend.js for &amp;lsquo;assets_backend&amp;rsquo; bundle。如果模块中只有一个文件，习惯上使用 &amp;lt;module_name&amp;gt;.ext (i.e.: project.js)。不要使用外部链接（图片、库）：不要使用图片的URL，而是把图片放到代码库中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于报表，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;lt;report_name_A&amp;gt;_report.py&lt;/li&gt;
&lt;li&gt;&amp;lt;report_name_A&amp;gt;_report_views.py&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于可打印报表，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;lt;print_report_name&amp;gt;_reports.py (report actions, paperformat definition, &amp;hellip;)&lt;/li&gt;
&lt;li&gt;&amp;lt;print_report_name&amp;gt;_templates.xml (xml report templates)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整的目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;addons/&amp;lt;my_module_name&amp;gt;/
|-- __init__.py
|-- __manifest__.py
|-- controllers/
|   |-- __init__.py
|   |-- &amp;lt;inherited_module_name&amp;gt;.py
|   `-- main.py
|-- data/
|   |-- &amp;lt;main_model&amp;gt;_data.xml
|   `-- &amp;lt;inherited_main_model&amp;gt;_demo.xml
|-- models/
|   |-- __init__.py
|   |-- &amp;lt;main_model&amp;gt;.py
|   `-- &amp;lt;inherited_main_model&amp;gt;.py
|-- report/
|   |-- __init__.py
|   |-- &amp;lt;main_stat_report_model&amp;gt;.py
|   |-- &amp;lt;main_stat_report_model&amp;gt;_views.xml
|   |-- &amp;lt;main_print_report&amp;gt;_reports.xml
|   `-- &amp;lt;main_print_report&amp;gt;_templates.xml
|-- security/
|   |-- ir.model.access.csv
|   `-- &amp;lt;main_model&amp;gt;_security.xml
|-- static/
|   |-- img/
|   |   |-- my_little_kitten.png
|   |   `-- troll.jpg
|   |-- lib/
|   |   `-- external_lib/
|   `-- src/
|       |-- js/
|       |   `-- &amp;lt;my_module_name&amp;gt;.js
|       |-- css/
|       |   `-- &amp;lt;my_module_name&amp;gt;.css
|       |-- less/
|       |   `-- &amp;lt;my_module_name&amp;gt;.less
|       `-- xml/
|           `-- &amp;lt;my_module_name&amp;gt;.xml
|-- views/
|   |-- &amp;lt;main_model&amp;gt;_templates.xml
|   |-- &amp;lt;main_model&amp;gt;_views.xml
|   |-- &amp;lt;inherited_main_model&amp;gt;_templates.xml
|   `-- &amp;lt;inherited_main_model&amp;gt;_views.xml
`-- wizard/
    |-- &amp;lt;main_transient_A&amp;gt;.py
    |-- &amp;lt;main_transient_A&amp;gt;_views.xml
    |-- &amp;lt;main_transient_B&amp;gt;.py
    `-- &amp;lt;main_transient_B&amp;gt;_views.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意使用正确的文件权限：目录 755 ，文件 644&lt;/p&gt;

&lt;h2 id=&#34;XML files&#34;&gt;XML files&lt;/h2&gt;

&lt;h3 id=&#34;format&#34;&gt;Format&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;record id=&amp;quot;view_id&amp;quot; model=&amp;quot;ir.ui.view&amp;quot;&amp;gt;
    &amp;lt;field name=&amp;quot;name&amp;quot;&amp;gt;view.name&amp;lt;/field&amp;gt;
    &amp;lt;field name=&amp;quot;model&amp;quot;&amp;gt;object_name&amp;lt;/field&amp;gt;
    &amp;lt;field name=&amp;quot;priority&amp;quot; eval=&amp;quot;16&amp;quot;/&amp;gt;
    &amp;lt;field name=&amp;quot;arch&amp;quot; type=&amp;quot;xml&amp;quot;&amp;gt;
        &amp;lt;tree&amp;gt;
            &amp;lt;field name=&amp;quot;my_field_1&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;my_field_2&amp;quot; string=&amp;quot;My Label&amp;quot; widget=&amp;quot;statusbar&amp;quot; statusbar_visible=&amp;quot;draft,sent,progress,done&amp;quot; /&amp;gt;
        &amp;lt;/tree&amp;gt;
    &amp;lt;/field&amp;gt;
&amp;lt;/record&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;naming-xml-id&#34;&gt;Naming xml_id&lt;/h3&gt;

&lt;h4 id=&#34;security-view-and-action&#34;&gt;Security, View and Action&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- views and menus --&amp;gt;
&amp;lt;record id=&amp;quot;model_name_view_form&amp;quot; model=&amp;quot;ir.ui.view&amp;quot;&amp;gt;
    ...
&amp;lt;/record&amp;gt;

&amp;lt;record id=&amp;quot;model_name_view_kanban&amp;quot; model=&amp;quot;ir.ui.view&amp;quot;&amp;gt;
    ...
&amp;lt;/record&amp;gt;

&amp;lt;menuitem
    id=&amp;quot;model_name_menu_root&amp;quot;
    name=&amp;quot;Main Menu&amp;quot;
    sequence=&amp;quot;5&amp;quot;
/&amp;gt;
&amp;lt;menuitem
    id=&amp;quot;model_name_menu_action&amp;quot;
    name=&amp;quot;Sub Menu 1&amp;quot;
    parent=&amp;quot;module_name.module_name_menu_root&amp;quot;
    action=&amp;quot;model_name_action&amp;quot;
    sequence=&amp;quot;10&amp;quot;
/&amp;gt;

&amp;lt;!-- actions --&amp;gt;
&amp;lt;record id=&amp;quot;model_name_action&amp;quot; model=&amp;quot;ir.actions.act_window&amp;quot;&amp;gt;
    ...
&amp;lt;/record&amp;gt;

&amp;lt;record id=&amp;quot;model_name_action_child_list&amp;quot; model=&amp;quot;ir.actions.act_window&amp;quot;&amp;gt;
    ...
&amp;lt;/record&amp;gt;

&amp;lt;!-- security --&amp;gt;
&amp;lt;record id=&amp;quot;module_name_group_user&amp;quot; model=&amp;quot;res.groups&amp;quot;&amp;gt;
    ...
&amp;lt;/record&amp;gt;

&amp;lt;record id=&amp;quot;model_name_rule_public&amp;quot; model=&amp;quot;ir.rule&amp;quot;&amp;gt;
    ...
&amp;lt;/record&amp;gt;

&amp;lt;record id=&amp;quot;model_name_rule_company&amp;quot; model=&amp;quot;ir.rule&amp;quot;&amp;gt;
    ...
&amp;lt;/record&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;inherited-xml&#34;&gt;Inherited XML&lt;/h4&gt;

&lt;p&gt;继承一个 view 的命名方式：&lt;code&gt;&amp;lt;base_view&amp;gt;_inherit_&amp;lt;current_module_name&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;record id=&amp;quot;inherited_model_view_form_inherit_my_module&amp;quot; model=&amp;quot;ir.ui.view&amp;quot;&amp;gt;
    ...
&amp;lt;/record&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;Python&#34;&gt;Python&lt;/h2&gt;

&lt;h3 id=&#34;pep8&#34;&gt;PEP8&lt;/h3&gt;

&lt;h3 id=&#34;imports&#34;&gt;Imports&lt;/h3&gt;

&lt;p&gt;按照如下顺序引用库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 1 : imports of python lib
import base64
import re
import time
from datetime import datetime
# 2 :  imports of odoo
import odoo
from odoo import api, fields, models # alphabetically ordered
from odoo.tools.safe_eval import safe_eval as eval
from odoo.tools.translate import _
# 3 :  imports from odoo modules
from odoo.addons.website.models.website import slug
from odoo.addons.web.controllers.main import login_redirect
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;Idiomatics Python Programming&#34;&gt;Idiomatics Python Programming&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;每个文件的第一行是&lt;code&gt;# -*- coding: utf-8 -*-&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可读性要比简洁、语言特性更重要&lt;/li&gt;
&lt;li&gt;不要使用&lt;code&gt;clone&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  # bad
  new_dict = my_dict.clone()
  new_list = old_list.clone()
  # good
  new_dict = dict(my_dict)
  new_list = list(old_list)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;python字典的创建和更新&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  # -- creation empty dict
  my_dict = {}
  my_dict2 = dict()

  # -- creation with values
  # bad
  my_dict = {}
  my_dict[&#39;foo&#39;] = 3
  my_dict[&#39;bar&#39;] = 4
  # good
  my_dict = {&#39;foo&#39;: 3, &#39;bar&#39;: 4}

  # -- update dict
  # bad
  my_dict[&#39;foo&#39;] = 3
  my_dict[&#39;bar&#39;] = 4
  my_dict[&#39;baz&#39;] = 5
  # good
  my_dict.update(foo=3, bar=4, baz=5)
  my_dict = dict(my_dict, **my_dict2)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;命名变量／类／函数时，使用有意义的名字&lt;/li&gt;
&lt;li&gt;无用的变量，临时变量可以让代码更明确，但是不意味着总要创建临时变量。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  # pointless
  schema = kw[&#39;schema&#39;]
  params = {&#39;schema&#39;: schema}
  # simpler
  params = {&#39;schema&#39;: kw[&#39;schema&#39;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;用多个 return 来让代码更简单&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  # a bit complex and with a redundant temp variable
  def axes(self, axis):
        axes = []
        if type(axis) == type([]):
                axes.extend(axis)
        else:
                axes.append(axis)
        return axes

  # clearer
  def axes(self, axis):
        if type(axis) == type([]):
                return list(axis) # clone the axis
        else:
                return [axis] # single-element list
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;熟悉内建函数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  value = my_dict.get(&#39;key&#39;, None) # very very redundant
  value= my_dict.get(&#39;key&#39;) # good
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;列表表达式，它们会让代码更好读&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  # not very good
  cube = []
  for i in res:
        cube.append((i[&#39;id&#39;],i[&#39;name&#39;]))
  # better
  cube = [(i[&#39;id&#39;], i[&#39;name&#39;]) for i in res]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;集合也可以作为布尔类型，空为 false，非空为 true。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  bool([]) is False
  bool([1]) is True
  bool([False]) is True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以你可以写 &lt;code&gt;if some_collection:&lt;/code&gt; 而不是 &lt;code&gt;if len(some_collection):&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;迭代&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  # creates a temporary list and looks bar
  for key in my_dict.keys():
        &amp;quot;do something...&amp;quot;
  # better
  for key in my_dict:
        &amp;quot;do something...&amp;quot;
  # creates a temporary list
  for key, value in my_dict.items():
        &amp;quot;do something...&amp;quot;
  # only iterates
  for key, value in my_dict.iteritems():
        &amp;quot;do something...&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;dict.setdefault&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  # longer.. harder to read
  values = {}
  for element in iterable:
    if element not in values:
        values[element] = []
    values[element].append(other_value)

  # better.. use dict.setdefault method
  values = {}
  for element in iterable:
    values.setdefault(element, []).append(other_value)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;好的开发者，要做好文档工作。&lt;/li&gt;
&lt;li&gt;更多的注意事项参看：&lt;a href=&#34;http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html&#34;&gt;http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;Programming in Odoo&#34;&gt;Programming in Odoo&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不要创建生成器和装饰漆，只使用odoo api中提供的&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;filtered&lt;/code&gt;，&lt;code&gt;mapped&lt;/code&gt;，&lt;code&gt;sorted&lt;/code&gt;&amp;hellip;等函数来提高可能性和性能&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;make-your-method-works-in-batch&#34;&gt;Make your method works in batch&lt;/h4&gt;

&lt;h4 id=&#34;propagate-the-context&#34;&gt;Propagate the context&lt;/h4&gt;

&lt;h4 id=&#34;do-not-bypass-the-orm&#34;&gt;Do not bypass the ORM&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# very very wrong
self.env.cr.execute(&#39;SELECT id FROM auction_lots WHERE auction_id in (&#39; + &#39;,&#39;.join(map(str, ids))+&#39;) AND state=%s AND obj_price &amp;gt; 0&#39;, (&#39;draft&#39;,))
auction_lots_ids = [x[0] for x in self.env.cr.fetchall()]

# no injection, but still wrong
self.env.cr.execute(&#39;SELECT id FROM auction_lots WHERE auction_id in %s &#39;\
           &#39;AND state=%s AND obj_price &amp;gt; 0&#39;, (tuple(ids), &#39;draft&#39;,))
auction_lots_ids = [x[0] for x in self.env.cr.fetchall()]

# better
auction_lots_ids = self.search([(&#39;auction_id&#39;,&#39;in&#39;,ids), (&#39;state&#39;,&#39;=&#39;,&#39;draft&#39;), (&#39;obj_price&#39;,&#39;&amp;gt;&#39;,0)])
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;no-sql-injections-please&#34;&gt;No SQL injections, please !&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# the following is very bad:
#   - it&#39;s a SQL injection vulnerability
#   - it&#39;s unreadable
#   - it&#39;s not your job to format the list of ids
self.env.cr.execute(&#39;SELECT distinct child_id FROM account_account_consol_rel &#39; +
           &#39;WHERE parent_id IN (&#39;+&#39;,&#39;.join(map(str, ids))+&#39;)&#39;)

# better
self.env.cr.execute(&#39;SELECT DISTINCT child_id &#39;\
           &#39;FROM account_account_consol_rel &#39;\
           &#39;WHERE parent_id IN %s&#39;,
           (tuple(ids),))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;keep-your-methods-short-simple-when-possible&#34;&gt;Keep your methods short/simple when possible&lt;/h4&gt;

&lt;h4 id=&#34;never-commit-the-transaction&#34;&gt;Never commit the transaction&lt;/h4&gt;

&lt;h4 id=&#34;use-translation-method-correctly&#34;&gt;Use translation method correctly&lt;/h4&gt;

&lt;h3 id=&#34;symbols-and-conventions&#34;&gt;Symbols and Conventions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;模块名&lt;/li&gt;
&lt;li&gt;Odoo中的python类：驼峰命名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  class AccountInvoice(models.Model):
      ...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;变量名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;One2Many&lt;/code&gt; 和 &lt;code&gt;Many2Many&lt;/code&gt;字段需要有 _ids 后缀，如：sale_order_line_ids&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Many2One&lt;/code&gt; 字段需要有 _id 后缀，如：partner_id, user_id, &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;Module&#34;&gt;Module&lt;/h1&gt;

&lt;p&gt;描述文件用来描述将 odoo 的模块，并定义该模块的元数据。它的文件名是&lt;code&gt;__manifest__.py&lt;/code&gt;，里边只包含一个 python 字典。&lt;/p&gt;

&lt;h2 id=&#34;manifest&#34;&gt;Manifest&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;{
    &#39;name&#39;: &amp;quot;A Module&amp;quot;,
    &#39;version&#39;: &#39;1.0&#39;,
    &#39;depends&#39;: [&#39;base&#39;],
    &#39;author&#39;: &amp;quot;Author Name&amp;quot;,
    &#39;category&#39;: &#39;Category&#39;,
    &#39;description&#39;: &amp;quot;&amp;quot;&amp;quot;
    Description text
    &amp;quot;&amp;quot;&amp;quot;,
    # data files always loaded at installation
    &#39;data&#39;: [
        &#39;mymodule_view.xml&#39;,
    ],
    # data files containing optionally loaded demonstration data
    &#39;demo&#39;: [
        &#39;demo_data.xml&#39;,
    ],
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;Web Controllers&#34;&gt;Web Controllers&lt;/h1&gt;

&lt;h2 id=&#34;routing&#34;&gt;Routing&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;odoo.http.route(route=None, **kw)&lt;/code&gt;&lt;br /&gt;
装饰器，用来装饰处理请求的函数，该函数，必须属于&lt;code&gt;Controller&lt;/code&gt;的子类&lt;/p&gt;

&lt;h2 id=&#34;request&#34;&gt;Request&lt;/h2&gt;

&lt;p&gt;request 的对象会在处理请求的时候自动判断并设置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;class odoo.http.WebRequest(httprequest)&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;class odoo.http.HttpRequest(*args)&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;class odoo.http.JsonRequest(*args)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;response&#34;&gt;Response&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;class odoo.http.Response(*args, **kw)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;controllers&#34;&gt;Controllers&lt;/h2&gt;

&lt;p&gt;控制器都继承了&lt;code&gt;class odoo.http.Controller&lt;/code&gt;，处理请求的方法使用&lt;code&gt;route&lt;/code&gt;来装饰&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MyController(odoo.http.Controller):
    @route(&#39;/some_url&#39;, auth=&#39;public&#39;)
    def handler(self):
        return stuff()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;覆盖一个控制器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Extension(MyController):
    @route()
    def handler(self):
        do_before()
        return super(Extension, self).handler()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;route&lt;/code&gt;装饰是为了让方法可见：如果一个方法被重新定义了，但是没有装饰，那么它不可见&lt;/li&gt;
&lt;li&gt;所有装饰过的方法都会整合在一起。如果方法的装饰器没有参数之前所有的定义都会被保留，任何新的参数都会覆盖之前的参数。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Restrict(MyController):
    @route(auth=&#39;user&#39;)
    def handler(self):
        return super(Restrict, self).handler()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会修改&lt;code&gt;/some_url&lt;/code&gt;的认证方式，从 public 改为 user（需要登录）。&lt;/p&gt;

&lt;h1 id=&#34;ORM API&#34;&gt;ORM API&lt;/h1&gt;

&lt;h2 id=&#34;Recordsets&#34;&gt;Recordsets&lt;/h2&gt;

&lt;p&gt;模型和记录之间的操作是通过 recordset 来进行的，同一个模型里排好序的记录集。定义在模型上的方法是通过 recordset 来执行的，他们的 self 就是 recordset。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class AModel(models.Model):
    _name = &#39;a.model&#39;
    def a_method(self):
        # self can be anywhere between 0 records and all records in the
        # database
        self.do_operation()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遍历一个 recordset 会返回一个单独的记录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def do_operation(self):
    print self # =&amp;gt; a.model(1, 2, 3, 4, 5)
    for record in self:
        print record # =&amp;gt; a.model(1), then a.model(2), then a.model(3), ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;源码中的实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;https://github.com/odoo/odoo/blob/59d1f9b564f1a4cec8a061e148725a3a9f7ac853/odoo/models.py#L5054

    def __iter__(self):
        &amp;quot;&amp;quot;&amp;quot; Return an iterator over ``self``. &amp;quot;&amp;quot;&amp;quot;
        for id in self._ids:
            yield self._browse((id,), self.env, self._prefetch)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;field-access&#34;&gt;Field access&lt;/h3&gt;

&lt;p&gt;Recordsets 提供一个接口可以直接访问模型的字段，设置一个值会触发更新数据库。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; record.name
Example Name
&amp;gt;&amp;gt;&amp;gt; record.company_id.name
Company Name
&amp;gt;&amp;gt;&amp;gt; record.name = &amp;quot;Bob&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问字段时，recordsets 里只能有一条记录，尝试从包含多条记录的 recordset 中读取模型字段会触发异常。&lt;/p&gt;

&lt;p&gt;访问关系型字段（Many2one，One2many，Many2many）总会返回一个 recordset，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：&lt;br /&gt;
每次设置字段都会触发一次数据库的更新，如果要同时设置多个字段，使用 &lt;code&gt;write&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 3 * len(records) database updates
for record in records:
    record.a = 1
    record.b = 2
    record.c = 3

# len(records) database updates
for record in records:
    record.write({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3})
 
# 1 database update
records.write({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3})
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;record-cache-and-prefetching&#34;&gt;Record cache and prefetching&lt;/h3&gt;

&lt;p&gt;Odoo 提供了缓存来保存记录的各个字段，所以不是每次对记录的访问都需要读取数据库。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;record.name             # first access reads value from database
record.name             # second access gets value from cache
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;set-operations&#34;&gt;Set operations&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;record in set&lt;/code&gt; &lt;code&gt;record not in set&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;set1 &amp;lt;= set2&lt;/code&gt; &lt;code&gt;set1 &amp;lt; set2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;set1 &amp;gt;= set2&lt;/code&gt; &lt;code&gt;set1 &amp;gt; set2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;set1 | set2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;set1 &amp;amp; set2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;set1 - set2&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;other-recordset-operations&#34;&gt;Other recordset operations&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;filtered()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mapped()&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;Environment&#34;&gt;Environment&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Environment&lt;/code&gt;中保存了大量 ORM 用到的上下文信息：数据库连接（用来查询数据库），当前用户（用来获取权限信息），当前的上下文（存储各种元数据）。而且里边还有缓存。&lt;/p&gt;

&lt;p&gt;所有的 recordsets 中都有一个不可变的 enviroment，可以通过 &lt;code&gt;env&lt;/code&gt; 获得，并可以通过它来获取当前用户（user），数据库连接（cr）和上下文（context）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; records.env
&amp;lt;Environment object ...&amp;gt;
&amp;gt;&amp;gt;&amp;gt; records.env.user
res.user(3)
&amp;gt;&amp;gt;&amp;gt; records.env.cr
&amp;lt;Cursor object ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当通过一个 recordset 创建另一个 recordset 时，enviroment 会被继承下来。enviroment 可以用来获得另外一个模型的空 recordset ，然后进行查询&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; self.env[&#39;res.partner&#39;]
res.partner
&amp;gt;&amp;gt;&amp;gt; self.env[&#39;res.partner&#39;].search([[&#39;is_company&#39;, &#39;=&#39;, True], [&#39;customer&#39;, &#39;=&#39;, True]])
res.partner(7, 18, 12, 14, 17, 19, 8, 31, 26, 16, 13, 20, 30, 22, 29, 15, 23, 28, 74)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;altering-the-environment&#34;&gt;Altering the environment&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sudo()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# create partner object as administrator
env[&#39;res.partner&#39;].sudo().create({&#39;name&#39;: &amp;quot;A Partner&amp;quot;})

# list partners visible by the &amp;quot;public&amp;quot; user
public = env.ref(&#39;base.public_user&#39;)
env[&#39;res.partner&#39;].sudo(public).search([])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;with_context()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# look for partner, or create one with specified timezone if none is
# found
env[&#39;res.partner&#39;].with_context(tz=a_tz).find_or_create(email_address)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;with_env()&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;Common ORM methods&#34;&gt;Common ORM methods&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; # searches the current model
&amp;gt;&amp;gt;&amp;gt; self.search([(&#39;is_company&#39;, &#39;=&#39;, True), (&#39;customer&#39;, &#39;=&#39;, True)])
res.partner(7, 18, 12, 14, 17, 19, 8, 31, 26, 16, 13, 20, 30, 22, 29, 15, 23, 28, 74)
&amp;gt;&amp;gt;&amp;gt; self.search([(&#39;is_company&#39;, &#39;=&#39;, True)], limit=1).name
&#39;Agrolait&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：&lt;br /&gt;
如果只是想检查记录的条数，可以使用&lt;code&gt;search_count()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;create()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; self.create({&#39;name&#39;: &amp;quot;New Name&amp;quot;})
res.partner(78)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;self.write({&#39;name&#39;: &amp;quot;Newer Name&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;browse()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; self.browse([7, 18, 12])
res.partner(7, 18, 12)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;exists()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if not record.exists():
    raise Exception(&amp;quot;The record has been deleted&amp;quot;)
    
records.may_remove_some()
# only keep records which were not deleted
records = records.exists()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ref()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; env.ref(&#39;base.group_public&#39;)
res.groups(2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ensure_one()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;records.ensure_one()
# is equivalent to but clearer than:
assert len(records) == 1, &amp;quot;Expected singleton&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;Creating Models&#34;&gt;Creating Models&lt;/h2&gt;

&lt;p&gt;模型的字段被定义为模型自身的属性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from odoo import models, fields
class AModel(models.Model):
    _name = &#39;a.model.name&#39;

    field1 = fields.Char()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;string&lt;/code&gt;属性，来定义字段的标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;field2 = fields.Integer(string=&amp;quot;an other field&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;default&lt;/code&gt;属性，来定义字段的默认值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a_field = fields.Char(default=&amp;quot;a value&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以用一个方法来计算默认值，这个方法必须返回这个字段的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def compute_default_value(self):
    return self.get_value()
a_field = fields.Char(default=compute_default_value)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;computed-fields&#34;&gt;Computed fields&lt;/h3&gt;

&lt;p&gt;通过使用 compute 参数设置一个函数，可以计算字段的值（而不只是从数据库中读取）。&lt;strong&gt;这个函数必须将计算好的值赋给对应的字段&lt;/strong&gt;。如果计算过程依赖了其它字段，要使用 depends() 来标明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from odoo import api
total = fields.Float(compute=&#39;_compute_total&#39;)

@api.depends(&#39;value&#39;, &#39;tax&#39;)
def _compute_total(self):
    for record in self:
        record.total = record.value + record.value * record.tax
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;依赖中可以引用子字段&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@api.depends(&#39;line_ids.value&#39;)
def _compute_total(self):
    for record in self:
      record.total = sum(line.value for line in record.line_ids)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可计算字段默认不会存储。设置&lt;code&gt;store=True&lt;/code&gt;会将字段保存到数据库，并自动允许查询。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过设置 search 参数，可以让可计算字段也能进行搜索&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;upper_name = field.Char(compute=&#39;_compute_upper&#39;, search=&#39;_search_upper&#39;)

def _search_upper(self, operator, value):
    if operator == &#39;like&#39;:
        operator = &#39;ilike&#39;
    return [(&#39;name&#39;, operator, value)]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过设置 inverse 参数，可以向可计算字段赋值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document = fields.Char(compute=&#39;_get_document&#39;, inverse=&#39;_set_document&#39;)

def _get_document(self):
    for record in self:
        with open(record.get_document_path) as f:
            record.document = f.read()
def _set_document(self):
    for record in self:
        if not record.document: continue
        with open(record.get_document_path()) as f:
            f.write(record.document)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置了同一个函数的多个可计算字段，可以一起获得值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;discount_value = fields.Float(compute=&#39;_apply_discount&#39;)
total = fields.Float(compute=&#39;_apply_discount&#39;)

@depends(&#39;value&#39;, &#39;discount&#39;)
def _apply_discount(self):
    for record in self:
        # compute actual discount from discount percentage
        discount = record.value * record.discount
        record.discount_value = discount
        record.total = record.value - discount
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;related-fields&#34;&gt;Related fields&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;nickname = fields.Char(related=&#39;user_id.partner_id.name&#39;, store=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;onchange-updating-ui-on-the-fly&#34;&gt;onchange: updating UI on the fly&lt;/h3&gt;

&lt;p&gt;当用户修改表单中的值时，可以根据新的值自动修改其它字段的值。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可计算字段本身就可以检查并重新计算，他们不需要 onchange&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不可计算字段，可以通过 onchange() 装饰器来获得此功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@api.onchange(&#39;field1&#39;, &#39;field2&#39;) # if these fields are changed, call method
def check_change(self):
    if self.field1 &amp;lt; self.field2:
        self.field3 = True
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Both computed fields and new-API onchanges are automatically called by the client without having to add them in views&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It is possible to suppress the trigger from a specific field by adding on_change=&amp;ldquo;0&amp;rdquo; in a view:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;field name=&amp;quot;name&amp;quot; on_change=&amp;quot;0&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will not trigger any interface update when the field is edited by the user, even if there are function fields or explicit onchange depending on that field.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;onchange 不会修改数据库记录。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;low-level-sql&#34;&gt;Low-level SQL&lt;/h3&gt;

&lt;p&gt;enviroment 中的 cr 属性是当前连接数据库事务的一个游标，通过它可以直接执行 SQL 从而实现复杂的查询语句。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.env.cr.execute(&amp;quot;some_sql&amp;quot;, param1, param2, param3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为其它模型也在使用同一个游标，而且 enviroment 中还保存了大量的缓存，当使用原始 SQL 修改数据库的时候，要让这些缓存都失效。在使用 CREATE，UPDATE，DELETE 后都应该清理缓存。&lt;/p&gt;

&lt;p&gt;清除缓存可以使用 enviroment 的 invalidate_all() 方法。&lt;/p&gt;

&lt;h2 id=&#34;Compatibility between new API and old API&#34;&gt;Compatibility between new API and old API&lt;/h2&gt;

&lt;p&gt;Odoo 正在逐步从老的api过渡到新的。&lt;/p&gt;

&lt;p&gt;新老 api 最大的区别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;老 api 中，enviroment 中的值（cursor, user id and context）是显式传递的&lt;/li&gt;
&lt;li&gt;老 api 中，记录信息（ids）是显式传递的&lt;/li&gt;
&lt;li&gt;老 api 中，方法都是基于 ids 列表工作，而不是 recordset&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; # method in the old API style
&amp;gt;&amp;gt;&amp;gt; def old_method(self, cr, uid, ids, context=None):
...    print ids

&amp;gt;&amp;gt;&amp;gt; # method in the new API style
&amp;gt;&amp;gt;&amp;gt; def new_method(self):
...     # system automatically infers how to call the old-style
...     # method from the new-style method
...     self.old_method()

&amp;gt;&amp;gt;&amp;gt; env[model].browse([1, 2, 3, 4]).new_method()
[1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;Model Reference&#34;&gt;Model Reference&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;class odoo.models.Model(pool, cr)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Odoo的模型都继承了这个类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class user(Model):
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;structural-attributes&#34;&gt;Structural attributes&lt;/h3&gt;

&lt;h3 id=&#34;crud&#34;&gt;CRUD&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;create(vals) → record&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;browse([ids]) → records&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;unlink()&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;write(vals)&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;read([fields])&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;read_group(domain, fields, groupby, offset=0, limit=None, orderby=False, lazy=True)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;searching&#34;&gt;Searching&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;search(args[, offset=0][, limit=None][, order=None][, count=False])&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;search_count(args) → int&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;name_search(name=&#39;&#39;, args=None, operator=&#39;ilike&#39;, limit=100) → records&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;recordset-operations&#34;&gt;Recordset operations&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ids&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;ensure_one()&lt;/code&gt;
&lt;code&gt;exists() → records&lt;/code&gt;
&lt;code&gt;filtered(func)&lt;/code&gt;
&lt;code&gt;sorted(key=None, reverse=False)&lt;/code&gt;
&lt;code&gt;mapped(func)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;environment-swapping&#34;&gt;Environment swapping&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sudo([user=SUPERUSER])&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;with_context([context][, **overrides]) → records&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;with_env(env)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;fields-and-views-querying&#34;&gt;Fields and views querying&lt;/h3&gt;

&lt;h3 id=&#34;toc_34&#34;&gt;???&lt;/h3&gt;

&lt;h3 id=&#34;automatic-fields&#34;&gt;Automatic fields&lt;/h3&gt;

&lt;h3 id=&#34;reserved-field-names&#34;&gt;Reserved field names&lt;/h3&gt;

&lt;h2 id=&#34;Method decorators&#34;&gt;Method decorators&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;odoo.api.multi(method)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;odoo.api.model(method)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;odoo.api.depends(*args)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;odoo.api.constrains(*args)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;odoo.api.onchange(*args)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;odoo.api.returns(model, downgrade=None, upgrade=None)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;odoo.api.one(method)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;Fields&#34;&gt;Fields&lt;/h2&gt;

&lt;h3 id=&#34;basic-fields&#34;&gt;Basic fields&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;class odoo.fields.Field(string=&amp;lt;object object&amp;gt;, **kwargs)&lt;/code&gt;&lt;br /&gt;
所有字段类型的基础&lt;/p&gt;

&lt;h5 id=&#34;computed-fields-1&#34;&gt;Computed fields&lt;/h5&gt;

&lt;h5 id=&#34;related-fields-1&#34;&gt;Related fields&lt;/h5&gt;

&lt;h5 id=&#34;company-dependent-fields&#34;&gt;Company-dependent fields&lt;/h5&gt;

&lt;h5 id=&#34;sparse-fields&#34;&gt;Sparse fields&lt;/h5&gt;

&lt;h5 id=&#34;incremental-definition&#34;&gt;Incremental definition&lt;/h5&gt;

&lt;h3 id=&#34;relational-fields&#34;&gt;Relational fields&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;class odoo.fields.Many2one(comodel_name=&amp;lt;object object&amp;gt;, string=&amp;lt;object object&amp;gt;, **kwargs)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;class odoo.fields.One2many(comodel_name=&amp;lt;object object&amp;gt;, inverse_name=&amp;lt;object object&amp;gt;, string=&amp;lt;object object&amp;gt;, **kwargs)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;class odoo.fields.Many2many(comodel_name=&amp;lt;object object&amp;gt;, relation=&amp;lt;object object&amp;gt;, column1=&amp;lt;object object&amp;gt;, column2=&amp;lt;object object&amp;gt;, string=&amp;lt;object object&amp;gt;, **kwargs)&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;Data Files&#34;&gt;Data Files&lt;/h1&gt;

&lt;h2 id=&#34;structure&#34;&gt;Structure&lt;/h2&gt;

&lt;p&gt;Odoo中的数据文件之一是 XML，它的结构是
* 包含在 odoo 标签里的多个操作元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- the root elements of the data file --&amp;gt;
&amp;lt;odoo&amp;gt;
  &amp;lt;operation/&amp;gt;
  ...
&amp;lt;/odoo&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;core-operations&#34;&gt;Core operations&lt;/h2&gt;

&lt;h4 id=&#34;record&#34;&gt;record&lt;/h4&gt;

&lt;p&gt;定义或者更新数据库中的记录，有如下的属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;model（required）&lt;/li&gt;
&lt;li&gt;id&lt;/li&gt;
&lt;li&gt;context&lt;/li&gt;
&lt;li&gt;field&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;delete&#34;&gt;delete&lt;/h4&gt;

&lt;p&gt;删除数据库中的多条记录，有如下属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;model（required）&lt;/li&gt;
&lt;li&gt;id&lt;/li&gt;
&lt;li&gt;search&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;id&lt;/code&gt; 和 &lt;code&gt;search&lt;/code&gt;二选一&lt;/p&gt;

&lt;h4 id=&#34;function&#34;&gt;function&lt;/h4&gt;

&lt;h4 id=&#34;workflow&#34;&gt;workflow&lt;/h4&gt;

&lt;p&gt;这个标签会发送一个信号给指定的工作流。工作流的名字可以通过 ref 属性来指定。&lt;/p&gt;

&lt;h2 id=&#34;shortcuts&#34;&gt;Shortcuts&lt;/h2&gt;

&lt;p&gt;有些重要的模型用起来比较麻烦，所以提供了一种简单的使用方式&lt;/p&gt;

&lt;h4 id=&#34;menuitem&#34;&gt;menuitem&lt;/h4&gt;

&lt;p&gt;创建一个&lt;code&gt;ir.ui.menu&lt;/code&gt;记录&lt;/p&gt;

&lt;h4 id=&#34;template&#34;&gt;template&lt;/h4&gt;

&lt;p&gt;创建一个QWeb模版&lt;/p&gt;

&lt;h4 id=&#34;report&#34;&gt;report&lt;/h4&gt;

&lt;p&gt;创建一个ir.actions.report.xml记录&lt;/p&gt;

&lt;h2 id=&#34;csv-data-files&#34;&gt;CSV data files&lt;/h2&gt;

&lt;p&gt;常用在设置模块的访问权限上&lt;/p&gt;

&lt;h1 id=&#34;QWeb&#34;&gt;QWeb&lt;/h1&gt;

&lt;p&gt;QWeb 是odoo使用的模版引擎。
模版命令是含有前缀 &lt;code&gt;t-&lt;/code&gt; 的 xml 属性，例如&lt;code&gt;t-if&lt;/code&gt;是条件表达式。
为了避免错误的代码生成，提供了一个标签 &lt;code&gt;&amp;lt;t&amp;gt;&lt;/code&gt; ，这个标签会直接执行，而不生成任何的 html 代码。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;t t-if=&amp;quot;condition&amp;quot;&amp;gt;
    &amp;lt;p&amp;gt;Test&amp;lt;/p&amp;gt;
&amp;lt;/t&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;p&amp;gt;Test&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;div t-if=&amp;quot;condition&amp;quot;&amp;gt;
    &amp;lt;p&amp;gt;Test&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Test&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;data-output&#34;&gt;data output&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;t t-esc=&amp;quot;value&amp;quot;/&amp;gt;&amp;lt;/p&amp;gt; 会对value里的值进行转码
&amp;lt;p&amp;gt;&amp;lt;t t-raw=&amp;quot;value&amp;quot;/&amp;gt;&amp;lt;/p&amp;gt; 输出value中的原始值
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditionals&#34;&gt;conditionals&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    &amp;lt;t t-if=&amp;quot;condition&amp;quot;&amp;gt;
        &amp;lt;p&amp;gt;ok&amp;lt;/p&amp;gt;
    &amp;lt;/t&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;
    &amp;lt;p t-if=&amp;quot;user.birthday == today()&amp;quot;&amp;gt;Happy bithday!&amp;lt;/p&amp;gt;
    &amp;lt;p t-elif=&amp;quot;user.login == &#39;root&#39;&amp;quot;&amp;gt;Welcome master!&amp;lt;/p&amp;gt;
    &amp;lt;p t-else=&amp;quot;&amp;quot;&amp;gt;Welcome!&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;loops&#34;&gt;loops&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;t t-foreach=&amp;quot;[1, 2, 3]&amp;quot; t-as=&amp;quot;i&amp;quot;&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;t t-esc=&amp;quot;i&amp;quot;/&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/t&amp;gt;

&amp;lt;p t-foreach=&amp;quot;[1, 2, 3]&amp;quot; t-as=&amp;quot;i&amp;quot;&amp;gt;
    &amp;lt;t t-esc=&amp;quot;i&amp;quot;/&amp;gt;
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;attributes&#34;&gt;attributes&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;t-att-$name&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div t-att-a=&amp;quot;42&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;t-attf-$name&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;t t-foreach=&amp;quot;[1, 2, 3]&amp;quot; t-as=&amp;quot;item&amp;quot;&amp;gt;
    &amp;lt;li t-attf-class=&amp;quot;row {{ item_parity }}&amp;quot;&amp;gt;&amp;lt;t t-esc=&amp;quot;item&amp;quot;/&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/t&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;t-att=mapping&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div t-att=&amp;quot;{&#39;a&#39;: 1, &#39;b&#39;: 2}&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;t-att=pair&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div t-att=&amp;quot;[&#39;a&#39;, &#39;b&#39;]&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;setting-variables&#34;&gt;setting variables&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;t t-set=&amp;quot;foo&amp;quot; t-value=&amp;quot;2 + 1&amp;quot;/&amp;gt;
&amp;lt;t t-esc=&amp;quot;foo&amp;quot;/&amp;gt;

&amp;lt;t t-set=&amp;quot;foo&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;ok&amp;lt;/li&amp;gt;
&amp;lt;/t&amp;gt;
&amp;lt;t t-esc=&amp;quot;foo&amp;quot;/&amp;gt;  会输出&amp;amp;lt;li&amp;amp;gt;ok&amp;amp;lt;/li&amp;amp;gt; 因为 t-esc 会进行转码
&amp;lt;t t-raw=&amp;quot;foo&amp;quot;/&amp;gt;  会输出&amp;lt;li&amp;gt;ok&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;calling-sub-templates&#34;&gt;calling sub-templates&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;t t-call=&amp;quot;other-template&amp;quot;&amp;gt;
    &amp;lt;t t-set=&amp;quot;var&amp;quot; t-value=&amp;quot;1&amp;quot;/&amp;gt;
&amp;lt;/t&amp;gt;
&amp;lt;!-- &amp;quot;var&amp;quot; does not exist here --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;Views&#34;&gt;Views&lt;/h1&gt;

&lt;h3 id=&#34;common-structure&#34;&gt;Common Structure&lt;/h3&gt;

&lt;p&gt;视图对象有很多属性，它们都是可选的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;name&lt;/li&gt;
&lt;li&gt;model&lt;/li&gt;
&lt;li&gt;priority&lt;/li&gt;
&lt;li&gt;arch&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下为Odoo中的视图种类&lt;/p&gt;

&lt;h3 id=&#34;lists&#34;&gt;Lists&lt;/h3&gt;

&lt;p&gt;创建列表视图的标签是 &lt;code&gt;&amp;lt;tree&amp;gt;&lt;/code&gt;，它有如下属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;editable&lt;/li&gt;
&lt;li&gt;default_order&lt;/li&gt;
&lt;li&gt;create, edit, delete&lt;br /&gt;
通过对这些属性设置值&lt;code&gt;false&lt;/code&gt;，可以禁止对应的事件&lt;/li&gt;
&lt;li&gt;on_write&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可能出现的子元素&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;button
在表格上显示一个按钮&lt;/li&gt;
&lt;li&gt;field
用来定义模型的那些字段可以显示在列表里&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;forms&#34;&gt;Forms&lt;/h3&gt;

&lt;p&gt;表单视图用来显示单条记录的数据。使用标签 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;structural-components&#34;&gt;Structural components&lt;/h4&gt;

&lt;p&gt;结构组件用来提供展示结构。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;notebook&lt;/li&gt;
&lt;li&gt;group&lt;/li&gt;
&lt;li&gt;newline&lt;/li&gt;
&lt;li&gt;separator&lt;/li&gt;
&lt;li&gt;sheet&lt;/li&gt;
&lt;li&gt;header&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;semantic-components&#34;&gt;Semantic components&lt;/h4&gt;

&lt;p&gt;Semantic 组件用来和 odoo 系统进行交互操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;button
同 list view 中的按钮类似&lt;/li&gt;
&lt;li&gt;field&lt;br /&gt;
显示当前记录中的一个字段，有以下属性

&lt;ul&gt;
&lt;li&gt;name&lt;/li&gt;
&lt;li&gt;widget&lt;/li&gt;
&lt;li&gt;options&lt;/li&gt;
&lt;li&gt;class&lt;/li&gt;
&lt;li&gt;groups&lt;/li&gt;
&lt;li&gt;on_change&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;business-views-guidelines&#34;&gt;Business Views guidelines&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://www.odoo.com/documentation/10.0/_images/oppreadonly.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一般来说业务视图由以下3部分组成：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;顶部的状态栏&lt;/li&gt;
&lt;li&gt;中间的表格&lt;/li&gt;
&lt;li&gt;底部的历史记录和评论&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现起来就像下边的 XML 一样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form&amp;gt;
    &amp;lt;header&amp;gt; ... content of the status bar  ... &amp;lt;/header&amp;gt;
    &amp;lt;sheet&amp;gt;  ... content of the sheet       ... &amp;lt;/sheet&amp;gt;
    &amp;lt;div class=&amp;quot;oe_chatter&amp;quot;&amp;gt; ... content of the bottom part ... &amp;lt;/div&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;状态栏&#34;&gt;状态栏&lt;/h5&gt;

&lt;p&gt;状态栏用来显示当前记录的状态并提供一些操作按钮。&lt;/p&gt;

&lt;h6 id=&#34;按钮&#34;&gt;按钮&lt;/h6&gt;

&lt;p&gt;按钮的顺序根据业务来决定。例如，对于销售来说，一般的顺序是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;发报价单&lt;/li&gt;
&lt;li&gt;确认报价单&lt;/li&gt;
&lt;li&gt;创建最终的发货单&lt;/li&gt;
&lt;li&gt;发货&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;高亮的按钮用来提醒用户下一步是什么。一般放在最前边。而取消按钮（cancel）一般都是灰色的。
按钮的定义方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button name=&amp;quot;post&amp;quot; states=&amp;quot;draft&amp;quot; string=&amp;quot;Post&amp;quot; type=&amp;quot;object&amp;quot; class=&amp;quot;oe_highlight&amp;quot; groups=&amp;quot;account.group_account_invoice&amp;quot;/&amp;gt;
&amp;lt;button name=&amp;quot;%(action_view_account_move_reversal)d&amp;quot; states=&amp;quot;posted&amp;quot; string=&amp;quot;Reverse Entry&amp;quot; type=&amp;quot;action&amp;quot; groups=&amp;quot;account.group_account_invoice&amp;quot;/&amp;gt;
&amp;lt;button name=&amp;quot;button_cancel&amp;quot; states=&amp;quot;posted&amp;quot; string=&amp;quot;Cancel Entry&amp;quot; type=&amp;quot;object&amp;quot; groups=&amp;quot;account.group_account_invoice&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;状态&#34;&gt;状态&lt;/h6&gt;

&lt;p&gt;使用 &lt;code&gt;statusbar&lt;/code&gt; 插件，当前的状态显示红色。
显示的状态用属性 &lt;code&gt;statusbar_visible&lt;/code&gt; 来定义。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;field name=&amp;quot;state&amp;quot; widget=&amp;quot;statusbar&amp;quot;
    statusbar_visible=&amp;quot;draft,sent,progress,invoiced,done&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;表格&#34;&gt;表格&lt;/h4&gt;

&lt;h5 id=&#34;表头&#34;&gt;表头&lt;/h5&gt;

&lt;h5 id=&#34;按钮区&#34;&gt;按钮区&lt;/h5&gt;

&lt;h5 id=&#34;分组和标题&#34;&gt;分组和标题&lt;/h5&gt;

&lt;h3 id=&#34;graphs&#34;&gt;Graphs&lt;/h3&gt;

&lt;h3 id=&#34;kanban&#34;&gt;Kanban&lt;/h3&gt;

&lt;h3 id=&#34;calendar&#34;&gt;Calendar&lt;/h3&gt;

&lt;h3 id=&#34;gantt&#34;&gt;Gantt&lt;/h3&gt;

&lt;h3 id=&#34;diagram&#34;&gt;Diagram&lt;/h3&gt;

&lt;h3 id=&#34;search&#34;&gt;Search&lt;/h3&gt;

&lt;p&gt;&amp;hellip;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>odoo自定义模块</title>
      <link>https://asdfsx.github.io/post/odoo/odoo%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Fri, 13 Jan 2017 11:46:33 +0800</pubDate>
      
      <guid>https://asdfsx.github.io/post/odoo/odoo%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/</guid>
      <description>

&lt;p&gt;复制 &lt;a href=&#34;http://blog.sunansheng.com/python/odoo/odoo.html&#34;&gt;http://blog.sunansheng.com/python/odoo/odoo.html&lt;/a&gt; 中的请假单例子，创建一个带工作流的例子，工作环境是&lt;code&gt;odoo 10.0&lt;/code&gt;。&lt;br /&gt;
PS：在这个版本中官方自带的请假模块删掉了工作流～～何等的卧槽！&lt;/p&gt;

&lt;h3 id=&#34;创建模块模版&#34;&gt;创建模块模版：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;python odoo/odoo-bin scaffold qingjia odoo_dev/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;odoo_dev&lt;/code&gt;目录中可以找到新创建的模块，进入目录以后可以看到如下的目录结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;controllers  demo  __init__.py  __manifest__.py  models  security  views
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;__init__.py&lt;/code&gt;不需要修改&lt;br /&gt;
&lt;code&gt;__manifest__.py&lt;/code&gt;需要增加一点东西&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;application&amp;quot;: True,
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;创建模型&#34;&gt;创建模型&lt;/h3&gt;

&lt;p&gt;修改&lt;code&gt;models/model.py&lt;/code&gt;文件。添加新的模型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-

from odoo import models, fields, api

class Qingjd(models.Model):
    _name = &#39;qingjia.qingjd&#39;
    
    name = fields.Many2one(&#39;res.users&#39;, string=&amp;quot;申请人&amp;quot;, required=True)
    days = fields.Float(string=&amp;quot;天数&amp;quot;, required=True)
    startdate = fields.Date(string=&amp;quot;开始日期&amp;quot;, required=True)
    reason = fields.Text(string=&amp;quot;请假事由&amp;quot;)
    
    def send_qingjd(self):
        self.sended = True
        return self.sended
        
    def confirm_qingjd(self):
        self.state = &#39;confirmed&#39;
        return self.state
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;修改controller&#34;&gt;修改controller&lt;/h3&gt;

&lt;p&gt;修改&lt;code&gt;controllers/controller.py&lt;/code&gt;文件。由模版创建的&lt;code&gt;controller&lt;/code&gt;已经提供了最基础的功能，只需要去掉注释，做简单的修改就可以使用（主要是和新添加的模型做个对应）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
from odoo import http
class Qingjia(http.Controller):
    @http.route(&#39;/qingjia/qingjia&#39;, auth=&#39;public&#39;)
    def index(self, **kw):
        return &amp;quot;Hello, world&amp;quot;
        
    @http.route(&#39;/qingjia/qingjia/objects/&#39;, auth=&#39;public&#39;)
    def list(self, **kw):
        return http.request.render(&#39;qingjia.listing&#39;, {
            &#39;root&#39;: &#39;/qingjia/qingjia&#39;,
            &#39;objects&#39;: http.request.env[&#39;qingjia.qingjd&#39;].search([]),
        })

    @http.route(&#39;/qingjia/qingjia/objects/&amp;lt;model(&amp;quot;qingjia.qingjd&amp;quot;):obj&amp;gt;/&#39;, auth=&#39;public&#39;)
    def object(self, **kw):
        return http.request.render(&#39;qingjia.object&#39;, {
            &#39;object&#39;: obj,
        })

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;修改模版&#34;&gt;修改模版&lt;/h3&gt;

&lt;p&gt;在&lt;code&gt;controller&lt;/code&gt;中，可以看到使用了两个模版&lt;code&gt;qingjia.listing&lt;/code&gt;和&lt;code&gt;qingjia.object&lt;/code&gt;。这两个模版定义在&lt;code&gt;views/templates.xml&lt;/code&gt;文件中，只不过现在被注释掉了。只需要去掉注释就可以了，不需要做任何修改。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;odoo&amp;gt;
    &amp;lt;data&amp;gt;
        &amp;lt;template id=&amp;quot;listing&amp;quot;&amp;gt;
            &amp;lt;ul&amp;gt;
                &amp;lt;li t-foreach=&amp;quot;objects&amp;quot; t-as=&amp;quot;object&amp;quot;&amp;gt;
                    &amp;lt;a t-attf-href=&amp;quot;#{ root }/objects/#{ object.id }&amp;quot;&amp;gt;
                        &amp;lt;t t-esc=&amp;quot;object.display_name&amp;quot;/&amp;gt;
                    &amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
        &amp;lt;/template&amp;gt;
        &amp;lt;template id=&amp;quot;object&amp;quot;&amp;gt;
            &amp;lt;h1&amp;gt;&amp;lt;t t-esc=&amp;quot;object.display_name&amp;quot;/&amp;gt;&amp;lt;/h1&amp;gt;
            &amp;lt;dl&amp;gt;
                &amp;lt;t t-foreach=&amp;quot;object._fields&amp;quot; t-as=&amp;quot;field&amp;quot;&amp;gt;
                    &amp;lt;dt&amp;gt;&amp;lt;t t-esc=&amp;quot;field&amp;quot;/&amp;gt;&amp;lt;/dt&amp;gt;
                    &amp;lt;dd&amp;gt;&amp;lt;t t-esc=&amp;quot;object[field]/&amp;gt;&amp;lt;/dd&amp;gt;
                &amp;lt;/t&amp;gt;
            &amp;lt;/dl&amp;gt;
        &amp;lt;/template&amp;gt;
    &amp;lt;/data&amp;gt;
&amp;lt;/odoo&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;修改视图&#34;&gt;修改视图&lt;/h3&gt;

&lt;p&gt;视图的信息定义在&lt;code&gt;views/views.xml&lt;/code&gt;中。模版生成内容都被注释了，直接添加自己的内容好了。我们也可以从零开始。&lt;/p&gt;

&lt;p&gt;首先先把文件的框架建好&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;odoo&amp;gt;
    &amp;lt;data&amp;gt;
    &amp;lt;/data&amp;gt;
&amp;lt;/odoo&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;修改导航按钮&#34;&gt;修改导航按钮&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;menuitem id=&amp;quot;menu_qingjia&amp;quot; name=&amp;quot;请假&amp;quot; sequence=&amp;quot;0&amp;quot;&amp;gt;&amp;lt;/menuitem&amp;gt;
&amp;lt;menuitem id=&amp;quot;menu_qingjia_qingjiadan&amp;quot; name=&amp;quot;请假单&amp;quot; parent=&amp;quot;menu_qingjia&amp;quot;&amp;gt;&amp;lt;/menuitem&amp;gt;
&amp;lt;menuitem id=&amp;quot;menu_qingjia_qingjiadan_qingjiadan&amp;quot; name=&amp;quot;列表&amp;quot; parent=&amp;quot;menu_qingjia_qingjiadan&amp;quot; action=&amp;quot;action_qingjia_qingjd&amp;quot;&amp;gt;&amp;lt;/menuitem&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;修改列表页&#34;&gt;修改列表页&lt;/h5&gt;

&lt;p&gt;在&lt;code&gt;views/views.xml&lt;/code&gt;中增加对列表页的定义。可以借鉴模版生成的&lt;code&gt;qingjia.list&lt;/code&gt;模版，只需要修改下字段就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;record model=&amp;quot;ir.ui.view&amp;quot; id=&amp;quot;qingjia.list&amp;quot;&amp;gt;
    &amp;lt;field name=&amp;quot;name&amp;quot;&amp;gt;qingjia list&amp;lt;/field&amp;gt;
    &amp;lt;field name=&amp;quot;model&amp;quot;&amp;gt;qingjia.qingjd&amp;lt;/field&amp;gt;
    &amp;lt;field name=&amp;quot;arch&amp;quot; type=&amp;quot;xml&amp;quot;&amp;gt;
        &amp;lt;tree&amp;gt;
            &amp;lt;field name=&amp;quot;name&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;days&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;startdate&amp;quot;/&amp;gt;
        &amp;lt;/tree&amp;gt;
    &amp;lt;/field&amp;gt;
&amp;lt;/record&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;修改详情页&#34;&gt;修改详情页&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;record id=&amp;quot;action_qingjia_qingjd&amp;quot; model=&amp;quot;ir.actions.act_window&amp;quot;&amp;gt;
    &amp;lt;field name=&amp;quot;name&amp;quot;&amp;gt;请假单&amp;lt;/field&amp;gt;
    &amp;lt;field name=&amp;quot;res_model&amp;quot;&amp;gt;qingjia.qingjd&amp;lt;/field&amp;gt;
    &amp;lt;field name=&amp;quot;view_mode&amp;quot;&amp;gt;tree,form&amp;lt;/field&amp;gt;
&amp;lt;/record&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;code&gt;tree,form&lt;/code&gt;之间不能有空格，不然会报错～～～&lt;/p&gt;

&lt;p&gt;也可以对详情页进行定制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;record id=&amp;quot;action_qingjia_qingjd&amp;quot; model=&amp;quot;ir.actions.act_window&amp;quot;&amp;gt;
    &amp;lt;field name=&amp;quot;name&amp;quot;&amp;gt;请假单&amp;lt;/field&amp;gt;
    &amp;lt;field name=&amp;quot;res_model&amp;quot;&amp;gt;qingjia.qingjd&amp;lt;/field&amp;gt;
    &amp;lt;field name=&amp;quot;arch&amp;quot; type=&amp;quot;xml&amp;quot;&amp;gt;
        &amp;lt;form&amp;gt;
        &amp;lt;sheet&amp;gt;
        &amp;lt;label for=&amp;quot;name&amp;quot;/&amp;gt;&amp;lt;field name=&amp;quot;name&amp;quot;/&amp;gt;
        &amp;lt;label for=&amp;quot;days&amp;quot;/&amp;gt;&amp;lt;field name=&amp;quot;days&amp;quot;/&amp;gt;
        &amp;lt;label for=&amp;quot;startdate&amp;quot;/&amp;gt;&amp;lt;field name=&amp;quot;startdate&amp;quot;/&amp;gt;
        &amp;lt;label for=&amp;quot;reason&amp;quot;/&amp;gt;&amp;lt;field name=&amp;quot;reason&amp;quot;/&amp;gt;
        &amp;lt;/sheet&amp;gt;
        &amp;lt;/form&amp;gt;
    &amp;lt;/field&amp;gt;
&amp;lt;/record&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;record id=&amp;quot;action_qingjia_qingjd&amp;quot; model=&amp;quot;ir.actions.act_window&amp;quot;&amp;gt;
    &amp;lt;field name=&amp;quot;name&amp;quot;&amp;gt;请假单&amp;lt;/field&amp;gt;
    &amp;lt;field name=&amp;quot;res_model&amp;quot;&amp;gt;qingjia.qingjd&amp;lt;/field&amp;gt;
    &amp;lt;field name=&amp;quot;arch&amp;quot; type=&amp;quot;xml&amp;quot;&amp;gt;
        &amp;lt;form&amp;gt;
        &amp;lt;group&amp;gt;
            &amp;lt;field name=&amp;quot;name&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;days&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;startdate&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;reason&amp;quot;/&amp;gt;
        &amp;lt;/group&amp;gt;
        &amp;lt;/form&amp;gt;
    &amp;lt;/field&amp;gt;
&amp;lt;/record&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目前这个例子还比较简单，看不出来&lt;code&gt;group&lt;/code&gt;的作用。&lt;/p&gt;

&lt;p&gt;完成以上内容，就可以试着安装一下新模块了。&lt;/p&gt;

&lt;h3 id=&#34;工作流&#34;&gt;工作流&lt;/h3&gt;

&lt;p&gt;为了实现工作流，需要对模型进行修改&lt;/p&gt;

&lt;h5 id=&#34;修改模型&#34;&gt;修改模型&lt;/h5&gt;

&lt;p&gt;注意 odoo 10 不再支持旧版的api，即&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    def draft(self, cr, uid, ids, context=None):
        self.write(cr, uid, ids, {&#39;state&#39;:&#39;draft&#39;}, context=context)
        return True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新版本里，从某种意义上对api进行了一些简化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @api.model
    def draft(self):
        self.write({&#39;state&#39;:&#39;draft&#39;})
        return True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下为完整代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Qingjd(models.Model):
    _name = &#39;qingjia.qingjd&#39;
    name = fields.Many2one(&#39;res.users&#39;, string=&amp;quot;申请人&amp;quot;, required=True)
    manager = fields.Many2one(&#39;res.users&#39;, string=&amp;quot;主管&amp;quot;, required=True)
    beginning = fields.Date(string=&amp;quot;开始日期&amp;quot;, required=True, default=fields.Datetime.now())
    ending = fields.Date(string=&amp;quot;结束日期&amp;quot;, required=True)
    reason = fields.Text(string=&amp;quot;请假事由&amp;quot;, required=True)
    accept_reason = fields.Text(string=&amp;quot;同意理由&amp;quot;, default=&amp;quot;同意&amp;quot;)

    current_name = fields.Many2one(&#39;res.users&#39;, string=&amp;quot;当前登录人&amp;quot;, compute=&amp;quot;_get_current_name&amp;quot;)
    is_manager = fields.Boolean(compute=&amp;quot;_get_is_manager&amp;quot;)

    state = fields.Selection([(&#39;draft&#39;,&#39;草稿&#39;),
                              (&#39;confirmed&#39;,&#39;待审批&#39;),
                              (&#39;accepted&#39;,&#39;批准&#39;),
                              (&#39;rejected&#39;,&#39;拒绝&#39;),],
                              string=&#39;状态&#39;, default=&#39;draft&#39;, readonly=True)

    @api.model
    def _get_default_name(self):
        uid = self.env.uid
        res = self.env[&#39;resource.resource&#39;].search([(&#39;user_id&#39;, &#39;=&#39;, uid)]) 
        name = res.name
        employee = self.env[&#39;hr.employee&#39;].search([(&#39;name_related&#39;,&#39;=&#39;,name)])
        return employee

    @api.model
    def _get_default_manager(self):
        uid = self.env.uid
        res = self.env[&#39;resource.resource&#39;].search([(&#39;user_id&#39;, &#39;=&#39;, uid)])
        name = res.name
        employee = self.env[&#39;hr.employee&#39;].search([(&#39;name_related&#39;,&#39;=&#39;,name)])
        return employee.parent_id
    

    defaults = {&#39;name&#39;:_get_default_name,&#39;manager&#39;:_get_default_manager,}

    def _get_is_manager(self):
        if self.current_name == self.manager:
            self.is_manager = True
        else:
            self.is_manager = False

    def _get_current_name(self):
        uid = self.env.uid
        res = self.env[&#39;res.users&#39;].search([(&#39;id&#39;, &#39;=&#39;, uid)])
        self.current_name = res

    @api.model
    def draft(self):
        self.write({&#39;state&#39;:&#39;draft&#39;})
        return True

    @api.model
    def confirm(self):
        self.write({&#39;state&#39;:&#39;confirmed&#39;})
        return True

    @api.model
    def accept(self):
        self.write({&#39;state&#39;:&#39;accepted&#39;})
        return True

    @api.model
    def reject(self):
        self.write({&#39;state&#39;:&#39;rejected&#39;})
        return True
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;增加视图&#34;&gt;增加视图&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;record model=&amp;quot;ir.ui.view&amp;quot; id=&amp;quot;qingjia.qingjia_qingjd_form&amp;quot;&amp;gt;
        &amp;lt;field name=&amp;quot;name&amp;quot;&amp;gt;qing jia dan form&amp;lt;/field&amp;gt;
        &amp;lt;field name=&amp;quot;model&amp;quot;&amp;gt;qingjia.qingjd&amp;lt;/field&amp;gt;
        &amp;lt;field name=&amp;quot;arch&amp;quot; type=&amp;quot;xml&amp;quot;&amp;gt;
            &amp;lt;form&amp;gt;
            &amp;lt;header&amp;gt;
                &amp;lt;button name=&amp;quot;btn_confirm&amp;quot; type=&amp;quot;workflow&amp;quot; states=&amp;quot;draft&amp;quot; string=&amp;quot;发送&amp;quot; class=&amp;quot;oe_highlight&amp;quot;/&amp;gt;
                &amp;lt;button name=&amp;quot;btn_accept&amp;quot; type=&amp;quot;workflow&amp;quot; states=&amp;quot;confirmed&amp;quot; string=&amp;quot;批准&amp;quot; class=&amp;quot;oe_highlight&amp;quot;/&amp;gt;
                &amp;lt;button name=&amp;quot;btn_reject&amp;quot; type=&amp;quot;workflow&amp;quot; states=&amp;quot;confirmed&amp;quot; string=&amp;quot;拒绝&amp;quot; class=&amp;quot;oe_highlight&amp;quot;/&amp;gt;
                &amp;lt;field name=&amp;quot;state&amp;quot; widget=&amp;quot;statusbar&amp;quot; statusbar_visible=&amp;quot;draft,confirmed,accepted,rejected&amp;quot; class=&amp;quot;oe_highlight&amp;quot; type=&amp;quot;workflow&amp;quot;/&amp;gt;
            &amp;lt;/header&amp;gt;
                &amp;lt;sheet&amp;gt;
                    &amp;lt;group name=&amp;quot;group_top&amp;quot; string=&amp;quot;请假单&amp;quot;&amp;gt;
                        &amp;lt;group name=&amp;quot;group_left&amp;quot;&amp;gt;
                            &amp;lt;field name=&amp;quot;name&amp;quot;/&amp;gt;
                            &amp;lt;field name=&amp;quot;beginning&amp;quot;/&amp;gt;
                        &amp;lt;/group&amp;gt;
                        &amp;lt;group name=&amp;quot;group_right&amp;quot;&amp;gt;
                            &amp;lt;field name=&amp;quot;manager&amp;quot;/&amp;gt;
                            &amp;lt;field name=&amp;quot;ending&amp;quot;/&amp;gt;
                        &amp;lt;/group&amp;gt;
                    &amp;lt;/group&amp;gt;
                    &amp;lt;group name=&amp;quot;group_below&amp;quot;&amp;gt;
                        &amp;lt;field name=&amp;quot;reason&amp;quot;/&amp;gt;
                    &amp;lt;/group&amp;gt;
                &amp;lt;/sheet&amp;gt;
            &amp;lt;/form&amp;gt;
        &amp;lt;/field&amp;gt;
    &amp;lt;/record&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;增加工作流&#34;&gt;增加工作流&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;odoo&amp;gt;
    &amp;lt;data noupdate=&amp;quot;0&amp;quot;&amp;gt;
        &amp;lt;record id=&amp;quot;wkf_qingjia&amp;quot; model=&amp;quot;workflow&amp;quot;&amp;gt;
            &amp;lt;field name=&amp;quot;name&amp;quot;&amp;gt;wkf.qingjia&amp;lt;/field&amp;gt;
            &amp;lt;field name=&amp;quot;osv&amp;quot;&amp;gt;qingjia.qingjd&amp;lt;/field&amp;gt;
            &amp;lt;field name=&amp;quot;on_create&amp;quot;&amp;gt;True&amp;lt;/field&amp;gt;
        &amp;lt;/record&amp;gt;
        &amp;lt;record id=&amp;quot;act_draft&amp;quot; model=&amp;quot;workflow.activity&amp;quot;&amp;gt;
            &amp;lt;field name=&amp;quot;wkf_id&amp;quot; ref=&amp;quot;wkf_qingjia&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;name&amp;quot;&amp;gt;draft&amp;lt;/field&amp;gt;
            &amp;lt;field name=&amp;quot;flow_start&amp;quot; eval=&amp;quot;True&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;kind&amp;quot;&amp;gt;function&amp;lt;/field&amp;gt;
            &amp;lt;field name=&amp;quot;action&amp;quot;&amp;gt;draft()&amp;lt;/field&amp;gt;
        &amp;lt;/record&amp;gt;
        &amp;lt;record id=&amp;quot;act_confirm&amp;quot; model=&amp;quot;workflow.activity&amp;quot;&amp;gt;
            &amp;lt;field name=&amp;quot;wkf_id&amp;quot; ref=&amp;quot;wkf_qingjia&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;name&amp;quot;&amp;gt;confirm&amp;lt;/field&amp;gt;
            &amp;lt;field name=&amp;quot;kind&amp;quot;&amp;gt;function&amp;lt;/field&amp;gt;
            &amp;lt;field name=&amp;quot;action&amp;quot;&amp;gt;confirm()&amp;lt;/field&amp;gt;
        &amp;lt;/record&amp;gt;
        &amp;lt;record id=&amp;quot;act_accept&amp;quot; model=&amp;quot;workflow.activity&amp;quot;&amp;gt;
            &amp;lt;field name=&amp;quot;wkf_id&amp;quot; ref=&amp;quot;wkf_qingjia&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;name&amp;quot;&amp;gt;accept&amp;lt;/field&amp;gt;
            &amp;lt;field name=&amp;quot;kind&amp;quot;&amp;gt;function&amp;lt;/field&amp;gt;
            &amp;lt;field name=&amp;quot;action&amp;quot;&amp;gt;accept()&amp;lt;/field&amp;gt;
        &amp;lt;/record&amp;gt;
        &amp;lt;record id=&amp;quot;act_reject&amp;quot; model=&amp;quot;workflow.activity&amp;quot;&amp;gt;
            &amp;lt;field name=&amp;quot;wkf_id&amp;quot; ref=&amp;quot;wkf_qingjia&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;name&amp;quot;&amp;gt;reject&amp;lt;/field&amp;gt;
            &amp;lt;field name=&amp;quot;kind&amp;quot;&amp;gt;function&amp;lt;/field&amp;gt;
            &amp;lt;field name=&amp;quot;action&amp;quot;&amp;gt;reject()&amp;lt;/field&amp;gt;
        &amp;lt;/record&amp;gt;
        &amp;lt;record id=&amp;quot;qingjia_draft2confirm&amp;quot; model=&amp;quot;workflow.transition&amp;quot;&amp;gt;
            &amp;lt;field name=&amp;quot;act_from&amp;quot; ref=&amp;quot;act_draft&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;act_to&amp;quot; ref=&amp;quot;act_confirm&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;signal&amp;quot;&amp;gt;btn_confirm&amp;lt;/field&amp;gt;
        &amp;lt;/record&amp;gt;
        &amp;lt;record id=&amp;quot;qingjia_confirm2accept&amp;quot; model=&amp;quot;workflow.transition&amp;quot;&amp;gt;
            &amp;lt;field name=&amp;quot;act_from&amp;quot; ref=&amp;quot;act_confirm&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;act_to&amp;quot; ref=&amp;quot;act_accept&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;signal&amp;quot;&amp;gt;btn_accept&amp;lt;/field&amp;gt;
            &amp;lt;field name=&amp;quot;condition&amp;quot;&amp;gt;is_manager&amp;lt;/field&amp;gt;
        &amp;lt;/record&amp;gt;
        &amp;lt;record id=&amp;quot;qingjia_confirm2reject&amp;quot; model=&amp;quot;workflow.transition&amp;quot;&amp;gt;
            &amp;lt;field name=&amp;quot;act_from&amp;quot; ref=&amp;quot;act_confirm&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;act_to&amp;quot; ref=&amp;quot;act_reject&amp;quot;/&amp;gt;
            &amp;lt;field name=&amp;quot;signal&amp;quot;&amp;gt;btn_reject&amp;lt;/field&amp;gt;
            &amp;lt;field name=&amp;quot;condition&amp;quot;&amp;gt;is_manager&amp;lt;/field&amp;gt;
        &amp;lt;/record&amp;gt;
    &amp;lt;/data&amp;gt;
&amp;lt;/odoo&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整的项目：&lt;a href=&#34;https://github.com/asdfsx/qingjia&#34;&gt;https://github.com/asdfsx/qingjia&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python的导入系统</title>
      <link>https://asdfsx.github.io/post/python/python%E7%9A%84%E5%AF%BC%E5%85%A5%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 11 Jan 2017 12:01:19 +0800</pubDate>
      
      <guid>https://asdfsx.github.io/post/python/python%E7%9A%84%E5%AF%BC%E5%85%A5%E7%B3%BB%E7%BB%9F/</guid>
      <description>

&lt;p&gt;一个模块中的Python代码通过导入的过程获得对另一个模块中的代码的访问。&lt;code&gt;import&lt;/code&gt;语句是调用导入机制的最常用方法，但它不是唯一的方法。诸如&lt;code&gt;importlib.import_module()&lt;/code&gt;和内置&lt;code&gt;__import__()&lt;/code&gt;之类的函数也可以用于调用导入机制。&lt;/p&gt;

&lt;p&gt;import语句组合两个操作；它搜索指定的模块，然后将该搜索的结果绑定到本地作用域中的名称。import语句的搜索操作被定义为使用适当的参数调用&lt;code&gt;__import__()&lt;/code&gt;函数。&lt;code&gt;__import__()&lt;/code&gt;的返回值用于执行import语句的名称绑定操作。有关该名称绑定操作的确切详细信息，请参见import语句。&lt;/p&gt;

&lt;p&gt;直接调用&lt;code&gt;__import__()&lt;/code&gt;只执行模块搜索，如果找到，则执行模块创建操作。虽然可能会发生某些副作用，例如导入父包以及更新各种缓存（包括&lt;code&gt;sys.modules&lt;/code&gt;），但只有import语句会执行名称绑定操作。&lt;/p&gt;

&lt;p&gt;当调用&lt;code&gt;__import__()&lt;/code&gt;作为import语句的一部分时，将调用标准的内置&lt;code&gt;__import__()&lt;/code&gt;。用于调用导入系统的其他机制（例如&lt;code&gt;importlib.import_module()&lt;/code&gt;）可以选择颠覆&lt;code&gt;__import__()&lt;/code&gt;并使用其自己的解决方案来实现导入语义。&lt;/p&gt;

&lt;p&gt;首次导入模块时，Python会搜索模块，如果找到，它会创建一个模块对象[1]，并初始化它。如果找不到指定的模块，则会引发ImportError。当执行导入机制时，Python实现各种策略来搜索命名的模块。这些策略可以通过使用下面部分中描述的各种钩子来修改和扩展。&lt;/p&gt;

&lt;p&gt;在版本3.3中更改：导入系统更新成完全实现 PEP 302的第二阶段。不再有任何隐式导入机制 - 完整导入系统通过sys.meta_path暴露。此外，已实现原生命名空间包支持（参见 PEP 420）。&lt;/p&gt;

&lt;h3 id=&#34;1-importlib&#34;&gt;1. importlib&lt;/h3&gt;

&lt;p&gt;importlib模块提供了一个丰富的API，用于与导入系统进行交互。例如&lt;code&gt;importlib.import_module()&lt;/code&gt;提供了一个比内置的&lt;code&gt;__import__()&lt;/code&gt;更简单的API来调用导入机制。有关其他详细信息，请参阅importlib库文档。&lt;/p&gt;

&lt;h3 id=&#34;2-包-packages&#34;&gt;2. 包&lt;code&gt;Packages&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Python只有一种模块对象，所有的模块都是这种类型，不管这个模块是否是用Python，C，或者其他语言实现。为了帮助组织模块并提供命名层次结构，Python有一个概念：包。&lt;/p&gt;

&lt;p&gt;你可以认为包是文件系统中的一个目录并且模块作为文件存放于目录中，但是不要做这种太字面化的类比因为包和模块不需要源于文件系统。从这篇文档的目的是我们用目录和文件这个方便的类比来解释包和模块。和文件系统一样，包有有层次的组织着，并且包本身也会包含子包，规则的模块也一样。&lt;/p&gt;

&lt;p&gt;重要的是请注意所有的包都是模块，但不是所有的模块都是包。换句话说，包只是一种特殊形式的模块。具体来说，包含&lt;code&gt;__path__&lt;/code&gt;属性的任何模块都被视为包。&lt;/p&gt;

&lt;p&gt;所有的模块都有名字。子模块的名字是通过点号从父模块中分离出来的，和Python标准的属性访问语法相似。因此，您可能有一个名为sys的模块和一个名为email的软件包，其中包含一个名为&lt;code&gt;email.mime&lt;/code&gt;的子包，名为&lt;code&gt;email.mime.text&lt;/code&gt;的子包。&lt;/p&gt;

&lt;h5 id=&#34;2-1-普通包&#34;&gt;2.1 普通包&lt;/h5&gt;

&lt;p&gt;Python defines two types of packages, regular packages and namespace packages. Regular packages are traditional packages as they existed in Python 3.2 and earlier. A regular package is typically implemented as a directory containing an &lt;strong&gt;init&lt;/strong&gt;.py file. When a regular package is imported, this &lt;strong&gt;init&lt;/strong&gt;.py file is  executed, and the objects it defines are bound to names in the package’s namespace. The &lt;strong&gt;init&lt;/strong&gt;.py file can contain the same Python code that any other module can contain, and Python will add some additional attributes to the module when it is imported.&lt;/p&gt;

&lt;p&gt;Python定义了两种包，普通包和名字空间包。普通包就是传统的包，它们在Python3.2和更早的版本中就存在。一个普通包就是一个含有一个&lt;code&gt;__init__py&lt;/code&gt;文件的目录。当一个包被导入时，这个&lt;code&gt;__init__.py&lt;/code&gt;文件会在暗中执行，它定义的对象会绑定到包的名字空间中的名字上。&lt;code&gt;__init__.py&lt;/code&gt;文件中可以包含其它模块可以包含的Python代码，而且Python导入这个模块时可以添加些额外的属性到模块中。&lt;/p&gt;

&lt;p&gt;比如：下面的文件系统层次定义了一个个包含3个子包的父包。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;parent/
    __init__.py
    one/
        __init__.py
    two/
        __init__.py
    three/
        __init__.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导入&lt;code&gt;parent.one&lt;/code&gt;会暗中执行&lt;code&gt;parent/__init__.py&lt;/code&gt;和&lt;code&gt;parent/one/__init__.py&lt;/code&gt;。之后再导入&lt;code&gt;parent.two&lt;/code&gt;或者&lt;code&gt;parent.three&lt;/code&gt;会执行&lt;code&gt;parent/two/__init__.py&lt;/code&gt;或者&lt;code&gt;parent/three/__init__.py&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;2-2-名字空间包&#34;&gt;2.2 名字空间包&lt;/h5&gt;

&lt;h3 id=&#34;3-搜索&#34;&gt;3. 搜索&lt;/h3&gt;

&lt;h5 id=&#34;3-1-模块缓存-the-module-cache&#34;&gt;3.1 模块缓存&lt;code&gt;The module cache&lt;/code&gt;&lt;/h5&gt;

&lt;h5 id=&#34;3-2-查询器与装载器-finders-and-loaders&#34;&gt;3.2 查询器与装载器&lt;code&gt;Finders and loaders&lt;/code&gt;&lt;/h5&gt;

&lt;h5 id=&#34;3-3-导入钩子-import-hooks&#34;&gt;3.3 导入钩子&lt;code&gt;Import hooks&lt;/code&gt;&lt;/h5&gt;

&lt;h5 id=&#34;3-4-元路径-meta-path&#34;&gt;3.4 元路径&lt;code&gt;meta path&lt;/code&gt;&lt;/h5&gt;

&lt;h3 id=&#34;4-装载&#34;&gt;4. 装载&lt;/h3&gt;

&lt;p&gt;当找到模块描述后，导入系统将使用它导入模块。这里模拟一下导入过程中发生了什么：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module = None
if spec.loader is not None and hasattr(spec.loader, &#39;create_module&#39;):
    # It is assumed &#39;exec_module&#39; will also be defined on the loader.
    module = spec.loader.create_module(spec)
if module is None:
    module = ModuleType(spec.name)
# The import-related module attributes get set here:
_init_module_attrs(spec, module)

if spec.loader is None:
    if spec.submodule_search_locations is not None:
        # namespace package
        sys.modules[spec.name] = module
    else:
        # unsupported
        raise ImportError
elif not hasattr(spec.loader, &#39;exec_module&#39;):
    module = spec.loader.load_module(spec.name)
    # Set __loader__ and __package__ if missing.
else:
    sys.modules[spec.name] = module
    try:
        spec.loader.exec_module(module)
    except BaseException:
        try:
            del sys.modules[spec.name]
        except KeyError:
            pass
        raise
return sys.modules[spec.name]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意以下内容：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果在&lt;code&gt;sys.modules&lt;/code&gt;中已经存在给定名称的模块对象，导入系统将会返回这个对象。&lt;/li&gt;
&lt;li&gt;在装载器执行模块代码之前，模块将保存在&lt;code&gt;sys.modules&lt;/code&gt;中。这点非常重要，因为模块可能会导入自己（直接或间接）；把它预先添加到&lt;code&gt;sys.modules&lt;/code&gt;会避免循环绑定和反复装载。&lt;/li&gt;
&lt;li&gt;如果装载失败，失败的模块 - 而且只有失败的模块 - 会从&lt;code&gt;sys.modules&lt;/code&gt;中移除。而&lt;code&gt;sys.modules&lt;/code&gt;中已有的模块，和导入过程中成功导入的那些模块仍然会保留在&lt;code&gt;sys.modules&lt;/code&gt;中。与之不同的是重新装载&lt;code&gt;reloading&lt;/code&gt;，即使失败也会保留在&lt;code&gt;sys.modules&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;当模块创建后但是还没有执行，导入机构会设置依赖导入&lt;code&gt;import-related&lt;/code&gt;的模块属性（&lt;code&gt;__init_module_attrs&lt;/code&gt;上边的伪代码例子中），在之后的部分会详细介绍。&lt;/li&gt;
&lt;li&gt;执行模块时装在过程中很重要的一步，在这一步中会创建模块的名字空间。执行由装载器全权负责，它会决定生成什么和如何生成。&lt;/li&gt;
&lt;li&gt;在装载过程中创建的模块有可能不是最终返回的模块，如果它被传递给&lt;code&gt;exec_module()&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.4版发生的变化：导入系统接管loader的引用功能，之前是由&lt;code&gt;importlib.abc.Loader.load_module()&lt;/code&gt;来执行。&lt;/p&gt;

&lt;h5 id=&#34;4-1-装载器&#34;&gt;4.1 装载器&lt;/h5&gt;

&lt;h5 id=&#34;4-2-子模块&#34;&gt;4.2 子模块&lt;/h5&gt;

&lt;h5 id=&#34;4-3-模块描述&#34;&gt;4.3 模块描述&lt;/h5&gt;

&lt;h5 id=&#34;4-4-导入时的模块属性&#34;&gt;4.4 导入时的模块属性&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;__name__&lt;/li&gt;
&lt;li&gt;__loader__&lt;/li&gt;
&lt;li&gt;__package__&lt;/li&gt;
&lt;li&gt;__spec__&lt;/li&gt;
&lt;li&gt;__path__&lt;/li&gt;
&lt;li&gt;__file__&lt;/li&gt;
&lt;li&gt;__cached__&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;4-5-module-path&#34;&gt;4.5 module.__path__&lt;/h5&gt;

&lt;h5 id=&#34;4-6-module-reprs&#34;&gt;4.6 Module reprs&lt;/h5&gt;

&lt;h3 id=&#34;5-基于路径的查找器&#34;&gt;5. 基于路径的查找器&lt;/h3&gt;

&lt;h5 id=&#34;5-1-path-entry-finders&#34;&gt;5.1 Path entry finders&lt;/h5&gt;

&lt;h5 id=&#34;5-2-path-entry-finder-protocol&#34;&gt;5.2 Path entry finder protocol&lt;/h5&gt;

&lt;h3 id=&#34;6-替换标准的导入系统&#34;&gt;6. 替换标准的导入系统&lt;/h3&gt;

&lt;p&gt;最可靠的替换整个导入系统的方法是删除&lt;code&gt;sys.meta_path&lt;/code&gt;的默认内容，用自定义的&lt;code&gt;meta path hook&lt;/code&gt;来彻底替换。&lt;/p&gt;

&lt;p&gt;替换内置&lt;code&gt;__import__()&lt;/code&gt;函数就只能对导入系统的行为造成影响，而不能影响使用导入系统的其它API。这个技术可以在包内部使用，以修改包内部的导入行为。&lt;/p&gt;

&lt;p&gt;为了有选择的避免通过&lt;code&gt;hook&lt;/code&gt;导入包早于扫描&lt;code&gt;meta path&lt;/code&gt;（甚至早于关闭整个标准导入系统），可以通过从&lt;code&gt;find_spec&lt;/code&gt;直接抛出&lt;code&gt;ModuleNoFoundError&lt;/code&gt;异常而不是返回一个&lt;code&gt;None&lt;/code&gt;。后者会让后续的&lt;code&gt;meta path&lt;/code&gt;搜索继续执行，而抛出异常会立即中断搜索。&lt;/p&gt;

&lt;h3 id=&#34;7-main-的特殊考虑&#34;&gt;7. &lt;code&gt;__main__&lt;/code&gt;的特殊考虑&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;__main__&lt;/code&gt;模块是Python导入系统产生的特殊模块。就像别处提到的，&lt;code&gt;__main__&lt;/code&gt;模块是在解释器启动时被直接创建的，就像&lt;code&gt;sys&lt;/code&gt;和&lt;code&gt;builtings&lt;/code&gt;。但是与它们不同，&lt;code&gt;__main__&lt;/code&gt;不是严格意义上的内建模块。因为&lt;code&gt;__main__&lt;/code&gt;的创建方式由标志位、参数、以及解释器的实现来决定。&lt;/p&gt;

&lt;h5 id=&#34;7-1-main-spec&#34;&gt;7.1 &lt;code&gt;__main__.__spec__&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;根据&lt;code&gt;__main__&lt;/code&gt;的创建方式，&lt;code&gt;__main__.__spec__&lt;/code&gt;会被设置为合适的值或者&lt;code&gt;None&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当Python启动时使用&lt;code&gt;-m&lt;/code&gt;参数，&lt;code&gt;__spec__&lt;/code&gt;的值就是对应模块或者包的模块名。当执行一个目录、&lt;code&gt;zip&lt;/code&gt;文件或其他&lt;code&gt;sys.path&lt;/code&gt;时，&lt;code&gt;__main__&lt;/code&gt;模块也会被装载，这时&lt;code&gt;__spec__&lt;/code&gt;也
会产生。&lt;/p&gt;

&lt;p&gt;在以下情况下&lt;code&gt;__main__.__spec__&lt;/code&gt;被设置为&lt;code&gt;None&lt;/code&gt;，当产生&lt;code&gt;__main__&lt;/code&gt;的代码不在一个可导入模块下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;解释器命令行&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;-c&lt;/code&gt;转换&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;stdin&lt;/code&gt;读入后执行&lt;/li&gt;
&lt;li&gt;直接执行源码或者字节码文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意最后一种情况里&lt;code&gt;__main__.__spec__&lt;/code&gt;通常时&lt;code&gt;None&lt;/code&gt;，即便这个文件可以当作模块字节导入。如果&lt;code&gt;__main__&lt;/code&gt;需要模块的元数据，执行时可以使用&lt;code&gt;-m&lt;/code&gt;参数。&lt;/p&gt;

&lt;p&gt;注意即便&lt;code&gt;__main__&lt;/code&gt;对应一个可导入模块，而且&lt;code&gt;__main__.__spec__&lt;/code&gt;也照样设置了，它们仍然被看作不同的模块。这是因为代码块被&lt;code&gt;if __name__ == &amp;quot;__main__&amp;quot;&lt;/code&gt;保护着：只有当模块是用于创建&lt;code&gt;__main__&lt;/code&gt;名字空间，而不是是普通的导入才会被执行。&lt;/p&gt;

&lt;h3 id=&#34;8-open-issues&#34;&gt;8. Open issues&lt;/h3&gt;

&lt;h3 id=&#34;9-references&#34;&gt;9. References&lt;/h3&gt;

&lt;p&gt;导入机制从Python诞生至今不断的进化。原始的包说明书现在仍然可以使用，尽管很多细节已经发生了变化。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;翻的真烂！给自己刨的坑略多、略大！愚公移山慢慢弄吧！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>odoo中页面的生成</title>
      <link>https://asdfsx.github.io/post/odoo/odoo%E4%B8%AD%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E6%88%90/</link>
      <pubDate>Mon, 09 Jan 2017 17:40:52 +0800</pubDate>
      
      <guid>https://asdfsx.github.io/post/odoo/odoo%E4%B8%AD%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E6%88%90/</guid>
      <description>

&lt;p&gt;在请求的处理中，已经知道在请求处理的最后，会调用&lt;code&gt;Response&lt;/code&gt;的&lt;code&gt;render&lt;/code&gt;来生成页面。这里来研究下页面是如何形成的。&lt;/p&gt;

&lt;p&gt;以入口地址的处理为例：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;处理&lt;code&gt;/&lt;/code&gt;请求的&lt;code&gt;controller&lt;/code&gt;为&lt;code&gt;addon.web.controllers.main.Home&lt;/code&gt;，定义在&lt;code&gt;web&lt;/code&gt;模块中，处理方式是直接跳转到&lt;code&gt;/web&lt;/code&gt;。&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;处理&lt;code&gt;/web&lt;/code&gt;请求的&lt;code&gt;controller&lt;/code&gt;同上，使用&lt;code&gt;web.webclient_bootstrap&lt;/code&gt;这个模版来生成页面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Home(http.Controller):
    @http.route(&#39;/&#39;, type=&#39;http&#39;, auth=&amp;quot;none&amp;quot;)
    def index(self, s_action=None, db=None, **kw):
        return http.local_redirect(&#39;/web&#39;, query=request.params, keep_hash=True)
        
    @http.route(&#39;/web&#39;, type=&#39;http&#39;, auth=&amp;quot;none&amp;quot;)
    def web_client(self, s_action=None, **kw):
        ensure_db()
        if not request.session.uid:
            return werkzeug.utils.redirect(&#39;/web/login&#39;, 303)
        if kw.get(&#39;redirect&#39;):
            return werkzeug.utils.redirect(kw.get(&#39;redirect&#39;), 303)

        request.uid = request.session.uid
        context = request.env[&#39;ir.http&#39;].webclient_rendering_context()

        return request.render(&#39;web.webclient_bootstrap&#39;, qcontext=context)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在介绍页面生成之前，先熟悉下可能会用到的模型&lt;/p&gt;

&lt;h3 id=&#34;模型-odoo-addons-base-ir-ir-ui-view-view&#34;&gt;模型 &lt;code&gt;odoo.addons.base.ir.ir_ui_view.View&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;在&lt;code&gt;response.render&lt;/code&gt;函数中，需要用到&lt;code&gt;ir.ui.view&lt;/code&gt;模型来生成页面。下边就是这个模型的定义。从中我们可以知道在数据库中一定会有一张表&lt;code&gt;ir_ui_view&lt;/code&gt;，同时这个模型会在&lt;code&gt;ir_model&lt;/code&gt;注册，模型的字段会在&lt;code&gt;ir_model_fields&lt;/code&gt;中记录。其中一个特殊的字段是&lt;code&gt;type&lt;/code&gt;，从定义猜测&lt;code&gt;View&lt;/code&gt;的种类就是列表中的那几种。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;View&lt;/code&gt;模型还提供了如下功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;根据模版生成页面 &lt;code&gt;render_template&lt;/code&gt;（仅仅算是入口函数）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查询模版ID &lt;code&gt;get_view_id&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select ir_model_data.id from ir_model_data where module=&#39;web&#39; and name=&#39;webclient_bootstrap&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模版读取 &lt;code&gt;read_template&lt;/code&gt;、&lt;code&gt;read_template&lt;/code&gt;、&lt;code&gt;read_combined&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用模版引擎&lt;code&gt;render&lt;/code&gt;生成页面，&lt;code&gt;render&lt;/code&gt;。默认使用&lt;code&gt;ir_qweb&lt;/code&gt;。参数中的&lt;code&gt;self.id&lt;/code&gt;，通过之前对模型的研究，它就是刚才的&lt;code&gt;res_id&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class View(models.Model):
    _name = &#39;ir.ui.view&#39;
    _order = &amp;quot;priority,name,id&amp;quot;
    ...
    type = fields.Selection([(&#39;tree&#39;, &#39;Tree&#39;),
                             (&#39;form&#39;, &#39;Form&#39;),
                             (&#39;graph&#39;, &#39;Graph&#39;),
                             (&#39;pivot&#39;, &#39;Pivot&#39;),
                             (&#39;calendar&#39;, &#39;Calendar&#39;),
                             (&#39;diagram&#39;, &#39;Diagram&#39;),
                             (&#39;gantt&#39;, &#39;Gantt&#39;),
                             (&#39;kanban&#39;, &#39;Kanban&#39;),
                             (&#39;search&#39;, &#39;Search&#39;),
                             (&#39;qweb&#39;, &#39;QWeb&#39;)], string=&#39;View Type&#39;)
    arch = fields.Text(compute=&#39;_compute_arch&#39;, inverse=&#39;_inverse_arch&#39;, string=&#39;View Architecture&#39;, nodrop=True)
    ...
    
    @api.model
    def get_view_id(self, template):
        ...
        return self.env[&#39;ir.model.data&#39;].xmlid_to_res_id(template, raise_if_not_found=True)
    
    @api.model
    def render_template(self, template, values=None, engine=&#39;ir.qweb&#39;):
        return self.browse(self.get_view_id(template)).render(values, engine)
        
   def _read_template(self, view_id):
        arch = self.browse(view_id).read_combined([&#39;arch&#39;])[&#39;arch&#39;]
        arch_tree = etree.fromstring(arch)
        self.distribute_branding(arch_tree)
        root = E.templates(arch_tree)
        arch = etree.tostring(root, encoding=&#39;utf-8&#39;, xml_declaration=True)
        return arch

    @api.model
    def read_template(self, xml_id):
        return self._read_template(self.get_view_id(xml_id))
        
    @api.multi
    def read_combined(self, fields=None):
         &amp;quot;&amp;quot;&amp;quot;
        Utility function to get a view combined with its inherited views.
        * Gets the top of the view tree if a sub-view is requested
        * Applies all inherited archs on the root view
        * Returns the view with all requested fields
          .. note:: ``arch`` is always added to the fields list even if not
                    requested (similar to ``id``)
        &amp;quot;&amp;quot;&amp;quot;
        ...
    ...
    @api.multi
    def render(self, values=None, engine=&#39;ir.qweb&#39;):
        assert isinstance(self.id, (int, long))

        qcontext = dict(
            env=self.env,
            keep_query=keep_query,
            request=request, # might be unbound if we&#39;re not in an httprequest context
            debug=request.debug if request else False,
            json=json,
            quote_plus=werkzeug.url_quote_plus,
            time=time,
            datetime=datetime,
            relativedelta=relativedelta,
            xmlid=self.key,
        )
        qcontext.update(values or {})

        return self.env[engine].render(self.id, qcontext)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当模型表创建好后，就需要往里添加数据。之前研究&lt;code&gt;Registry&lt;/code&gt;的时候，已经知道在加载模块的时候，模型的数据文件会写入到自己的数据表，以及&lt;code&gt;ir_model_data&lt;/code&gt;表。以&lt;code&gt;web&lt;/code&gt;模块来说，它的数据文件&lt;code&gt;webclient_templates.xml&lt;/code&gt;中有很多模版，都会保存到数据库中。&lt;/p&gt;

&lt;h3 id=&#34;模型-odoo-addons-base-ir-ir-qweb-ir-qweb-irqweb&#34;&gt;模型 &lt;code&gt;odoo.addons.base.ir.ir_qweb.ir_qweb.IrQWeb&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;这也是一个只提供功能而不提供数据存储的模型，主要负责模版的读取、页面的生成。它的父类&lt;code&gt;QWeb&lt;/code&gt;提供了绝大部分的模版处理函数，在子类中只需要根据需要覆盖个别函数就可以了。感觉子类存在更重要的意义在于将模版引擎也当作模型加载到&lt;code&gt;registry&lt;/code&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class IrQWeb(models.AbstractModel, QWeb):
    _name = &#39;ir.qweb&#39;

    @api.model
    def render(self, id_or_xml_id, values=None, **options):
        ...
        return super(IrQWeb, self).render(id_or_xml_id, values=values, **context)
    ...    
    
    def compile(self, id_or_xml_id, options):
        return super(IrQWeb, self).compile(id_or_xml_id, options=options)

    def load(self, name, options):
        ...   
        template = env[&#39;ir.ui.view&#39;].read_template(name)
        ... 
    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;模版引擎-qweb&#34;&gt;模版引擎 &lt;code&gt;QWeb&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;模型&lt;code&gt;ir.qweb&lt;/code&gt;的父类，定义了模版处理的大部分行为。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class QWeb(object):
    def render(self, template, values=None, **options):
        body = []
        self.compile(template, options)(self, body.append, values or {})
        return u&#39;&#39;.join(body).encode(&#39;utf8&#39;)
    
    def compile(self, template, options):
        ...
        element, document = self.get_template(template, options)
        ...
        def _compiled_fn(self, append, values):
            log = {&#39;last_path_node&#39;: None}
            values = dict(self.default_values(), **values)
            try:
                return compiled(self, append, values, options, log)
            except QWebException, e:
                raise e
            except Exception, e:
                path = log[&#39;last_path_node&#39;]
                element, document = self.get_template(template, options)
                node = element.getroottree().xpath(path)
                raise QWebException(&amp;quot;Error to render compiling AST&amp;quot;, e, path, node and etree.tostring(node[0]), name)

        return _compiled_fn
        
    ...
    
    def get_template(self, template, options):
        ...
        document = options.get(&#39;load&#39;, self.load)(template, options)
        ...
        if document is not None:
            if isinstance(document, etree._Element):
                element = document
                document = etree.tostring(document)
            elif document.startswith(&amp;quot;&amp;lt;?xml&amp;quot;):
                element = etree.fromstring(document)
            else:
                element = etree.parse(document).getroot()
            for node in element:
                if node.get(&#39;t-name&#39;) == str(template):
                    return (node, document)

        raise QWebException(&amp;quot;Template not found&amp;quot;, name=template)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;模版的获取&#34;&gt;模版的获取&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;response.render&lt;/code&gt;会用&lt;code&gt;ir.ui.view&lt;/code&gt;模型来根据模版来创建页面。具体到&lt;code&gt;/web&lt;/code&gt;请求的处理，就是使用&lt;code&gt;ir.ui.view&lt;/code&gt;模型的&lt;code&gt;render_template&lt;/code&gt;函数，利用&lt;code&gt;web.webclient_bootstrap&lt;/code&gt;模版来创建页面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Response(werkzeug.wrappers.Response):

    ...

    def render(self):
        ...
        return env[&amp;quot;ir.ui.view&amp;quot;].render_template(self.template, self.qcontext)
    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;回到模型&lt;code&gt;ir.ui.view&lt;/code&gt;，&lt;code&gt;render_template&lt;/code&gt;函数首先使用模型的名字获得模版在&lt;code&gt;ir.model.data&lt;/code&gt;中保存的&lt;code&gt;res_id&lt;/code&gt;，也就是模版在&lt;code&gt;ir_ui_view&lt;/code&gt;中的主键。对应的sql：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select ir_model_data.id from ir_model_data 
where ir_model_data.module=&#39;web&#39; and 
      ir_model_data.name=&#39;webclient_bootstrap&#39; 
order by ir_model_data.module, ir_model_data.name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用&lt;code&gt;browse&lt;/code&gt;创建一个&lt;code&gt;ir_ui_view&lt;/code&gt;对象。然后调用&lt;code&gt;ir.ui.view&lt;/code&gt;模型的&lt;code&gt;render&lt;/code&gt;函数生成页面。这个函数默认使用&lt;code&gt;ir.qweb&lt;/code&gt;引擎的&lt;code&gt;render&lt;/code&gt;函数来生成页面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@api.multi
def render(self, values=None, engine=&#39;ir.qweb&#39;):
    ...
    return self.env[engine].render(self.id, qcontext)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;模版编译&#34;&gt;模版编译&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;模版引擎&lt;code&gt;ir.qweb&lt;/code&gt;&lt;br /&gt;
当&lt;code&gt;ir.ui.view&lt;/code&gt;中获得模版id以后，使用父类&lt;code&gt;qweb.render&lt;/code&gt;生成页面。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先编译模版&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;读取模版 &lt;code&gt;get_template&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从&lt;code&gt;options&lt;/code&gt;中检查是否有&lt;code&gt;load&lt;/code&gt;函数，如果没有用自己的&lt;code&gt;load&lt;/code&gt;函数。注意：因为真正在使用的其实是&lt;code&gt;ir.qweb&lt;/code&gt;模型，所以这里的&lt;code&gt;load&lt;/code&gt;函数，其实是被子类&lt;code&gt;ir.qweb&lt;/code&gt;覆盖过的&lt;code&gt;load&lt;/code&gt;函数。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在子类&lt;code&gt;ir.qweb&lt;/code&gt;中，&lt;code&gt;load&lt;/code&gt;函数会调用&lt;code&gt;ir.ui.view&lt;/code&gt;模型的&lt;code&gt;_read_template&lt;/code&gt;来获取模版。先根据&lt;code&gt;view_id&lt;/code&gt;获取当前&lt;code&gt;view&lt;/code&gt;的对象，然后调用&lt;code&gt;read_combined&lt;/code&gt;读取该对象的&lt;code&gt;arch&lt;/code&gt;字段。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在&lt;code&gt;read_combined&lt;/code&gt;中，有一句&lt;code&gt;arch = self.browse(view_id).read_combined([&#39;arch&#39;])[&#39;arch&#39;]&lt;/code&gt;，它调用&lt;code&gt;read_combined&lt;/code&gt;来读取模型的&lt;code&gt;arch&lt;/code&gt;字段。&lt;br /&gt;
&lt;code&gt;arch&lt;/code&gt;是个很神奇的字段。它的定义是&lt;code&gt;arch = fields.Text(compute=&#39;_compute_arch&#39;, inverse=&#39;_inverse_arch&#39;, string=&#39;View Architecture&#39;, nodrop=True)&lt;/code&gt;，其中&lt;code&gt;compute&lt;/code&gt;说明这个字段是经过计算才能获得值，而这个&lt;code&gt;compute&lt;/code&gt;的值就是用来计算的函数&amp;ndash;从文件中读取内容，然后放入&lt;code&gt;arch&lt;/code&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@api.depends(&#39;arch_db&#39;, &#39;arch_fs&#39;)
def _compute_arch(self):
    ...
    for view in self:
        arch_fs = None
        if &#39;xml&#39; in config[&#39;dev_mode&#39;] and view.arch_fs and view.xml_id:
            fullpath = get_resource_path(*view.arch_fs.split(&#39;/&#39;))
            arch_fs = get_view_arch_from_file(fullpath, view.xml_id)
            arch_fs = arch_fs and resolve_external_ids(arch_fs, view.xml_id)
        view.arch = arch_fs or view.arch_db
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模版读到以后，使用&lt;code&gt;ast&lt;/code&gt;生成一个&lt;code&gt;python&lt;/code&gt;的语法树，将模版等信息加入其中，最终生成一个&lt;code&gt;python&lt;/code&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; element, document = self.get_template(template, options)
             
 ...
             
 astmod = self._base_module()
             
 ...
             
 body = self._compile_node(element, _options)
 ast_calls = _options[&#39;ast_calls&#39;]
 _options[&#39;ast_calls&#39;] = []
 def_name = self._create_def(_options, body, prefix=&#39;template_%s&#39; % name.replace(&#39;.&#39;, &#39;_&#39;))
 _options[&#39;ast_calls&#39;] += ast_calls
             
 ...
             
 astmod.body.extend(_options[&#39;ast_calls&#39;])
             
 ...
             
 ns = {}
 unsafe_eval(compile(astmod, &#39;&amp;lt;template&amp;gt;&#39;, &#39;exec&#39;), ns)
 compiled = ns[def_name]           
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;返回一个函数&lt;code&gt;_compiled_fn&lt;/code&gt;，这个函数使用了之前&lt;code&gt;ast&lt;/code&gt;创建的函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def _compiled_fn(self, append, values):
   ...
   return compiled(self, append, values, options, log)
   ...
           
return _compiled_fn
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个基于&lt;code&gt;ast&lt;/code&gt;的模版引擎，个人感觉最大的好处就是，可以将系统中注册的各种资源自由的组合到一起。&lt;/p&gt;

&lt;p&gt;最终&lt;code&gt;/web&lt;/code&gt;获得了由&lt;code&gt;web.webclient_bootstrap&lt;/code&gt;生成的页面。但是通过对模版以及页面的分析发现，这时浏览器只获得了页面的框架、css、js。而模块中定义的视图则是由&lt;code&gt;odoo&lt;/code&gt;自己定义的一套javascript引擎，从服务器获取后绘制到页面上的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>odoo的阶段性总结：服务器的启动、模块的加载、请求处理、页面生成</title>
      <link>https://asdfsx.github.io/post/odoo/odoo%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 05 Jan 2017 15:32:00 +0800</pubDate>
      
      <guid>https://asdfsx.github.io/post/odoo/odoo%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/</guid>
      <description>

&lt;p&gt;经过漫长的阅读代码，搞清了启动的过程。先简单做个总结。如有遗漏之后再做补充。&lt;/p&gt;

&lt;h3 id=&#34;系统的启动-模块的加载&#34;&gt;系统的启动，模块的加载&lt;/h3&gt;

&lt;p&gt;结合之前研究过的&lt;code&gt;registry&lt;/code&gt;，系统启动时会发生如下动作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先加载全局模块&lt;code&gt;web&lt;/code&gt;，&lt;code&gt;web_kanban&lt;/code&gt;。（在没有确定数据库地址之前，只能显示数据库选择页面。所以这个时候只需要这两个模块就可以了）

&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;import controller&lt;/code&gt;时，由于元类的作用，&lt;code&gt;controller&lt;/code&gt;类会自动加载到解释器中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;根据配置创建web服务器（线程的、进程的），所有的服务器都使用&lt;code&gt;odoo.service.wsgi_server.application&lt;/code&gt;来处理请求。

&lt;ul&gt;
&lt;li&gt;具体处理请求的是&lt;code&gt;odoo.http.Root&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;根据需要看要不要再次加载插件&lt;/li&gt;
&lt;li&gt;只有当首次接收请求的时候，才会执行加载插件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;启动服务器

&lt;ul&gt;
&lt;li&gt;在启动web服务器之前，首先创建&lt;code&gt;registry&lt;/code&gt;。（在进程的实现中，registry会在进程&lt;code&gt;fork&lt;/code&gt;之前创建，&lt;code&gt;fork&lt;/code&gt;之后&lt;code&gt;registry&lt;/code&gt;会被拷贝到各个进程的内存空间中）&lt;/li&gt;
&lt;li&gt;当数据库选定之后，&lt;code&gt;registry&lt;/code&gt;会根据配置去加载模块

&lt;ul&gt;
&lt;li&gt;先加载&lt;code&gt;base&lt;/code&gt;模块

&lt;ul&gt;
&lt;li&gt;先创建&lt;code&gt;base&lt;/code&gt;模块的依赖关系图&lt;code&gt;graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;graph&lt;/code&gt;加载&lt;code&gt;base&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;获取模块中的所有模型&lt;/li&gt;
&lt;li&gt;组装配置模型类

&lt;ul&gt;
&lt;li&gt;根据模型的属性，创建新的模型类，并将模型类注册到&lt;code&gt;registry&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;根据模型的属性，为新的模型类添加字段，关联关系等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;初始化模型

&lt;ul&gt;
&lt;li&gt;根据模型类，创建模型类对应的表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;装载定义在&lt;code&gt;__manifast__.py&lt;/code&gt;中的模块的数据

&lt;ul&gt;
&lt;li&gt;获取文件列表&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;odoo.tools.convert.convert_file&lt;/code&gt;装载文件。

&lt;ul&gt;
&lt;li&gt;判断文件类型，根据文件类型使用不同的方法解析&lt;/li&gt;
&lt;li&gt;根据情况将数据写入&lt;code&gt;ir.model.data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据情况将数据写入模型自己的数据表中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;根据配置标注其它需要加载的模块&lt;/li&gt;
&lt;li&gt;根据标注加载模块

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;graph&lt;/code&gt;进行模块的记载（下边以&lt;code&gt;web&lt;/code&gt;模块为例，看一下模块数据的加载）

&lt;ul&gt;
&lt;li&gt;获取数据文件：&lt;code&gt;views/webclient_templates.xml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;odoo.tools.convert.convert_file&lt;/code&gt;装载文件

&lt;ul&gt;
&lt;li&gt;创建&lt;code&gt;xml&lt;/code&gt;专用的解析器对象&lt;code&gt;xml_import&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解析&lt;code&gt;xml&lt;/code&gt;文件

&lt;ul&gt;
&lt;li&gt;遍历整个&lt;code&gt;xml&lt;/code&gt;文档树，根据节点的类型调用不同的函数来进行处理。具体到&lt;code&gt;views/webclient_templates.xml&lt;/code&gt;，这个文件由&lt;code&gt;template&lt;/code&gt;组成，对应的函数是&lt;code&gt;_tag_template&lt;/code&gt;。这个函数在结尾调用&lt;code&gt;_tag_record&lt;/code&gt;，这个函数会将数据文件里的内容写入&lt;code&gt;ir_model_data&lt;/code&gt;表中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;模块加载完毕后，服务器开始运行。等待处理请求。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;请求处理&#34;&gt;请求处理&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;首次接受到请求

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;odoo.http.Root&lt;/code&gt;根据请求创建&lt;code&gt;JsonRequest&lt;/code&gt;或者&lt;code&gt;HttpRequest&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;Registry&lt;/code&gt;中查找&lt;code&gt;ir.http&lt;/code&gt;模型&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;ir.http&lt;/code&gt;模型&lt;code&gt;_dispatch&lt;/code&gt;转发请求

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_dispatch&lt;/code&gt;查询路由表

&lt;ul&gt;
&lt;li&gt;如果路由表不存在，使用&lt;code&gt;odoo.http.routing_map&lt;/code&gt;创建路由表&lt;/li&gt;
&lt;li&gt;使用路由表获取处理请求的具体&lt;code&gt;controller&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;校验用户&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;controller&lt;/code&gt;放入请求对象中&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;request.dispatch&lt;/code&gt;处理请求&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;request.dispatch&lt;/code&gt;函数中（以HttpRequest为例），对请求参数、请求头、等进行校验，然后通过调用&lt;code&gt;_call_function&lt;/code&gt;来调用之前放入&lt;code&gt;request&lt;/code&gt;的&lt;code&gt;controller&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;controller&lt;/code&gt;中的处理函数设置了延迟生成页面，则在&lt;code&gt;dispatch&lt;/code&gt;结束的时候生成页面。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;页面生成&#34;&gt;页面生成&lt;/h3&gt;

&lt;p&gt;请求处理完成后，要生成显示的页面。以入口地址为例：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;处理&lt;code&gt;/&lt;/code&gt;请求的&lt;code&gt;controller&lt;/code&gt;为&lt;code&gt;addon.web.controllers.main.Home&lt;/code&gt;，定义在&lt;code&gt;web&lt;/code&gt;模块中，处理方式是直接跳转到&lt;code&gt;/web&lt;/code&gt;。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;处理&lt;code&gt;/web&lt;/code&gt;请求的&lt;code&gt;controller&lt;/code&gt;同上，使用&lt;code&gt;web.webclient_bootstrap&lt;/code&gt;这个模版来生成页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class Home(http.Controller):
    @http.route(&#39;/&#39;, type=&#39;http&#39;, auth=&amp;quot;none&amp;quot;)
    def index(self, s_action=None, db=None, **kw):
        return http.local_redirect(&#39;/web&#39;, query=request.params, keep_hash=True)
        
    @http.route(&#39;/web&#39;, type=&#39;http&#39;, auth=&amp;quot;none&amp;quot;)
    def web_client(self, s_action=None, **kw):
        ensure_db()
        if not request.session.uid:
            return werkzeug.utils.redirect(&#39;/web/login&#39;, 303)
        if kw.get(&#39;redirect&#39;):
            return werkzeug.utils.redirect(kw.get(&#39;redirect&#39;), 303)

        request.uid = request.session.uid
        context = request.env[&#39;ir.http&#39;].webclient_rendering_context()

        return request.render(&#39;web.webclient_bootstrap&#39;, qcontext=context)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;请求的处理，之前已经提到过了。&lt;code&gt;request.render&lt;/code&gt;函数里，会创建&lt;code&gt;Response&lt;/code&gt;对象。不管是否使用延迟创建页面，最终是通过&lt;code&gt;response.render&lt;/code&gt;来生成页面。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;response.render&lt;/code&gt;会用&lt;code&gt;ir.ui.view&lt;/code&gt;模型来根据模版来创建页面。具体到&lt;code&gt;/web&lt;/code&gt;请求的处理，就是使用&lt;code&gt;ir.ui.view&lt;/code&gt;模型的&lt;code&gt;render_template&lt;/code&gt;函数，利用&lt;code&gt;web.webclient_bootstrap&lt;/code&gt;模版来创建页面。

&lt;ul&gt;
&lt;li&gt;先用&lt;code&gt;ir.ui.view&lt;/code&gt;模型的&lt;code&gt;get_view_id&lt;/code&gt;函数中，先在&lt;code&gt;ir.model.data&lt;/code&gt;模型中查找模版：根据模版的名字，获取&lt;code&gt;res_id&lt;/code&gt;：
&lt;code&gt;
select ir_model_data.id from ir_model_data where module=&#39;web&#39; and name=&#39;webclient_bootstrap&#39;
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用基类的&lt;code&gt;browse&lt;/code&gt;函数，创建一个&lt;code&gt;View&lt;/code&gt;对象，保存&lt;code&gt;res_id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;View&lt;/code&gt;的&lt;code&gt;render&lt;/code&gt;函数

&lt;ul&gt;
&lt;li&gt;调用&lt;code&gt;ir.qweb&lt;/code&gt;的&lt;code&gt;render&lt;/code&gt;函数

&lt;ul&gt;
&lt;li&gt;调用&lt;code&gt;QWeb&lt;/code&gt;的&lt;code&gt;render&lt;/code&gt;函数

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;ir.qweb&lt;/code&gt;的&lt;code&gt;load&lt;/code&gt;读入模版

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;ir.ui.view&lt;/code&gt;中的&lt;code&gt;read_template&lt;/code&gt;读入模版

&lt;ul&gt;
&lt;li&gt;从&lt;code&gt;ir_ui_view&lt;/code&gt;表中获取&lt;code&gt;arch_fs&lt;/code&gt;信息，然后读取对应的文件作为&lt;code&gt;arch&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;ast&lt;/code&gt;对模版进行处理，生成一个&lt;code&gt;python&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;用生成的函数生成最终的页面&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过访问&lt;code&gt;/web&lt;/code&gt;只是获得了页面的框架、样式表、js等静态资源。然后&lt;code&gt;odoo&lt;/code&gt;会通过自己实现的一套&lt;code&gt;js&lt;/code&gt;框架，从服务器获取展示所需的其它部分绘制到页面上。&lt;/p&gt;

&lt;p&gt;接下来的部分基于对前端的一些猜测：
当浏览器打开由模版生成的页面后，将页面上相关的静态资源下载到本地。其中的&lt;code&gt;js&lt;/code&gt;加载到浏览器后，会向服务器发起请求，来获取当前页面上要的元素：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;/web/action/load&lt;br /&gt;
获取要展示模块的行为&lt;br /&gt;
json请求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{jsonrpc:&amp;quot;2.0&amp;quot;,method=&amp;quot;call&amp;quot;,params:{action_id:261}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务器会从&lt;code&gt;ir_action&lt;/code&gt;中查询&lt;code&gt;action_id&lt;/code&gt;对应的记录，并返回&lt;code&gt;action&lt;/code&gt;相关的信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ jsonrpc:&amp;quot;2.0&amp;quot;,
result:{ ...
    xml_id:&amp;quot;qingjia.action_qingjia_qingjd&amp;quot;,
    ...
    res_model:&amp;quot;qingjiaj.qingjd&amp;quot;,
    search_view:&amp;quot;{&#39;name&#39;:&#39;default&#39;,&#39;arch&#39;:....}&amp;quot;,
    ..
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;odoo的js框架会根据收到的数据，在页面上添加响应的元素（如按钮）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;/web/dataset/call_kw/qingjia.qingjd/load_views&lt;br /&gt;
加载模块展示需要用到的view
json请求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{jsonrpc:&amp;quot;2.0&amp;quot;, method:&amp;quot;call&amp;quot;, params:{
model:&amp;quot;qingjia.qingjd&amp;quot;,
method:&amp;quot;load_views&amp;quot;,
kwargs:{
views:[[null, &amp;quot;list&amp;quot;],[null,&amp;quot;from&amp;quot;],[false,&amp;quot;search&amp;quot;]],
...
}
}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务器会服务器返回结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{jsonrpc:&amp;quot;2.0&amp;quot;
     result:{
         fields:{
             id:{...},
             create_date:{...},
             ...
         },
         fields_views:{
             form:{},
             list:{},
             search:{},
         },
         ...
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到在一次请求中，获得了3种view。这些结果会缓存在浏览器，odoo的js框架之后就不需要反复的去获取view。同时js框架会根据以上内容在页面上生成相应的内容。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;hellip;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>odoo模型中的Field</title>
      <link>https://asdfsx.github.io/post/odoo/odoo%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84Field/</link>
      <pubDate>Thu, 05 Jan 2017 12:39:46 +0800</pubDate>
      
      <guid>https://asdfsx.github.io/post/odoo/odoo%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84Field/</guid>
      <description>

&lt;p&gt;&lt;code&gt;Odoo&lt;/code&gt;的定义了自己的一套&lt;code&gt;ORM&lt;/code&gt;系统。其中的一个重要组成部分就是字段的处理。这部分的内容都在&lt;code&gt;odoo.field&lt;/code&gt;中。和其他模块一样，也大量使用了python的特殊语法，如：元类、&lt;code&gt;__slots__&lt;/code&gt;、特殊函数，等。&lt;/p&gt;

&lt;h3 id=&#34;元类-odoo-fields-metafield&#34;&gt;元类：odoo.fields.MetaField&lt;/h3&gt;

&lt;p&gt;所有的字段类型的元类。如果一个字段类型使用了这个类，那么在创建这个类型时元类会扫描类中是否有&lt;code&gt;_slots&lt;/code&gt;属性。如果有的话，会将&lt;code&gt;_slots&lt;/code&gt;中的东西放到&lt;code&gt;__slots__&lt;/code&gt;中。然后在初始化这个类型的时候，会把这个新创建的类型放在&lt;code&gt;MetaField&lt;/code&gt;的&lt;code&gt;by_type&lt;/code&gt;字典中。&lt;/p&gt;

&lt;p&gt;注：&lt;code&gt;__slots__&lt;/code&gt;的作用是用来存放类实例中的属性。默认，python中的实例是存放在&lt;code&gt;__dict__&lt;/code&gt;中的；如果声明了&lt;code&gt;__slots__&lt;/code&gt;就不会创建&lt;code&gt;__dict__&lt;/code&gt;；&lt;code&gt;__slots__&lt;/code&gt;应该比
&lt;code&gt;__dict__&lt;/code&gt;节省空间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MetaField(type):
    &amp;quot;&amp;quot;&amp;quot; Metaclass for field classes. &amp;quot;&amp;quot;&amp;quot;
    by_type = {}
    
    def __new__(meta, name, bases, attrs):
        &amp;quot;&amp;quot;&amp;quot; Combine the ``_slots`` dict from parent classes, and determine
        ``__slots__`` for them on the new class.
        &amp;quot;&amp;quot;&amp;quot;
        base_slots = {}
        for base in reversed(bases):
            base_slots.update(getattr(base, &#39;_slots&#39;, ()))

        slots = dict(base_slots)
        slots.update(attrs.get(&#39;_slots&#39;, ()))

        attrs[&#39;__slots__&#39;] = set(slots) - set(base_slots)
        attrs[&#39;_slots&#39;] = slots
        return type.__new__(meta, name, bases, attrs)

    def __init__(cls, name, bases, attrs):
        super(MetaField, cls).__init__(name, bases, attrs)
        if cls.type and cls.type not in MetaField.by_type:
            MetaField.by_type[cls.type] = cls

        # compute class attributes to avoid calling dir() on fields
        cls.related_attrs = []
        cls.description_attrs = []
        for attr in dir(cls):
            if attr.startswith(&#39;_related_&#39;):
                cls.related_attrs.append((attr[9:], attr))
            elif attr.startswith(&#39;_description_&#39;):
                cls.description_attrs.append((attr[13:], attr))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基类-odoo-fields-field&#34;&gt;基类：odoo.fields.Field&lt;/h3&gt;

&lt;p&gt;所有字段类的基类。定义了一个长长的&lt;code&gt;_slots&lt;/code&gt;；定义了字段用到的大部分方法；定义了类型转换的方法&lt;code&gt;convert_to_read&lt;/code&gt;、&lt;code&gt;convert_to_column&lt;/code&gt;等，以便子类扩展。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Field(object):
    __metaclass__ = MetaField
    type = None                         # type of the field (string)
    relational = False                  # whether the field is a relational one
    translate = False                   # whether the field is translated

    column_type = None                  # database column type (ident, spec)
    column_format = &#39;%s&#39;                # placeholder for value in queries
    ......
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;布尔型-odoo-fields-boolean&#34;&gt;布尔型：odoo.fields.Boolean&lt;/h3&gt;

&lt;p&gt;布尔类型是最简单的一个实现。可以看到通过覆盖&lt;code&gt;convert_to_column&lt;/code&gt;函数，定义了如何将数据库中读出的内容，转换为python中的布尔型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Boolean(Field):
    type = &#39;boolean&#39;
    column_type = (&#39;bool&#39;, &#39;bool&#39;)

    def convert_to_column(self, value, record):
        return bool(value)

    def convert_to_cache(self, value, record, validate=True):
        return bool(value)

    def convert_to_export(self, value, record):
        if record._context.get(&#39;export_raw_data&#39;):
            return value
        return ustr(value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其它类似得类还有很多：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;odoo.fields.Integer&lt;/li&gt;
&lt;li&gt;odoo.fields.Float&lt;/li&gt;
&lt;li&gt;odoo.fields.Float&lt;/li&gt;
&lt;li&gt;odoo.fields.Monetary&lt;/li&gt;
&lt;li&gt;odoo.fields._String&lt;/li&gt;
&lt;li&gt;odoo.fields.Char&lt;/li&gt;
&lt;li&gt;odoo.fields.Text&lt;/li&gt;
&lt;li&gt;odoo.fields.Html&lt;/li&gt;
&lt;li&gt;odoo.fields.Date&lt;/li&gt;
&lt;li&gt;odoo.fields.Datetime&lt;/li&gt;
&lt;li&gt;odoo.fields.Binary&lt;/li&gt;
&lt;li&gt;odoo.fields.Selection&lt;/li&gt;
&lt;li&gt;odoo.fields.Reference&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;关系类-odoo-fields-relational&#34;&gt;关系类：odoo.fields._Relational&lt;/h3&gt;

&lt;p&gt;还有一些特殊的字段用来处理一对多或多对一的关系，它们的父类是&lt;code&gt;odoo.fields._Relational&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class _Relational(Field):
    &amp;quot;&amp;quot;&amp;quot; Abstract class for relational fields. &amp;quot;&amp;quot;&amp;quot;
    relational = True
    _slots = {
        &#39;domain&#39;: [],                   # domain for searching values
        &#39;context&#39;: {},                  # context for searching values
    }
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个类型有如下子类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;odoo.fields.Many2one&lt;/li&gt;
&lt;li&gt;odoo.fields.One2many&lt;/li&gt;
&lt;li&gt;odoo.fields.Many2many&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;主键类-odoo-fields-id&#34;&gt;主键类：odoo.fields.Id&lt;/h3&gt;

&lt;p&gt;每个模型类中都会有的字段，从这里可以看到，主键与&lt;code&gt;_ids&lt;/code&gt;的关系。（曾经非常疑惑为什么通过&lt;code&gt;browse&lt;/code&gt;获得模型类以后，可以访问&lt;code&gt;id&lt;/code&gt;属性。从&lt;code&gt;__get__&lt;/code&gt;函数里可以基本找到答案了。）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Id(Field):
&amp;quot;&amp;quot;&amp;quot; Special case for field &#39;id&#39;. &amp;quot;&amp;quot;&amp;quot;
    type = &#39;integer&#39;
    column_type = (&#39;int4&#39;, &#39;int4&#39;)
    _slots = {
        &#39;string&#39;: &#39;ID&#39;,
        &#39;store&#39;: True,
        &#39;readonly&#39;: True,
    }

    def __get__(self, record, owner):
        if record is None:
            return self         # the field is accessed through the class owner
        if not record:
            return False
        return record.ensure_one()._ids[0]

    def __set__(self, record, value):
        raise TypeError(&amp;quot;field &#39;id&#39; cannot be assigned&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;例子-odoo-addons-base-ir-res-res-users-users&#34;&gt;例子：odoo.addons.base.ir.res.res_users.Users:&lt;/h3&gt;

&lt;p&gt;依然以&lt;code&gt;users&lt;/code&gt;为例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Users(models.Model):
    _name = &amp;quot;res.users&amp;quot;
    _description = &#39;Users&#39;
    _inherits = {&#39;res.partner&#39;: &#39;partner_id&#39;}
    _order = &#39;name, login&#39;
    __uid_cache = defaultdict(dict)
    
    partner_id = fields.Many2one(&#39;res.partner&#39;, required=True, ondelete=&#39;restrict&#39;, auto_join=True,
        string=&#39;Related Partner&#39;, help=&#39;Partner-related data of the user&#39;)
    login = fields.Char(required=True, help=&amp;quot;Used to log into the system&amp;quot;)
    password = fields.Char(default=&#39;&#39;, invisible=True, copy=False,
        help=&amp;quot;Keep empty if you don&#39;t want the user to be able to connect on the system.&amp;quot;)
    new_password = fields.Char(string=&#39;Set Password&#39;,
        compute=&#39;_compute_password&#39;, inverse=&#39;_inverse_password&#39;,
        help=&amp;quot;Specify a value only when creating a user or if you&#39;re &amp;quot;\
             &amp;quot;changing the user&#39;s password, otherwise leave empty. After &amp;quot;\
             &amp;quot;a change of password, the user has to login again.&amp;quot;)
    signature = fields.Html()
    active = fields.Boolean(default=True)
    action_id = fields.Many2one(&#39;ir.actions.actions&#39;, string=&#39;Home Action&#39;,
        help=&amp;quot;If specified, this action will be opened at log on for this user, in addition to the standard menu.&amp;quot;)
    groups_id = fields.Many2many(&#39;res.groups&#39;, &#39;res_groups_users_rel&#39;, &#39;uid&#39;, &#39;gid&#39;, string=&#39;Groups&#39;, default=_default_groups)
    log_ids = fields.One2many(&#39;res.users.log&#39;, &#39;create_uid&#39;, string=&#39;User log entries&#39;)
    login_date = fields.Datetime(related=&#39;log_ids.create_date&#39;, string=&#39;Latest connection&#39;)
    share = fields.Boolean(compute=&#39;_compute_share&#39;, compute_sudo=True, string=&#39;Share User&#39;, store=True,
         help=&amp;quot;External user with limited access, created only for the purpose of sharing data.&amp;quot;)
    companies_count = fields.Integer(compute=&#39;_compute_companies_count&#39;, string=&amp;quot;Number of Companies&amp;quot;, default=_companies_count)
    tz_offset = fields.Char(compute=&#39;_compute_tz_offset&#39;, string=&#39;Timezone offset&#39;, invisible=True)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;不算总结的总结&#34;&gt;不算总结的总结&lt;/h3&gt;

&lt;p&gt;通过自己定的&lt;code&gt;Field&lt;/code&gt;类型。&lt;code&gt;Odoo&lt;/code&gt;实现了将数据库中读到的数据转化成python中的数据类型。但是仍然有些没有太搞清楚，如&lt;code&gt;many2one&lt;/code&gt;、&lt;code&gt;one2many&lt;/code&gt;这种类型。之后在使用中再研究它们。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>odoo的模型 Model</title>
      <link>https://asdfsx.github.io/post/odoo/odoo%E7%9A%84model/</link>
      <pubDate>Fri, 30 Dec 2016 14:31:31 +0800</pubDate>
      
      <guid>https://asdfsx.github.io/post/odoo/odoo%E7%9A%84model/</guid>
      <description>

&lt;p&gt;&lt;code&gt;model&lt;/code&gt;是&lt;code&gt;odoo&lt;/code&gt;中最重要的部分之一。主要负责各种功能的实现，&lt;code&gt;crm&lt;/code&gt;之类的业务模块中的功能姑且不论，页面渲染、工作流引擎、定时任务等核心的功能，也都是基于模型来实现。&lt;/p&gt;

&lt;h3 id=&#34;元类的基础-odoo-api-meta&#34;&gt;元类的基础：odoo.api.Meta&lt;/h3&gt;

&lt;p&gt;检查要创建的类中的所有函数，然后根据各函数&lt;code&gt;_api&lt;/code&gt;属性进行特殊处理。处理完成后再创建该类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Meta(type):
    &amp;quot;&amp;quot;&amp;quot; Metaclass that automatically decorates traditional-style methods by
        guessing their API. It also implements the inheritance of the
        :func:`returns` decorators.
    &amp;quot;&amp;quot;&amp;quot;

    def __new__(meta, name, bases, attrs):
        # dummy parent class to catch overridden methods decorated with &#39;returns&#39;
        parent = type.__new__(meta, name, bases, {})

        for key, value in attrs.items():
            if not key.startswith(&#39;__&#39;) and callable(value):
                # make the method inherit from decorators
                value = propagate(getattr(parent, key, None), value)

                # guess calling convention if none is given
                if not hasattr(value, &#39;_api&#39;):
                    try:
                        value = guess(value)
                    except TypeError:
                        pass

                if (getattr(value, &#39;_api&#39;, None) or &#39;&#39;).startswith(&#39;cr&#39;):
                    _logger.warning(&amp;quot;Deprecated method %s.%s in module %s&amp;quot;, name, key, attrs.get(&#39;__module__&#39;))

                attrs[key] = value

        return type.__new__(meta, name, bases, attrs)
        
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;元类-odoo-models-metamodel&#34;&gt;元类：odoo.models.MetaModel&lt;/h3&gt;

&lt;p&gt;所有的模型的元类，继承了&lt;code&gt;odoo.api.Meta&lt;/code&gt;，可以自动记录模型属于哪个模块。在Python的数据结构定义了&lt;code&gt;__new__&lt;/code&gt;和&lt;code&gt;__init__&lt;/code&gt;的区别。这里也可以发现，&lt;code&gt;Meta&lt;/code&gt;中&lt;code&gt;__new__&lt;/code&gt;负责创建类型对象，&lt;code&gt;MetaModel&lt;/code&gt;中&lt;code&gt;__init__&lt;/code&gt;负责初始化类型对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MetaModel(api.Meta):
    module_to_models = defaultdict(list)
    def __init__(self, name, bases, attrs):
        ...
        if not self._custom:
            self.module_to_models[self._module].append(self)
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基类的基类-odoo-models-basemodel&#34;&gt;基类的基类：odoo.models.BaseModel&lt;/h3&gt;

&lt;p&gt;这个基类不再是鸡肋了。它是所有模型的基类。它的作用大致如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义了一系列模型的属性&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据类属性，用&lt;code&gt;_build_model&lt;/code&gt;创建新模型类（要处理模型之间的继承关系），新模型类会存放在&lt;code&gt;registry&lt;/code&gt;中。（&lt;code&gt;pool&lt;/code&gt;变量其实就是&lt;code&gt;registry&lt;/code&gt;）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@classmethod
def _build_model(cls, pool, cr):
    ...
    ModelClass.pool = pool
    pool[name] = ModelClass
            
    model = object.__new__(ModelClass)
    model.__init__(pool, cr)
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据模型属性，用&lt;code&gt;_setup_base&lt;/code&gt;为新的模型类添加父模型的字段、删除不需要的字段。最重要的添加魔法字段&lt;code&gt;_add_magic_fields&lt;/code&gt;，其中包括模型的主键&lt;code&gt;id&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据模型属性，用&lt;code&gt;_setup_fields&lt;/code&gt;为新的模型类添加字段。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当新的模型类安装配置好以后，用&lt;code&gt;_auto_init&lt;/code&gt;来进行初始化。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据&lt;code&gt;_fields&lt;/code&gt;属性，在数据库中的&lt;code&gt;ir_model&lt;/code&gt;等表中记录模型中的字段；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@api.model_cr_context
def _field_create(self):
    ...
    cr.execute(&amp;quot;&amp;quot;&amp;quot; INSERT INTO ir_model (model, name, info, state, transient)
                   VALUES (%(model)s, %(name)s, %(info)s, %(state)s, %(transient)s)
                   RETURNING id &amp;quot;&amp;quot;&amp;quot;, params)
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据&lt;code&gt;_table&lt;/code&gt;属性，在数据库建表（建立一个只有主键的表）；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@api.model_cr
def _create_table(self):
    self._cr.execute(&#39;CREATE TABLE &amp;quot;%s&amp;quot; (id SERIAL NOT NULL, PRIMARY KEY(id))&#39; % (self._table,))
    self._cr.execute(&amp;quot;COMMENT ON TABLE \&amp;quot;%s\&amp;quot; IS %%s&amp;quot; % self._table, (self._description,))
    _schema.debug(&amp;quot;Table &#39;%s&#39;: created&amp;quot;, self._table)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据&lt;code&gt;_fields&lt;/code&gt;属性，修改之前建的表（用字段填充之间建的没有字段的表，或者改字段名，或者修改字段类型&amp;hellip;&amp;hellip;）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@api.model_cr_context
def _auto_init(self):
   ...
   else :
       # the column doesn&#39;t exist in database, create it
       cr.execute(&#39;ALTER TABLE &amp;quot;%s&amp;quot; ADD COLUMN &amp;quot;%s&amp;quot; %s&#39; % (self._table, name, field.column_type[1]))
       cr.execute(&amp;quot;COMMENT ON COLUMN %s.\&amp;quot;%s\&amp;quot; IS %%s&amp;quot; % (self._table, name), (field.string,))
       ...
   ...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;处理模型的依赖关系（可能反映到数据库上就是一个个外键约束）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@api.model_cr
def _add_sql_constraints(self):
    ...
    def add(name, definition):
        query = &#39;ALTER TABLE &amp;quot;%s&amp;quot; ADD CONSTRAINT &amp;quot;%s&amp;quot; %s&#39; % (self._table, name, definition)
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;处理模型的继承关系。&lt;br /&gt;
例如：在&lt;code&gt;_build_model&lt;/code&gt;过程中，子类的&lt;code&gt;cls._table&lt;/code&gt;属性可能直接使用了基类的&lt;code&gt;cls._table&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for base in reversed(cls.__bases__):
    if not getattr(base, &#39;pool&#39;, None):
    ...
        cls._table = base._table or cls._table
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建模型对象&lt;code&gt;_create&lt;/code&gt;，并返回一个模型类的新对象。&lt;br /&gt;
这个应该处理创建全新的模型记录。它会将新的模型记录存放到数据库中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@api.model
def _create(self, vals):
    ...
    query = &amp;quot;&amp;quot;&amp;quot;INSERT INTO &amp;quot;%s&amp;quot; (%s) VALUES(%s) RETURNING id&amp;quot;&amp;quot;&amp;quot; % (
            self._table,
            &#39;, &#39;.join(&#39;&amp;quot;%s&amp;quot;&#39; % u[0] for u in updates),
            &#39;, &#39;.join(u[1] for u in updates),
        )
    cr.execute(query, tuple(u[2] for u in updates if len(u) &amp;gt; 2))

    # from now on, self is the new record
    id_new, = cr.fetchone()
    self = self.browse(id_new)
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建模型对象&lt;code&gt;_browse&lt;/code&gt;。&lt;br /&gt;
可以看到利用&lt;code&gt;object.__new__(cls)&lt;/code&gt;创建了对象，然后对对象里的属性进行设定。个人感觉，这里创建的模型对象里只有最基本的id，没有模型的其它属性。如果需要其它属性的话，还需要通过&lt;code&gt;search&lt;/code&gt;来进行查询。这个函数应该用来处理系统中已存在的模型记录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@classmethod
def _browse(cls, ids, env, prefetch=None):
    records = object.__new__(cls)
    records.env = env
    records._ids = ids
    if prefetch is None:
        prefetch = defaultdict(set)         # {model_name: set(ids)}
    records._prefetch = prefetch
    prefetch[cls._name].update(ids)
    return records
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模型数据的读取。&lt;br /&gt;
在基类中还定义了一些特殊的函数&lt;code&gt;__getitem__&lt;/code&gt;、&lt;code&gt;__setitem__&lt;/code&gt;。通过这些函数，可以像访问字典一样访问模型对象中的数据。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模型数据的查询。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@api.model
def _search(self, args, offset=0, limit=None, order=None, count=False, access_rights_uid=None):
    ...
    query_str = &#39;SELECT &amp;quot;%s&amp;quot;.id FROM &#39; % self._table + from_clause + where_str + order_by + limit_str + offset_str
    self._cr.execute(query_str, where_clause_params)
    res = self._cr.fetchall()
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class BaseModel(object):
    __metaclass__ = MetaModel
    _auto = False               # don&#39;t create any database backend
    _register = False           # not visible in ORM registry
    _abstract = True            # whether model is abstract
    _transient = False          # whether model is transient
    
    _name = None                # the model name
    _table = None               # SQL table name used by model
    ......
    
    @api.model_cr_context
    def _field_create(self):
        ...
    
    @classmethod
    def _build_model(cls, pool, cr):
        ...
        
    @api.model_cr_context
    def _auto_init(self):
        &amp;quot;&amp;quot;&amp;quot; Instantiate a given model in the registry.
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基类-odoo-models-model&#34;&gt;基类：odoo.models.Model&lt;/h3&gt;

&lt;p&gt;模型大部分是继承这个类的。继承这个类的模型都会自动创建表。也就意味着会有数据写入表中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AbstractModel = BaseModel

class Model(AbstractModel):
    _auto = True                # automatically create database backend
    _register = False           # not visible in ORM registry, meant to be python-inherited only
    _abstract = False           # not abstract
    _transient = False          # not transient
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;例子-odoo-addons-base-ir-ir-ui-view-view&#34;&gt;例子：odoo.addons.base.ir.ir_ui_view.View&lt;/h3&gt;

&lt;p&gt;在之前研究请求处理的时候，看到了这个类。它主要是负责根据模版生成页面的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;registry&lt;/code&gt;可以通过它的名字&lt;code&gt;ir.ui.view&lt;/code&gt;来获取这个模型的类。&lt;/li&gt;
&lt;li&gt;数据库里会有一个表叫做&lt;code&gt;ir_ui_view&lt;/code&gt;。所有&lt;code&gt;View&lt;/code&gt;的子类，都会将相关的信息写入这个表。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;render_template&lt;/code&gt;用来生成页面&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用&lt;code&gt;get_view_id&lt;/code&gt;，获取&lt;code&gt;ir.model.data&lt;/code&gt;对象，然后从&lt;code&gt;ir_model_data&lt;/code&gt;表中根据模版名查找对应的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select * from ir_model_data where module=&#39;web&#39; and name=&#39;webclient_bootstrap&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过&lt;code&gt;browse&lt;/code&gt;创建模型&lt;code&gt;ir.ui.View&lt;/code&gt;的对象，模型对象里存放模版的id&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用模型的&lt;code&gt;render&lt;/code&gt;函数，制作页面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class View(models.Model):
    _name = &#39;ir.ui.view&#39;
    _order = &amp;quot;priority,name,id&amp;quot;

    # Holds the RNG schema
    _relaxng_validator = None
    
    name = fields.Char(string=&#39;View Name&#39;, required=True)
    model = fields.Char(index=True)
    key = fields.Char()
    priority = fields.Integer(string=&#39;Sequence&#39;, default=16, required=True)
    type = fields.Selection([(&#39;tree&#39;, &#39;Tree&#39;),
                             (&#39;form&#39;, &#39;Form&#39;),
                             (&#39;graph&#39;, &#39;Graph&#39;),
                             (&#39;pivot&#39;, &#39;Pivot&#39;),
                             (&#39;calendar&#39;, &#39;Calendar&#39;),
                             (&#39;diagram&#39;, &#39;Diagram&#39;),
                             (&#39;gantt&#39;, &#39;Gantt&#39;),
                             (&#39;kanban&#39;, &#39;Kanban&#39;),
                             (&#39;search&#39;, &#39;Search&#39;),
                             (&#39;qweb&#39;, &#39;QWeb&#39;)], string=&#39;View Type&#39;)
    ......
    
    @api.model
    def get_view_id(self, template):
        ...
        return self.env[&#39;ir.model.data&#39;].xmlid_to_res_id(template, raise_if_not_found=True)
        
    ...
    
    @api.model
    def render_template(self, template, values=None, engine=&#39;ir.qweb&#39;):
        return self.browse(self.get_view_id(template)).render(values, engine)
        
     @api.multi
    def render(self, values=None, engine=&#39;ir.qweb&#39;):
        assert isinstance(self.id, (int, long))

        qcontext = dict(
            env=self.env,
            keep_query=keep_query,
            request=request, # might be unbound if we&#39;re not in an httprequest context
            debug=request.debug if request else False,
            json=json,
            quote_plus=werkzeug.url_quote_plus,
            time=time,
            datetime=datetime,
            relativedelta=relativedelta,
            xmlid=self.key,
        )
        qcontext.update(values or {})

        return self.env[engine].render(self.id, qcontext)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;首先获取模版引擎，默认引擎是&lt;code&gt;ir.qweb&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用模版引擎的&lt;code&gt;render&lt;/code&gt;，生成页面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class IrQWeb(models.AbstractModel, QWeb):
    _name = &#39;ir.qweb&#39;
            
    @api.model
    def render(self, id_or_xml_id, values=None, **options):
        ...
        return super(IrQWeb, self).render(id_or_xml_id, values=values, **context)
                
    ......
        
class QWeb(object):
    ...
    def render(self, template, values=None, **options):
            
    ...
            
    def compile(self, template, options):
            
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;例子-odoo-addons-base-res-res-user&#34;&gt;例子：odoo.addons.base.res.res_user&lt;/h3&gt;

&lt;p&gt;由&lt;code&gt;base&lt;/code&gt;模块提供的一个保存&lt;code&gt;odoo&lt;/code&gt;用户的一个模型。应该有很多模型都利用了这个模型。比如&lt;code&gt;crm&lt;/code&gt;模块中的&lt;code&gt;odoo.addons.crm.models.res_user.User&lt;/code&gt;，这个模型就继承并扩展了这个&lt;code&gt;base&lt;/code&gt;模块中的模型。当安装&lt;code&gt;crm&lt;/code&gt;模块的时候，会将&lt;code&gt;crm&lt;/code&gt;中扩展的字段添加到&lt;code&gt;base&lt;/code&gt;中已经建好的&lt;code&gt;res_user&lt;/code&gt;表中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;下边为base模块中的模型

class Users(models.Model):
    _name = &amp;quot;res.users&amp;quot;
    _description = &#39;Users&#39;
    _inherits = {&#39;res.partner&#39;: &#39;partner_id&#39;}
    _order = &#39;name, login&#39;
    __uid_cache = defaultdict(dict)
    
    login = fields.Char(required=True, help=&amp;quot;Used to log into the system&amp;quot;)
    password = fields.Char(default=&#39;&#39;, invisible=True, copy=False,
    
.....

下边是crm模块中的模型    

class Users(models.Model):

    _inherit = &#39;res.users&#39;

    target_sales_won = fields.Integer(&#39;Won in Opportunities Target&#39;)
    target_sales_done = fields.Integer(&#39;Activities Done Target&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;不算总结的总结&#34;&gt;不算总结的总结&lt;/h3&gt;

&lt;p&gt;大概了解了一下模型的作用。还有遗漏的以后再补。这里遗留了一个问题，就是模型中的字段。
看了一下模型中的字段也算是&lt;code&gt;odoo&lt;/code&gt;自己实现的&lt;code&gt;orm&lt;/code&gt;的一部分，包括了元类、基类、一堆扩展。单开一章吧。&lt;code&gt;view&lt;/code&gt;在&lt;code&gt;odoo&lt;/code&gt;中也是很大的一块，也单开一章介绍吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>odoo中的请求处理</title>
      <link>https://asdfsx.github.io/post/odoo/odoo%E4%B8%AD%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 29 Dec 2016 15:57:59 +0800</pubDate>
      
      <guid>https://asdfsx.github.io/post/odoo/odoo%E4%B8%AD%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/</guid>
      <description>

&lt;h1 id=&#34;web请求&#34;&gt;Web请求&lt;/h1&gt;

&lt;p&gt;web请求的包装是在接收请求时，在&lt;code&gt;odoo.http.Root&lt;/code&gt;中处理的。请求主要分为&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;json请求：主要用来处理json请求、rpc请求。&lt;/li&gt;
&lt;li&gt;http请求：主要用来处理页面访问请求。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;请求的基类-odoo-http-webrequest&#34;&gt;请求的基类：odoo.http.WebRequest&lt;/h3&gt;

&lt;p&gt;所有请求的基类，定义了请求处理过程中都可能会用到的一些属性：如csrf、db、registry、session等等。&lt;/p&gt;

&lt;p&gt;同时WebQuest还使用了&lt;code&gt;__enter__&lt;/code&gt;、&lt;code&gt;__exit__&lt;/code&gt;。这样当使用&lt;code&gt;with request：&lt;/code&gt;这样当表达式时，会将当前&lt;code&gt;request&lt;/code&gt;放到&lt;code&gt;werkzeug.local.LocalStack&lt;/code&gt;中。方便从任何地方使用&lt;code&gt;odoo.http.request&lt;/code&gt;获取当前请求。&lt;/p&gt;

&lt;p&gt;具体处理请求的&lt;code&gt;endpoint&lt;/code&gt;是通过&lt;code&gt;set_handler&lt;/code&gt;传入的。&lt;code&gt;_call_function&lt;/code&gt;会调用&lt;code&gt;endpoint&lt;/code&gt;来获得返回结果。但是调用&lt;code&gt;_call_function&lt;/code&gt;的&lt;code&gt;dispath&lt;/code&gt;是由子类来实现的，基类中没有。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_request_stack = werkzeug.local.LocalStack()

request = _request_stack()

class WebRequest(object):
    ...
    @property
    def registry(self):
        return odoo.registry(self.db) if self.db else None
    
    @property
    def db(self):
        return self.session.db if not self.disable_db else None
    
    def csrf_token(self, time_limit=3600):
        ...
    
    ...
    def _call_function(self, *args, **kwargs):
        &amp;quot;&amp;quot;&amp;quot; Generates and returns a CSRF token for the current session
        ...
        
    def validate_csrf(self, csrf):
         ...
         
     def __enter__(self):
        _request_stack.push(self)
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        _request_stack.pop()
        ...
    
    def set_handler(self, endpoint, arguments, auth):
        # is this needed ?
        arguments = dict((k, v) for k, v in arguments.iteritems()
                         if not k.startswith(&amp;quot;_ignored_&amp;quot;))
        self.endpoint_arguments = arguments
        self.endpoint = endpoint
        self.auth_method = auth
     
    def _call_function(self, *args, **kwargs):
        ...
        return self.endpoint(*args, **kwargs)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;json请求-odoo-http-jsonrequest&#34;&gt;Json请求：odoo.http.JsonRequest&lt;/h3&gt;

&lt;p&gt;默认接收到的数据是json格式，所以在创建这个对象时，会按照&lt;code&gt;json&lt;/code&gt;的格式来读取请求数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class JsonRequest(WebRequest):
    def __init__(self, *args):
        ...
        self.jsonrequest = json.loads(request)
        ...
        self.params = dict(self.jsonrequest.get(&amp;quot;params&amp;quot;, {}))
        ...
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;http请求-odoo-http-httprequest&#34;&gt;Http请求：odoo.http.HttpRequest&lt;/h3&gt;

&lt;p&gt;在创建http请求时，从&lt;code&gt;url&lt;/code&gt;参数中、&lt;code&gt;form&lt;/code&gt;中、甚至上传的文件中获取请求信息。然后定义了&lt;code&gt;dispatch&lt;/code&gt;函数，这个函数负责创建并返回&lt;code&gt;Response&lt;/code&gt;对象。它通过调用基类中的&lt;code&gt;_call_function&lt;/code&gt;，调用从路由器得来的controller来获取&lt;code&gt;Response&lt;/code&gt;。
请求处理完成后，还要找到对应的模版，生成显示的页面（也可以根据&lt;code&gt;lazy&lt;/code&gt;参数延迟生成页面）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class HttpRequest(WebRequest):
    ...
    def __init__(self, *args):
        super(HttpRequest, self).__init__(*args)
        params = collections.OrderedDict(self.httprequest.args)
        params.update(self.httprequest.form)
        params.update(self.httprequest.files)
        params.pop(&#39;session_id&#39;, None)
        self.params = params

    ...

    def dispatch(self):
        ...
        r = self._call_function(**self.params)
        if not r:
            r = Response(status=204)  # no content
        return r
    
    ...
    
    def render(self, template, qcontext=None, lazy=True, **kw):
        response = Response(template=template, qcontext=qcontext, **kw)
        if not lazy:
            return response.render()
        return response
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;http响应-odoo-http-response&#34;&gt;Http响应：odoo.http.Response&lt;/h3&gt;

&lt;p&gt;这个只对应&lt;code&gt;http&lt;/code&gt;请求，主要的功能就是页面的创建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Response(werkzeug.wrappers.Response):
    ...
    def render(self):
        env = request.env(user=self.uid or request.uid or odoo.SUPERUSER_ID)
        self.qcontext[&#39;request&#39;] = request
        return env[&amp;quot;ir.ui.view&amp;quot;].render_template(self.template, self.qcontext)
    ...
    
    def flatten(self):
        &amp;quot;&amp;quot;&amp;quot; Forces the rendering of the response&#39;s template, sets the result
        as response body and unsets :attr:`.template`
        &amp;quot;&amp;quot;&amp;quot;
        if self.template:
            self.response.append(self.render())
            self.template = None
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;控制器&#34;&gt;控制器&lt;/h1&gt;

&lt;p&gt;对于一个有大量插件的项目来说，大量的路径管理是个麻烦事。不过&lt;code&gt;odoo&lt;/code&gt;有自己的解决之道，通过自己定义的一套&lt;code&gt;Controller&lt;/code&gt;机制。&lt;/p&gt;

&lt;h3 id=&#34;controller的元类-odoo-http-controllertype&#34;&gt;Controller的元类：odoo.http.ControllerType&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Controller&lt;/code&gt;的元类。如果一个类使用了这个元类的话，会自动存放到全局字典&lt;code&gt;controllers_per_module&lt;/code&gt;中。同时为了兼容老版本，会检查&lt;code&gt;Controller&lt;/code&gt;中的函数是否有&lt;code&gt;original_func&lt;/code&gt;属性。如果有，会给该函数增加路由属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;controllers_per_module = collections.defaultdict(list)

class ControllerType(type):
    def __init__(cls, name, bases, attrs):
        ...
        name_class = (&amp;quot;%s.%s&amp;quot; % (cls.__module__, cls.__name__), cls)
        ...
        controllers_per_module[module].append(name_class)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;controller的基类-odoo-http-controller&#34;&gt;Controller的基类：odoo.http.Controller&lt;/h3&gt;

&lt;p&gt;所有Controller的父类，可以看到使用了上边创建的元类。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Controller(object):
    __metaclass__ = ControllerType
    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;例子-web-模块的-controller&#34;&gt;例子：WEB 模块的 Controller&lt;/h3&gt;

&lt;p&gt;我们以&lt;code&gt;server-wide&lt;/code&gt;模块&lt;code&gt;web&lt;/code&gt;为例子，看看&lt;code&gt;Controller&lt;/code&gt;的具体使用。&lt;br /&gt;
当第一次访问&lt;code&gt;odoo&lt;/code&gt;时，请求由&lt;code&gt;index&lt;/code&gt;函数处理，被重定向到&lt;code&gt;/web&lt;/code&gt;。
当访问&lt;code&gt;/web&lt;/code&gt;时，会用&lt;code&gt;web.webclient_bootstrap&lt;/code&gt;模版来生成页面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Home(http.Controller):
    @http.route(&#39;/&#39;, type=&#39;http&#39;, auth=&amp;quot;none&amp;quot;)
    def index(self, s_action=None, db=None, **kw):
        return http.local_redirect(&#39;/web&#39;, query=request.params, keep_hash=True)
    
    @http.route(&#39;/web&#39;, type=&#39;http&#39;, auth=&amp;quot;none&amp;quot;)
    def web_client(self, s_action=None, **kw):
        ...
        return request.render(&#39;web.webclient_bootstrap&#39;, qcontext=context)
    
    @http.route(&#39;/web/dbredirect&#39;, type=&#39;http&#39;, auth=&amp;quot;none&amp;quot;)
    def web_db_redirect(self, redirect=&#39;/&#39;, **kw):
        ensure_db()
        return werkzeug.utils.redirect(redirect, 303)
        
    @http.route(&#39;/web/login&#39;, type=&#39;http&#39;, auth=&amp;quot;none&amp;quot;)
    def web_login(self, redirect=None, **kw):
        ...
        return request.render(&#39;web.login&#39;, values)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;首先继承&lt;code&gt;http.Controller&lt;/code&gt;，直接注册到&lt;code&gt;controllers_per_module&lt;/code&gt;中&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用来处理请求的都使用装饰器&lt;code&gt;http.route&lt;/code&gt;
包装以后，生成一个新函数&lt;code&gt;response_wrap&lt;/code&gt;，包含两个属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;routing&lt;/code&gt; 存放路由相关的信息，如：请求类型、路由地址等。&lt;br /&gt;
  之前在&lt;code&gt;http.routing_map&lt;/code&gt;函数中，依靠这个rouging获取路由的各个信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;original_func&lt;/code&gt; 存放原始的函数。（这个怀疑是为了兼容旧版本）
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def route(route=None, **kw):
    ...
    routing = kw.copy()
    def decorator(f):
        ...
        @functools.wraps(f)
        def response_wrap(*args, **kw):
            response = f(*args, **kw)
            ...
            return response
        response_wrap.routing = routing
        response_wrap.original_func = f
        return response_wrap
    return decorator
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;请求处理完后返回结果，通常是下一个要显示的页面&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;http.local_redirect&lt;/code&gt;进行重定向&lt;br /&gt;
其实就是对&lt;code&gt;werkzeug.utils.redirect&lt;/code&gt;的一个包装&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;request.render&lt;/code&gt;创建&lt;code&gt;response&lt;/code&gt;（支持lazy render）&lt;br /&gt;
可以看到如果是&lt;code&gt;lazy&lt;/code&gt;的话，只返回&lt;code&gt;Response&lt;/code&gt;对象。&lt;br /&gt;
如果不是&lt;code&gt;lazy&lt;/code&gt;的话，就直接生成最终的结果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;以HttpRequest为例：
        
def render(self, template, qcontext=None, lazy=True, **kw):
    response = Response(template=template, qcontext=qcontext, **kw)
    if not lazy:
        return response.render()
    return response
        
class Response(werkzeug.wrappers.Response):
    ...
    def render(self):
        &amp;quot;&amp;quot;&amp;quot; Renders the Response&#39;s template, returns the result
        &amp;quot;&amp;quot;&amp;quot;
        env = request.env(user=self.uid or request.uid or odoo.SUPERUSER_ID)
        self.qcontext[&#39;request&#39;] = request
        return env[&amp;quot;ir.ui.view&amp;quot;].render_template(self.template, self.qcontext)
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Response&lt;/code&gt;会根据提供的模版渲染出最终的页面&lt;br /&gt;
查找名为&lt;code&gt;ir.ui.view&lt;/code&gt;的模型&lt;code&gt;odoo.addons.base.ir.ir_ui_view.View&lt;/code&gt;，然后调用里面的&lt;code&gt;render_template&lt;/code&gt;、&lt;code&gt;render&lt;/code&gt;生成最终的页面&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;路由器&#34;&gt;路由器&lt;/h1&gt;

&lt;p&gt;当定义了大量的&lt;code&gt;controller&lt;/code&gt;后，如何将请求分发到这些&lt;code&gt;controller&lt;/code&gt;上就要靠路由器了。
在&lt;code&gt;odoo&lt;/code&gt;中，路由的功能由&lt;code&gt;IrHttp&lt;/code&gt;实现。&lt;/p&gt;

&lt;h3 id=&#34;odoo-addons-base-ir-ir-http-irhttp&#34;&gt;&lt;code&gt;odoo.addons.base.ir.ir_http.IrHttp&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;IrHttp&lt;/code&gt;也被定义为一个模型，不过它的基类是&lt;code&gt;AbstractModel&lt;/code&gt;。也就是说，这个模型不会在数据库中建表，只是一个纯粹提供功能的模型。主要功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;_dispatch&lt;/code&gt;请求转发&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_dispatch&lt;/code&gt;算是入口函数。它接收根据请求路径从&lt;code&gt;routing_map&lt;/code&gt;中查找&lt;code&gt;handler&lt;/code&gt;。然后进行用户校验。最后将&lt;code&gt;routing_map&lt;/code&gt;中查找到的&lt;code&gt;handler&lt;/code&gt;放入请求对象中。最后请求在&lt;code&gt;dispatch&lt;/code&gt;的时候处理请求。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;routing_map&lt;/code&gt;路由表的初始化&lt;br /&gt;
当类中没有&lt;code&gt;_routing_map&lt;/code&gt;属性时，使用&lt;code&gt;odoo.http.routing_map&lt;/code&gt;创建这个属性。&lt;code&gt;odoo.http.routing_map&lt;/code&gt;会遍历之前说过的&lt;code&gt;controllers_per_module&lt;/code&gt;，将所有的&lt;code&gt;controller&lt;/code&gt;、路径信息保存到&lt;code&gt;werkzeug.routing.Map&lt;/code&gt;中。最后的返回值就是这个&lt;code&gt;Map&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;_find_handler&lt;/code&gt;查找&lt;code&gt;controller&lt;/code&gt;
从routing_map中获取初期请求的&lt;code&gt;controller&lt;/code&gt;。获取到&lt;code&gt;routing_map&lt;/code&gt;后，用标准的&lt;code&gt;werkzeug&lt;/code&gt;获取陆游的方法匹配路由表，即：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;urls = url_map.bind_to_environ(environ)
endpoint, args = urls.match()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;_authenticate&lt;/code&gt;请求的安全验证&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总之在&lt;code&gt;IrHttp&lt;/code&gt;中，它根据需要创建&lt;code&gt;routing_map&lt;/code&gt;，从&lt;code&gt;routing_map&lt;/code&gt;中获取&lt;code&gt;controller&lt;/code&gt;，然后将&lt;code&gt;controller&lt;/code&gt;放入请求对象中，然后调用下&lt;code&gt;request.dispatch&lt;/code&gt;
并将结果返回。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class IrHttp(models.AbstractModel):

    ...
    
    @classmethod
    def routing_map(cls):
        if not hasattr(cls, &#39;_routing_map&#39;):
            ...
            cls._routing_map = http.routing_map(mods, False, converters=cls._get_converters())
        return cls._routing_map
        
    ...
    
    @classmethod
    def _find_handler(cls, return_rule=False):
        return cls.routing_map().bind_to_environ(request.httprequest.environ).match(return_rule=return_rule)
        
    ...
    
    @classmethod
    def _authenticate(cls, auth_method=&#39;user&#39;):
        ...
        if request.session.uid:
            request.session.check_security()
        ...
        
    ...
    
    @classmethod
    def _dispatch(cls):
        # locate the controller method
        try:
            rule, arguments = cls._find_handler(return_rule=True)
            func = rule.endpoint
        except werkzeug.exceptions.NotFound, e:
            return cls._handle_exception(e)

        # check authentication level
        try:
            auth_method = cls._authenticate(func.routing[&amp;quot;auth&amp;quot;])
        except Exception as e:
            return cls._handle_exception(e)

        processing = cls._postprocess_args(arguments, rule)
        if processing:
            return processing

        # set and execute handler
        try:
            request.set_handler(func, arguments, auth_method)
            result = request.dispatch()
            if isinstance(result, Exception):
                raise result
        except Exception, e:
            return cls._handle_exception(e)

        return result
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;请求处理器&#34;&gt;请求处理器&lt;/h1&gt;

&lt;h3 id=&#34;odoo-http-root&#34;&gt;&lt;code&gt;odoo.http.Root&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;所有种类的&lt;code&gt;server&lt;/code&gt;都使用&lt;code&gt;odoo.service.wsgi_server.application&lt;/code&gt;处理请求。而在其中，最重要的一个请求处理器是：&lt;code&gt;odoo.http.root&lt;/code&gt;，它主要负责页面请求的处理；另外一个&lt;code&gt;wsgi_xmlrpc&lt;/code&gt;，主要负责处理&lt;code&gt;xmlrpc&lt;/code&gt;一类的数据接口请求。&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;xmlrpc&lt;/code&gt;请求来说，处理起来相对容易：根据路径、参数，获取对应的函数；执行函数后将返回的结果转化成&lt;code&gt;json&lt;/code&gt;返回就可以了。&lt;/p&gt;

&lt;p&gt;对于另外一类来说就复杂很多：要将请求包装成&lt;code&gt;JsonRequest&lt;/code&gt;或者&lt;code&gt;HttpRequest&lt;/code&gt;；要根据路径找到对应的&lt;code&gt;controller&lt;/code&gt;；根据需要查找模版生成页面&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def wsgi_xmlrpc(environ, start_response):
    ...
    if environ[&#39;REQUEST_METHOD&#39;] == &#39;POST&#39; and environ[&#39;PATH_INFO&#39;].startswith(&#39;/xmlrpc/&#39;):
    ...
    
    
def application_unproxied(environ, start_response):
    ...
    with odoo.api.Environment.manage():
        # Try all handlers until one returns some result (i.e. not None).
        for handler in [wsgi_xmlrpc, odoo.http.root]:
            result = handler(environ, start_response)
            if result is None:
                continue
            return result
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上边的代码请求被&lt;code&gt;wsgi_xmlrpc，odoo.http.root&lt;/code&gt;两个函数处理。&lt;code&gt;odoo.http.root&lt;/code&gt;可以被当作函数使用，全都因为其中的&lt;code&gt;__call__&lt;/code&gt;函数。从下边代码中可以看到当&lt;code&gt;__call__&lt;/code&gt;首次运行时：首先加载模块；然后后&lt;code&gt;root&lt;/code&gt;会在&lt;code&gt;dispatch&lt;/code&gt;函数中判断请求类型生成&lt;code&gt;JsonRequest&lt;/code&gt;或&lt;code&gt;HttpRequest&lt;/code&gt;；从&lt;code&gt;request&lt;/code&gt;中查找&lt;code&gt;ir.http&lt;/code&gt;模型（其实就是从全局的&lt;code&gt;registry&lt;/code&gt;中）；通过&lt;code&gt;ir.http&lt;/code&gt;模型的&lt;code&gt;_dispatch&lt;/code&gt;来获得返回的结果；最后将结果生成最终的&lt;code&gt;Response&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;注意：之前在&lt;code&gt;HttpRequest&lt;/code&gt;类的&lt;code&gt;render&lt;/code&gt;函数中，可以设置请求的惰性处理（或者叫延迟处理）。在&lt;code&gt;dispatch&lt;/code&gt;函数的最后，在&lt;code&gt;get_response&lt;/code&gt;函数中，可以看到它调用了一个&lt;code&gt;result.flatten&lt;/code&gt;函数。这个函数定义在&lt;code&gt;Response&lt;/code&gt;对象中，它的作用是强制&lt;code&gt;render&lt;/code&gt;。
也就是说，如果设置了&lt;code&gt;HttpRequest&lt;/code&gt;延迟处理，那么直到dispatch进行完才会创建出页面，在此之前&lt;code&gt;response&lt;/code&gt;只是一个对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Root(object):
    def __init__(self):
        self._loaded = False
        
    def __call__(self, environ, start_response):
        &amp;quot;&amp;quot;&amp;quot; Handle a WSGI request
        &amp;quot;&amp;quot;&amp;quot;
        if not self._loaded:
            self._loaded = True
            self.load_addons()
        return self.dispatch(environ, start_response)
    
    def dispatch(self, environ, start_response):
        ...
        request = self.get_request(httprequest)
        ...
        with request:
            ...
            ir_http = request.registry[&#39;ir.http&#39;]
            ...
            result = ir_http._dispatch()
            ...
        ...
            response = self.get_response(httprequest, result, explicit_session)
        return response(environ, start_response)
        
    def get_request(self, httprequest):
        # deduce type of request
        if httprequest.args.get(&#39;jsonp&#39;):
            return JsonRequest(httprequest)
        if httprequest.mimetype in (&amp;quot;application/json&amp;quot;, &amp;quot;application/json-rpc&amp;quot;):
            return JsonRequest(httprequest)
        else:
            return HttpRequest(httprequest)
        
    def get_response(self, httprequest, result, explicit_session):
        if isinstance(result, Response) and result.is_qweb:
            ...
            result.flatten()
            ...
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;不算总结的总结&#34;&gt;不算总结的总结&lt;/h3&gt;

&lt;p&gt;经过若干次的补充，请求的处理貌似完成了。&lt;br /&gt;
终于搞清了&lt;code&gt;Request&lt;/code&gt;是如何一步步变成最终的&lt;code&gt;Resopnse&lt;/code&gt;。但是页面是如何生成的，依然是个问题。&lt;code&gt;odoo&lt;/code&gt;中使用了一套自己的模版体系来定义页面。通过&lt;code&gt;ir.ui.view&lt;/code&gt;这个模型将&lt;code&gt;Response&lt;/code&gt;变成最终的页面。&lt;br /&gt;
之后，就来研究一下&lt;code&gt;View&lt;/code&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>odoo的模块</title>
      <link>https://asdfsx.github.io/post/odoo/odoo%E7%9A%84%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Wed, 28 Dec 2016 16:49:21 +0800</pubDate>
      
      <guid>https://asdfsx.github.io/post/odoo/odoo%E7%9A%84%E6%A8%A1%E5%9D%97/</guid>
      <description>

&lt;p&gt;上一篇&lt;code&gt;odoo&lt;/code&gt;的模块管理，主要是odoo的模块加载。这一篇来看看模块到底是什么。&lt;br /&gt;
抄袭官网文档：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Both server and client extensions are packaged as modules which are optionally loaded in a database.

Odoo modules can either add brand new business logic to an Odoo system, or alter and extend existing business logic: a module can be created to add your country&#39;s accounting rules to Odoo&#39;s generic accounting support, while the next module adds support for real-time visualisation of a bus fleet.

Everything in Odoo thus starts and ends with modules.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在研究&lt;code&gt;odoo&lt;/code&gt;的过程中，也能感受到模块的重要性。&lt;code&gt;odoo&lt;/code&gt;核心的代码只有webserver、模块管理、数据库连接，其余的功能基本上都是由各个&lt;code&gt;addons&lt;/code&gt;目录中的模块实现，甚至最基础的显示框架都是由模块来实现。&lt;/p&gt;

&lt;h3 id=&#34;模块的内容&#34;&gt;模块的内容&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;业务模型&lt;br /&gt;
由Python类组成，并由Odoo负责进行持久化&lt;/li&gt;
&lt;li&gt;数据文件&lt;br /&gt;
XML、CSV格式的文件，包括元数据、配置文件、指标纬度等等&lt;/li&gt;
&lt;li&gt;web controller&lt;br /&gt;
处理浏览器发来的各种请求&lt;/li&gt;
&lt;li&gt;静态页面文件&lt;br /&gt;
包括图片、js、css&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;模块的结构&#34;&gt;模块的结构&lt;/h3&gt;

&lt;p&gt;通过&lt;code&gt;odoo-bin scaffold&lt;/code&gt;可以创建一个最基础的&lt;code&gt;odoo&lt;/code&gt;模块，从这个模块中我们可以看到一个模块的大致结构&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__init__.py&lt;/code&gt;&lt;br /&gt;
所有的python包都有的导入文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__manifest__.py&lt;/code&gt;&lt;br /&gt;
模块描述文件，内部就是一个字典，里边记录了模块名、描述、作者、分类、版本、依赖、数据文件等信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;controllers&lt;/code&gt;&lt;br /&gt;
存放web controller。&lt;code&gt;controller&lt;/code&gt;类继承了&lt;code&gt;odoo.http.Controller&lt;/code&gt;，用来定义访问的路径。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;demo&lt;/code&gt;&lt;br /&gt;
存放&lt;code&gt;demo&lt;/code&gt;使用的数据文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;security&lt;/code&gt;&lt;br /&gt;
存放模型的访问权限，通常是一个csv文件&lt;code&gt;ir.model.access.csv&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;views&lt;/code&gt;&lt;br /&gt;
存放定义页面、显示用的配置文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i18n&lt;/code&gt;
存放国际化使用的各种语言文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tests&lt;/code&gt;
存放测试用的程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;models&lt;/code&gt;&lt;br /&gt;
存放业务模型。模型继承了&lt;code&gt;odoo.models.Model&lt;/code&gt;。大部分的数据库操作由&lt;code&gt;odoo&lt;/code&gt;的&lt;code&gt;ORM&lt;/code&gt;层实现。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>odoo的模块管理</title>
      <link>https://asdfsx.github.io/post/odoo/odoo%E7%9A%84%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 27 Dec 2016 18:05:15 +0800</pubDate>
      
      <guid>https://asdfsx.github.io/post/odoo/odoo%E7%9A%84%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86/</guid>
      <description>

&lt;p&gt;之前一篇记录了odoo web server的大概情况，以及简单的启动流程、模块加载的情况。深入研究会发现odoo的所有功能都是基于模块制作的，所以本篇开始研究odoo的模块。首先研究下模块是如何进行管理的。负责管理模块的代码主要存放在&lt;code&gt;odoo.modules&lt;/code&gt;包里。&lt;/p&gt;

&lt;h3 id=&#34;模型的注册机-odoo-modules-registry-registry&#34;&gt;模型的注册机 odoo.modules.registry.Registry&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Registry&lt;/code&gt;的用途是存放模型名、模型类对应关系。是一个深度定制化的类。注意，&lt;code&gt;model&lt;/code&gt;、&lt;code&gt;module&lt;/code&gt;的区别。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;此类继承了&lt;code&gt;collections.Mapping&lt;/code&gt;，因此它的对像可以按照字典方式来使用&lt;/li&gt;
&lt;li&gt;这个类也是一个自产自销的类：创建自己的实例，然后将实例放到自己的类属性中。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类函数／属性&lt;code&gt;registries&lt;/code&gt;用来存放已创建的&lt;code&gt;Registry&lt;/code&gt;。
装饰器&lt;code&gt;lazy_classproperty&lt;/code&gt;是一个神器的东西，它把一个函数变成了一个属性：当函数第一次执行时，获得函数的返回值，然后将返回值设置为类中的一个属性（注意那个&lt;code&gt;setattr&lt;/code&gt;函数）。&lt;code&gt;__get__&lt;/code&gt;方法会在Registry.registry的时候执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class lazy_property(object):
    def __init__(self, fget):
        self.fget = fget
            
class lazy_classproperty(lazy_property):
    def __get__(self, obj, cls):
        val = self.fget(cls)
        setattr(cls, self.fget.__name__, val)
        return val
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用&lt;code&gt;__new__&lt;/code&gt;而不是&lt;code&gt;__init__&lt;/code&gt;来创建对象：首先尝试从&lt;code&gt;registries&lt;/code&gt;中获取已经生成的对象，失败后创建新对象。之前的python的数据结构中曾经探讨过&lt;code&gt;__init__&lt;/code&gt;和&lt;code&gt;__new__&lt;/code&gt;的区别。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Registry&lt;/code&gt;对象在&lt;code&gt;new()&lt;/code&gt;里生成：手动生成、手动初始化、存放到&lt;code&gt;registries&lt;/code&gt;中、加载所有的模块到&lt;code&gt;self.models&lt;/code&gt;字典中（&lt;code&gt;odoo.modules.load_modules&lt;/code&gt;函数）。在加载模块的过程中，还需要模块中导出模型（load函数）、完善模型（setup_models），根据模型建表、建约束（init_models）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注意LRU是Least Recently Used 近期最少使用算法。这里是一个python实现的功能模块。内部是一个字典。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Registry(Mapping):
    @lazy_classproperty
    def registries(cls):
        &amp;quot;&amp;quot;&amp;quot; A mapping from database names to registries. &amp;quot;&amp;quot;&amp;quot;
        size = config.get(&#39;registry_lru_size&#39;, None)
        ...
    return LRU(size)
        
    def __new__(cls, db_name):
        &amp;quot;&amp;quot;&amp;quot; Return the registry for the given database name.&amp;quot;&amp;quot;&amp;quot;
        with cls._lock:
            try:
                return cls.registries[db_name]
            except KeyError:
                return cls.new(db_name)
            finally:
                # set db tracker - cleaned up at the WSGI dispatching phase in
                # odoo.service.wsgi_server.application
                threading.current_thread().dbname = db_name
                
    ......
    
    @classmethod
    def new(cls, db_name, force_demo=False, status=None, update_module=False):
        ...
        registry = object.__new__(cls)
        registry.init(db_name)
        cls.delete(db_name)
        cls.registries[db_name] = registry
        ...
        odoo.modules.load_modules(registry._db, force_demo, status, update_module)
        ...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从模块中获取模型&lt;code&gt;load&lt;/code&gt;&lt;br /&gt;
从模块中，获取所有的模型类，然后调用&lt;code&gt;_build_model&lt;/code&gt;来完善这个类，完善后的模型类也保存到了模型类的基类中，又一次完成了自产自销。然后返回模块中所有的模型名字。模型的名字就是模型类中的&lt;code&gt;_name&lt;/code&gt;属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def load(self, cr, module):
    model_names = []
    for cls in models.MetaModel.module_to_models.get(module.name, []):
        # models register themselves in self.models
        model = cls._build_model(self, cr)
        model_names.append(model._name)

    return self.descendants(model_names, &#39;_inherit&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意&lt;code&gt;_build_model&lt;/code&gt;函数，它是所有模型的基类&lt;code&gt;odoo.models.BaseModel&lt;/code&gt;中的函数。其中&lt;code&gt;self&lt;/code&gt;参数对应下边的&lt;code&gt;pool&lt;/code&gt;参数。所以&lt;code&gt;model&lt;/code&gt;会在&lt;code&gt;_build_model&lt;/code&gt;的时候保存到&lt;code&gt;registry&lt;/code&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@classmethod
def _build_model(cls, pool, cr):
    ...
    ModelClass.pool = pool
    pool[name] = ModelClass
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模型安装&lt;code&gt;setup_models&lt;/code&gt;&lt;br /&gt;
根据配置信息、继承信息等从基类中创建新的模型类。通过对&lt;code&gt;model&lt;/code&gt;的学习下边几个&lt;code&gt;model&lt;/code&gt;的函数的功能是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_build_model&lt;/code&gt; 根据模型的信息，创建新的模型类，新的模型类会放在&lt;code&gt;registry&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_prepare_setup&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_setup_base&lt;/code&gt; 安装基础属性，如主键&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_setup_fields&lt;/code&gt; 安装各个字段&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_setup_complete&lt;/code&gt; 安装&lt;code&gt;trigger&lt;/code&gt;之类的东西，完成安装
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;cr.execute(&#39;SELECT * FROM ir_model WHERE state=%s&#39;, (&#39;manual&#39;,))
for model_data in cr.dictfetchall():
    model_class = ir_model._instanciate(model_data)
    model_class._build_model(self, cr)
    
models = env.values()
for model in models:
    model._prepare_setup()
        
for model in models:
    model._setup_base(partial)
        
for model in models:
    model._setup_fields(partial)
        
for model in models:
    model._setup_complete()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模型初始化&lt;code&gt;init_models&lt;/code&gt;&lt;br /&gt;
将完善后的模型信息，保存到数据库&lt;code&gt;ir_model&lt;/code&gt;、&lt;code&gt;ir_model_data&lt;/code&gt;、&lt;code&gt;ir_model_field&lt;/code&gt;等字段里。并根据模型建表、建索引、建关联约束。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;model._auto_init()  // 基类中已实现，用来保存信息、建表的。
model.init()        // 子类中实现，用来建新表，或者修改表
model._auto_end()   // _auto_init 执行完后，建立表间的外键约束。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;模块的依赖关系-odoo-modules-graph-graph&#34;&gt;模块的依赖关系 odoo.modules.graph.Graph&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;odoo&lt;/code&gt;的模块之间可以互相调用，那么就存在一定的依赖关系。这些依赖关系都保存在&lt;code&gt;__manifest__.py&lt;/code&gt;中。这个模块就是通过数据库、&lt;code&gt;__manifest__.py&lt;/code&gt;文件，将模块之间的依赖关系转化为一颗树状图来存储（希望这样表述没有错）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每个模块都是一个节点&lt;/li&gt;
&lt;li&gt;依赖模块是当前节点的子节点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下是加载过程中生成的一部分树结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;base
`-&amp;gt; auth_crypt
`-&amp;gt; web
   `-&amp;gt; web_calendar
   `-&amp;gt; web_diagram
   `-&amp;gt; web_editor
   `-&amp;gt; web_kanban
      `-&amp;gt; base_import
      `-&amp;gt; wb_kanban_gauge
   `-&amp;gt; web_planner
      `-&amp;gt; web_settings_dashboard
   `-&amp;gt; web_tour
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;模块的加载-odoo-modules-loading-load-modules&#34;&gt;模块的加载 odoo.modules.loading.load_modules&lt;/h3&gt;

&lt;p&gt;定义了如何导入模块&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;处理模块的查找路径&lt;br /&gt;
调用&lt;code&gt;odoo.modules.module.initialize_sys_path&lt;/code&gt;函数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;根据配置、系统安装路径等获取所有的插件安装路径&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;sys.meta_path.append&lt;/code&gt;定制插件导入方式（主要目的是让odoo和openerp的插件能互相支持）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;检查数据库是否创建&lt;br /&gt;
调用&lt;code&gt;odoo.modules.db&lt;/code&gt;下的函数，检查初始化数据库。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用建库脚本&lt;code&gt;odoo/addons/base/base.sql&lt;/code&gt;创建表&lt;/li&gt;
&lt;li&gt;将模块信息写入表&lt;code&gt;ir_module_module&lt;/code&gt;、&lt;code&gt;ir_model_data&lt;/code&gt;、&lt;code&gt;ir_module_category&lt;/code&gt;等表。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建一个&lt;code&gt;registry&lt;/code&gt;对象
由于&lt;code&gt;registry&lt;/code&gt;自产自销的特点，所以并不是一定要将&lt;code&gt;registry&lt;/code&gt;对象返回。之后会使用这个&lt;code&gt;registry&lt;/code&gt;对象进行模块的安装操作。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取运行环境&lt;br /&gt;
&lt;code&gt;env = api.Environment(cr, SUPERUSER_ID, {})&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Enviroment&lt;/code&gt;模拟了一个字典。和Registry类似，也是一个自产自销的类。第一次创建好对象后，会放在类的属性中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Environment(Mapping):
    _local = Local()

    @classproperty
    def envs(cls):
        return cls._local.environments
    
    ...
        
    def __new__(cls, cr, uid, context):
        ...
        envs.add(self)
...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导入base模块&lt;br /&gt;
&lt;code&gt;base&lt;/code&gt;模块提供了odoo的最基础功能。在该模块的&lt;code&gt;__manifest__.py&lt;/code&gt;中对自己的描述是&lt;code&gt;The kernel of Odoo, needed for all installation.&lt;/code&gt;，可见它的重要性。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建依赖管理器&lt;code&gt;odoo.modules.graph.Graph&lt;/code&gt;，并将&lt;code&gt;base&lt;/code&gt;加入其它&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  graph = odoo.modules.graph.Graph()
  graph.add_module(cr, &#39;base&#39;, force)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;加载&lt;code&gt;base&lt;/code&gt;模块。注意这里是通过&lt;code&gt;graph&lt;/code&gt;进行的加载。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  loaded_modules, processed_modules = load_module_graph(cr, graph, status, perform_checks=update_module, report=report)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;load_module_graph&lt;/code&gt;函数中进行如下操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;遍历graph中所有的模块，抽取模块中的模型，从模型的基类中，创建新的模型类。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  model_names = registry.load(cr, package)
  registry.setup_models(cr, partial=True)
  registry.init_models(cr, model_names, {&#39;module&#39;: package.name})
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据需要安装视图、demo等&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  if hasattr(package, &#39;init&#39;) or hasattr(package, &#39;update&#39;) or package.state in (&#39;to install&#39;, &#39;to upgrade&#39;):
  ...
      _load_data(cr, module_name, idref, mode, kind=&#39;data&#39;)
      ...
      env[&#39;ir.ui.view&#39;]._validate_module_views(module_name)
      ...
  ...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后在&lt;code&gt;registry&lt;/code&gt;中安装&lt;code&gt;base&lt;/code&gt;里的模型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  registry.setup_models(cr, partial=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;标记其它需要加载或更新的模块&lt;br /&gt;
如果有需要更新的模块，进行标注。这里的标注貌似只是在模块的按钮上显示安装、更新按钮。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导入标记过的模块&lt;br /&gt;
安装除base以外的模块。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从数据库中查询特定状态的模块，例如：&lt;code&gt;installed&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将它们放入graph中，通过graph导入
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;结束安装并进行清理&lt;br /&gt;
从数据库查询所有应该导入的模块，检查它们的状态，执行相应的清理。因为有些模块在安装过程中，可能会导入一些测试数据进行单元测试，安装完成以后这些东西应该被清理。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;卸载标记删除的模块
从数据库中查询所有标记为要删除的模块。从graph中获取所有的依赖，然后从中查找&lt;code&gt;uninstall_hook&lt;/code&gt;函数，利用&lt;code&gt;getattr&lt;/code&gt;来调用这些函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pkgs = reversed([p for p in graph if p.name in modules_to_remove])
for pkg in pkgs:
    uninstall_hook = pkg.info.get(&#39;uninstall_hook&#39;)
    if uninstall_hook:
        py_module = sys.modules[&#39;odoo.addons.%s&#39; % (pkg.name,)]
        getattr(py_module, uninstall_hook)(cr, registry)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;检查所有模型的视图&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;View._validate_custom_views(model)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;研究视图的时候再研究这个函数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用每个模块的&lt;code&gt;_register_hook&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for model in env.values():
    model._register_hook()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;研究模块、模型的时候再详细研究这个&lt;code&gt;hook&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;执行&lt;code&gt;post-install&lt;/code&gt;
从数据库中查询所有的模块，然后逐个进行单元测试&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;模块的加载-odoo-modules-loading-load-module-graph&#34;&gt;模块的加载 odoo.modules.loading.load_module_graph&lt;/h3&gt;

&lt;p&gt;按照模块之间的依赖关系导入模块。这个是最终将模块、模型、模型数据导入到registry中的函数。其中内部定义的函数&lt;code&gt;_load_data&lt;/code&gt;，负责将&lt;code&gt;__manifest__.py&lt;/code&gt;中的数据文件保存到数据库中。具体负责读取不同格式的数据文件的函数是&lt;code&gt;odoo.tools.convert.convert_file&lt;/code&gt;。
它会根据不同类型的文件类型使用不同的方法解析数据文件，并将数据保存到自己的模型表中，然后保存到&lt;code&gt;ir_model_data&lt;/code&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def load_module_graph(cr, graph, status=None, perform_checks=True, skip_modules=None, report=None):
    ...
    def _load_data(cr, module_name, idref, mode, kind):
        ...
        for filename in _get_files_of_kind(kind):
            ...
            tools.convert_file(cr, module_name, filename, idref, mode, noupdate, kind, report)
            ...
    ...
    processed_modules = []
    loaded_modules = []
    registry = odoo.registry(cr.dbname)
    ...
    for index, package in enumerate(graph, 1):
        load_openerp_module(package.name)
        ...
        model_names = registry.load(cr, package)
        ...
        if hasattr(package, &#39;init&#39;) or hasattr(package, &#39;update&#39;) or package.state in (&#39;to install&#39;, &#39;to upgrade&#39;):
            registry.setup_models(cr, partial=True)
            registry.init_models(cr, model_names, {&#39;module&#39;: package.name})
            ...
            _load_data(cr, module_name, idref, mode, kind=&#39;data&#39;)
            ...
            registry._init_modules.add(package.name)
        ...
    ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tools.convert_file&lt;/code&gt;中以及&lt;code&gt;ir.model&lt;/code&gt;中的代码片段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class xml_import(object):
    ...
    def _tag_template(self, el, data_node=None, mode=None):
        ...
        record_attrs = {
            &#39;id&#39;: tpl_id,
            &#39;model&#39;: &#39;ir.ui.view&#39;,
        }
        ...
        record = etree.Element(&#39;record&#39;, attrib=record_attrs)
        ...
        return self._tag_record(record, data_node)
    
    def _tag_record(self, rec, data_node=None, mode=None):
        ...
        id = self.env(context=rec_context)[&#39;ir.model.data&#39;]._update(rec_model, self.module, res, rec_id or False, not self.isnoupdate(data_node), noupdate=self.isnoupdate(data_node), mode=self.mode)
        ...
        return rec_model, id
        
...

class IrModelData(models.Model):
    ...
    @api.model
    def _update(self, model, module, values, xml_id=False, store=True, noupdate=False, mode=&#39;init&#39;, res_id=False):
        record = self.env[model].browse(res_id)
        ...
        record = record.create(values)
        ...
        self.sudo().create(...)
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;record.create&lt;/code&gt;将数据写入模型自己的表中，&lt;code&gt;sudo().create&lt;/code&gt;将数据写入&lt;code&gt;ir.model.data&lt;/code&gt;中。&lt;/p&gt;

&lt;h3 id=&#34;不算总结的总结&#34;&gt;不算总结的总结&lt;/h3&gt;

&lt;p&gt;通过学习这部分的代码，可以发现模块的加载、更新、删除等操作，都有数据库的深度参与。模块的物理信息会存放在&lt;code&gt;ir_module_module&lt;/code&gt;等表中。从模块中抽取出来的逻辑信息则会存放在&lt;code&gt;ir_model&lt;/code&gt;等表中。对模块的操作需要反复的遍历、修改这些表。&lt;strong&gt;所以在使用过程中，数据库的安全、稳定是头等大事&lt;/strong&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>odoo的web server</title>
      <link>https://asdfsx.github.io/post/odoo/odoo%E7%9A%84web%20server/</link>
      <pubDate>Sat, 24 Dec 2016 20:47:02 +0800</pubDate>
      
      <guid>https://asdfsx.github.io/post/odoo/odoo%E7%9A%84web%20server/</guid>
      <description>

&lt;p&gt;odoo的web服务器实现都在一个包里odoo.service.server。为了提升服务器的性能，提供了3种不同的web服务器，分别使用了thread、gevent、process。而在web服务器里，odoo使用werkzeug这套wsgi库，实现端口监听、请求处理等。&lt;/p&gt;

&lt;h3 id=&#34;服务器的启动&#34;&gt;服务器的启动&lt;/h3&gt;

&lt;p&gt;在&lt;code&gt;odoo.service.server&lt;/code&gt;包中，入口函数是位于文件末尾的&lt;code&gt;start&lt;/code&gt;函数，它的行为如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义全局变量server&lt;/li&gt;
&lt;li&gt;加载所谓的&lt;code&gt;server wide module&lt;/code&gt;（默认的全局模块只有&lt;code&gt;web&lt;/code&gt;，&lt;code&gt;web_kanban&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;根据配置创建不同的server&lt;/li&gt;
&lt;li&gt;创建文件监视（为了实现模块的动态加载）&lt;/li&gt;
&lt;li&gt;启动server&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从中可以看到具体处理请求的程序是&lt;code&gt;odoo.service.wsgi_server.application&lt;/code&gt;，而默认的&lt;code&gt;server&lt;/code&gt;是基于线程的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def start(preload=None, stop=False):
    &amp;quot;&amp;quot;&amp;quot; Start the odoo http server and cron processor.
    &amp;quot;&amp;quot;&amp;quot;
    global server
    load_server_wide_modules()
    if odoo.evented:
        server = GeventServer(odoo.service.wsgi_server.application)
    elif config[&#39;workers&#39;]:
        server = PreforkServer(odoo.service.wsgi_server.application)
    else:
        server = ThreadedServer(odoo.service.wsgi_server.application)

    watcher = None
    if &#39;reload&#39; in config[&#39;dev_mode&#39;]:
        if watchdog:
            watcher = FSWatcher()
            watcher.start()
        else:
            _logger.warning(&amp;quot;&#39;watchdog&#39; module not installed. Code autoreload feature is disabled&amp;quot;)
    if &#39;werkzeug&#39; in config[&#39;dev_mode&#39;]:
        server.app = DebuggedApplication(server.app, evalex=True)

    rc = server.run(preload, stop)

    # like the legend of the phoenix, all ends with beginnings
    if getattr(odoo, &#39;phoenix&#39;, False):
        if watcher:
            watcher.stop()
        _reexec()

    return rc if rc else 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基类-odoo-service-server-commonserver&#34;&gt;基类 odoo.service.server.CommonServer&lt;/h3&gt;

&lt;p&gt;作为鸡肋，啥也没有，只有一个关闭socket的函数&lt;/p&gt;

&lt;h3 id=&#34;基于线程的实现-odoo-service-server-threadedserver&#34;&gt;基于线程的实现 odoo.service.server.ThreadedServer&lt;/h3&gt;

&lt;p&gt;实现了父类的&lt;code&gt;run&lt;/code&gt;函数，作为程序的入口吧。&lt;/p&gt;

&lt;p&gt;启动过程中会创建两种线程&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;处理http请求的线程&lt;br /&gt;
用&lt;code&gt;odoo.service.server.ThreadedWSGIServerReloadable&lt;/code&gt;来实现线程。这个类继承了&lt;code&gt;werkzeug.serving.ThreadedWSGIServer&lt;/code&gt;，所以具体如何使用线程来完成请求的处理，都被隐藏在&lt;code&gt;werkzeug&lt;/code&gt;中了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;处理定时任务的线程&lt;br /&gt;
在&lt;code&gt;cron_spawn&lt;/code&gt;函数中创建的，按照配置中的&lt;code&gt;max_cron_threads&lt;/code&gt;来创建&lt;code&gt;daemon&lt;/code&gt;线程。线程中通过遍历&lt;code&gt;odoo.modules.registry.Registry.registries&lt;/code&gt;来获得数据库信息，然后通过&lt;code&gt;odoo.addons.base.ir.ir_cron.ir_cron._acquire_job&lt;/code&gt;来获取定时任务。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;基于gevent的实现-odoo-service-server-geventserver&#34;&gt;基于gevent的实现 odoo.service.server.GeventServer&lt;/h3&gt;

&lt;p&gt;gevent是一个基于协程的网络库。底层使用greenlet作为轻量级的异步并法方式，使用libev实现基于事件循环的网络请求处理。&lt;/p&gt;

&lt;p&gt;GeventServer实现非常简单，感觉和Thread、Process的方案比，感觉缺了些东西。（比如进程、线程版里都会有cron_xxx，目测应该是执行定时任务的程序。）&lt;/p&gt;

&lt;h3 id=&#34;基于进程的实现-odoo-service-server-preforkserver&#34;&gt;基于进程的实现 odoo.service.server.PreforkServer&lt;/h3&gt;

&lt;p&gt;让人又爱又恨的进程。与上边的两个实现相比，进程要靠自己一点点实现&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;PreforkServer&lt;br /&gt;
启动函数为&lt;code&gt;run&lt;/code&gt;，这个函数中也定义了主进程的行为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;建立管道、处理信号；建立socket&lt;/li&gt;
&lt;li&gt;处理信号&lt;/li&gt;
&lt;li&gt;处理僵尸进程&lt;/li&gt;
&lt;li&gt;处理超时连接&lt;/li&gt;
&lt;li&gt;创建子进程&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其余的函数都是为了上述功能&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Worker&lt;br /&gt;
子进程的父类，定义了子进程的大部分行为。包括信号的处理、进程状态的处理。具体的业务放在&lt;code&gt;process_work&lt;/code&gt;函数中，当然父类不需要实现这个函数，具体业务逻辑放在子类中实现。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;WorkerHTTP&lt;br /&gt;
处理http请求的子进程。启动子进程的时候，会定义一个处理http请求的&lt;code&gt;self.server&lt;/code&gt;，类型是&lt;code&gt;BaseWSGIServerNoBind&lt;/code&gt;。从类的定义上可以看出来它继承了&lt;code&gt;werkzeug.serving.BaseWSGIServer&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;WorkerCron&lt;br /&gt;
处理定时任务的子进程。执行完任务后退出。（这里和线程的实现不一样。线程里是死循环；进程则是执行完就退出，然后由主进程再次拉起？？？待确认啊～～）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;预加载模型-preload-registries&#34;&gt;预加载模型 preload_registries&lt;/h3&gt;

&lt;p&gt;在之后的文章中，我们可以看到&lt;code&gt;registry&lt;/code&gt;的重要性。在这里我们只需要明确，不管是进程、还是线程的实现，都会在启动服务器时调用这个函数创建&lt;code&gt;registry&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def preload_registries(dbnames):
    &amp;quot;&amp;quot;&amp;quot; Preload a registries, possibly run a test file.&amp;quot;&amp;quot;&amp;quot;
    # TODO: move all config checks to args dont check tools.config here
    config = odoo.tools.config
    test_file = config[&#39;test_file&#39;]
    dbnames = dbnames or []
    rc = 0
    for dbname in dbnames:
        try:
            update_module = config[&#39;init&#39;] or config[&#39;update&#39;]
            registry = Registry.new(dbname, update_module=update_module)
            # run test_file if provided
            if test_file:
                _logger.info(&#39;loading test file %s&#39;, test_file)
                with odoo.api.Environment.manage():
                    if test_file.endswith(&#39;yml&#39;):
                        load_test_file_yml(registry, test_file)
                    elif test_file.endswith(&#39;py&#39;):
                        load_test_file_py(registry, test_file)

            if registry._assertion_report.failures:
                rc += 1
        except Exception:
            _logger.critical(&#39;Failed to initialize database `%s`.&#39;, dbname, exc_info=True)
            return -1
    return rc
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文件系统监视器-fswatcher&#34;&gt;文件系统监视器 FSWatcher&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;watchdog&lt;/code&gt;监视指定目录中发生的文件创建、删除、修改事件。主要是为了模块的动态更新。&lt;/p&gt;

&lt;h3 id=&#34;处理请求的-wsgi-server&#34;&gt;处理请求的 wsgi_server&lt;/h3&gt;

&lt;p&gt;之前说的3种server，都使用了&lt;code&gt;odoo.service.wsgi_server.application&lt;/code&gt;来处理请求。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def wsgi_xmlrpc(environ, start_response):
    ...
    if environ[&#39;REQUEST_METHOD&#39;] == &#39;POST&#39; and environ[&#39;PATH_INFO&#39;].startswith(&#39;/xmlrpc/&#39;):
    ...
    
    
def application_unproxied(environ, start_response):
    ...
    with odoo.api.Environment.manage():
        # Try all handlers until one returns some result (i.e. not None).
        for handler in [wsgi_xmlrpc, odoo.http.root]:
            result = handler(environ, start_response)
            if result is None:
                continue
            return result
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的请求都会尝试用2个handler来处理一下。&lt;code&gt;wsgi_xmlrpc&lt;/code&gt;用来处理xmlrpc，只有&lt;code&gt;POST&lt;/code&gt;类型的、url以&lt;code&gt;/xmlrpc/&lt;/code&gt;开头的会被这个handler处理。其余的都由&lt;code&gt;odoo.http.root&lt;/code&gt;来处理。看来&lt;code&gt;odoo.http.root&lt;/code&gt;应该超级复杂。&lt;/p&gt;

&lt;h3 id=&#34;超级长的-odoo-http&#34;&gt;超级长的 odoo.http&lt;/h3&gt;

&lt;p&gt;这是一个1651行的，历史悠久的python文件。第一行&lt;code&gt;# -*- coding: utf-8 -*-&lt;/code&gt;是2013年2月1日写下的。里边集中了请求的封装、模块加载、session管理等东西。这里我们重点先看&lt;code&gt;root&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;首先，在文件的末尾找到&lt;code&gt;root = Root()&lt;/code&gt;。&lt;code&gt;root&lt;/code&gt;是一个&lt;code&gt;Root&lt;/code&gt;的对象。哪一个对象怎么作为&lt;code&gt;handler&lt;/code&gt;作为函数调用的呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Root(object):
    ...
    def __call__(self, environ, start_response):
        if not self._loaded:
            self._loaded = True
            self.load_addons()
        return self.dispatch(environ, start_response)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原来是特殊的的&lt;code&gt;__call__&lt;/code&gt;函数。而且可以看到模块是延迟加载的：只有在第一次被调用的时候才会&lt;code&gt;load_addons&lt;/code&gt;。然后才会调用&lt;code&gt;dispatch&lt;/code&gt;去处理请求。&lt;/p&gt;

&lt;h5 id=&#34;加载模块-load-addons&#34;&gt;加载模块 load_addons&lt;/h5&gt;

&lt;p&gt;加载模块的步骤&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从&lt;code&gt;odoo.modules.module.ad_paths&lt;/code&gt;下的所有目录里，获取所有的模块目录。&lt;/li&gt;
&lt;li&gt;从各个目录里，查找模块的&lt;code&gt;__manifest__.py&lt;/code&gt;文件（模块的描述文件）。&lt;/li&gt;
&lt;li&gt;读取模块信息，然后&lt;code&gt;__import__&lt;/code&gt;模块。&lt;/li&gt;
&lt;li&gt;将模块、模块信息存到全局变量&lt;code&gt;addons_module, addons_manifest&lt;/code&gt;中，同时将模块的静态文件地址也保存起来。&lt;/li&gt;
&lt;li&gt;创建用来处理请求的dispatch&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特别注意在最后，&lt;code&gt;dispatch&lt;/code&gt;函数被特殊处理了一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app = werkzeug.wsgi.SharedDataMiddleware(self.dispatch, statics, cache_timeout=STATIC_CACHE)
        self.dispatch = DisableCacheMiddleware(app)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里先用类中的&lt;code&gt;dispatch&lt;/code&gt;函数，生成&lt;code&gt;werkzeug.wsgi.SharedDataMiddleware&lt;/code&gt;的对象&lt;code&gt;app&lt;/code&gt;；然后再用&lt;code&gt;app&lt;/code&gt;生成一个&lt;code&gt;DisableCacheMiddleware&lt;/code&gt;对象，替换掉原来的&lt;code&gt;dispatch&lt;/code&gt;&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;h5 id=&#34;抽丝剥茧-dispatch&#34;&gt;抽丝剥茧 dispatch&lt;/h5&gt;

&lt;p&gt;在&lt;code&gt;load_addons&lt;/code&gt;的最后，原先的&lt;code&gt;dispatch&lt;/code&gt;函数被层层包裹（真的是两层）。
最外边一层是&lt;code&gt;DisableCacheMiddleware&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class DisableCacheMiddleware(object):
    def __init__(self, app):
        self.app = app
    def __call__(self, environ, start_response):
        def start_wrapped(status, headers):
            referer = environ.get(&#39;HTTP_REFERER&#39;, &#39;&#39;)
            parsed = urlparse.urlparse(referer)
            debug = parsed.query.count(&#39;debug&#39;) &amp;gt;= 1

            new_headers = []
            unwanted_keys = [&#39;Last-Modified&#39;]
            if debug:
                new_headers = [(&#39;Cache-Control&#39;, &#39;no-cache&#39;)]
                unwanted_keys += [&#39;Expires&#39;, &#39;Etag&#39;, &#39;Cache-Control&#39;]

            for k, v in headers:
                if k not in unwanted_keys:
                    new_headers.append((k, v))

            start_response(status, new_headers)
        return self.app(environ, start_wrapped)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码不多直接贴。不出意外的使用了&lt;code&gt;__call__&lt;/code&gt;，然后可以看到它主要是对返回的&lt;code&gt;http头&lt;/code&gt;做了特殊的处理。&lt;/p&gt;

&lt;p&gt;接下来是一层&lt;code&gt;werkzeug.wsgi.SharedDataMiddleware&lt;/code&gt;，借用官方文档：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A WSGI middleware that provides static content for development environments or simple server setups.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它是用来安装模块对应的静态文件。&lt;/p&gt;

&lt;p&gt;最后就是&lt;code&gt;dispatch&lt;/code&gt;函数了。先对请求进行处理：设置session、设置数据库、设置语言；然后交给&lt;code&gt;ir_http._dispatch&lt;/code&gt;来处理请求；&lt;code&gt;get_response&lt;/code&gt;将前一步的结果进行处理，生成最终返回的&lt;code&gt;response&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def dispatch(self, environ, start_response):
    ...
    httprequest = werkzeug.wrappers.Request(environ)
    ...
    explicit_session = self.setup_session(httprequest)
    self.setup_db(httprequest)
    self.setup_lang(httprequest)
    request = self.get_request(httprequest)
    ...
    with request:
        ...
        with odoo.tools.mute_logger(&#39;odoo.sql_db&#39;):
            ir_http = request.registry[&#39;ir.http&#39;]
        ...
        result = ir_http._dispatch()
        ...
        response = self.get_response(httprequest, result, explicit_session)
    return repsonse
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是&lt;code&gt;registry&lt;/code&gt;从何而来，&lt;code&gt;ir_http&lt;/code&gt;又是什么。继续探索下去吧。&lt;/p&gt;

&lt;h5 id=&#34;请求的包装&#34;&gt;请求的包装&lt;/h5&gt;

&lt;p&gt;最初的请求时由&lt;code&gt;werkzeug.wrappers.Request&lt;/code&gt;生成的。然后经过一步步的设置，将它的session信息、可能访问的数据库连接、使用的语言，都配置存放到请求对象中。然后根据请求的类型，生成&lt;code&gt;JsonRequest&lt;/code&gt;或者&lt;code&gt;HttpRequest&lt;/code&gt;。这两个类分别对应&lt;code&gt;Json&lt;/code&gt;请求和一般的&lt;code&gt;Http&lt;/code&gt;请求，他们的父类都是&lt;code&gt;WebRequest&lt;/code&gt;。在他们的父类中，我们看到了神秘的&lt;code&gt;registry&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@property
def registry(self):
    &amp;quot;&amp;quot;&amp;quot;
    The registry to the database linked to this request. Can be ``None``
    if the current request uses the ``none`` authentication.
    .. deprecated:: 8.0
        use :attr:`.env`
    &amp;quot;&amp;quot;&amp;quot;
    return odoo.registry(self.db) if self.db else None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用了&lt;code&gt;@property&lt;/code&gt;使这个函数可以当作类的属性访问。&lt;code&gt;odoo.registry&lt;/code&gt;这个函数可以在&lt;code&gt;odoo/__init__.py&lt;/code&gt;中找到，返回一个Registry对象。初步判断这里时做了一个初始化工作：创建Registry对象，成功的话返回数据库名称，失败返回None。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def registry(database_name=None):
    &amp;quot;&amp;quot;&amp;quot;
    Return the model registry for the given database, or the database mentioned
    on the current thread. If the registry does not exist yet, it is created on
    the fly.
    &amp;quot;&amp;quot;&amp;quot;
    if database_name is None:
        import threading
        database_name = threading.currentThread().dbname
    return modules.registry.Registry(database_name)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;模型的注册表-registry&#34;&gt;模型的注册表 Registry&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;The registry is essentially a mapping between model names and model classes.
There is one registry instance per database.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;官方文档对&lt;code&gt;Registry&lt;/code&gt;的说明。&lt;/p&gt;

&lt;p&gt;在请求处理的过程中，如果&lt;code&gt;modules.registry.Registry&lt;/code&gt;还没有实例，那么就创建一个。这个是一个继承了&lt;code&gt;collections.Mapping&lt;/code&gt;，高度定制化的类。在这个类中，创建了一个类的属性&lt;code&gt;registries&lt;/code&gt;作为缓存来存放之后生成的&lt;code&gt;registry&lt;/code&gt;。每次想获取&lt;code&gt;registry&lt;/code&gt;对象的时候，都是先查询这个缓存。如果缓存中有现成的对象，直接返回，否则生成新的对象。&lt;/p&gt;

&lt;p&gt;在创建registry的同时，还进行了模块的实例化：从模块中抽取模型、把模型保存到数据库、将模型的实例存到registry中。&lt;/p&gt;

&lt;h5 id=&#34;请求的重定向&#34;&gt;请求的重定向&lt;/h5&gt;

&lt;p&gt;通过对模块、以及&lt;code&gt;registry&lt;/code&gt;的了解，我们可以继续探究之前的&lt;code&gt;ir_http&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ir_http = request.registry[&#39;ir.http&#39;]
result = ir_http._dispatch()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从&lt;code&gt;registrty&lt;/code&gt;中查找名字为&lt;code&gt;ir.http&lt;/code&gt;的模型的对象。通过搜索我们找到这个名字对应的类是：&lt;code&gt;odoo.addons.base.ir.ir_http.IrHttp&lt;/code&gt;，在这个类中，我们找到了这个&lt;code&gt;_dispatch&lt;/code&gt;方法。可以看到它在初次执行时会将安装好的模块都加载到&lt;code&gt;odoo.http.routing_map&lt;/code&gt;中。之后当请求到达的时候，从&lt;code&gt;routing_map&lt;/code&gt;中获得&lt;code&gt;controller&lt;/code&gt;，然后由controller来处理请求。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @classmethod
    def routing_map(cls):
        if not hasattr(cls, &#39;_routing_map&#39;):
            installed = request.registry._init_modules - {&#39;web&#39;}
            mods = [&#39;&#39;] + odoo.conf.server_wide_modules + sorted(installed)
            cls._routing_map = http.routing_map(mods, False, converters=cls._get_converters())
        return cls._routing_map
        
    @classmethod
    def _find_handler(cls, return_rule=False):
        return cls.routing_map().bind_to_environ(request.httprequest.environ).match(return_rule=return_rule)

    @classmethod
    def _dispatch(cls):
        # locate the controller method
        try:
            rule, arguments = cls._find_handler(return_rule=True)
            func = rule.endpoint
        except werkzeug.exceptions.NotFound, e:
            return cls._handle_exception(e)
            
        ......
        
        try:
            request.set_handler(func, arguments, auth_method)
            result = request.dispatch()
        except Exception, e:
            return cls._handle_exception(e)
        return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;创建请求的路由器-odoo-http-routing-map&#34;&gt;创建请求的路由器 odoo.http.routing_map&lt;/h5&gt;

&lt;p&gt;请求的路由信息是保存在&lt;code&gt;werkzeug.routing.Map&lt;/code&gt;中的。而&lt;code&gt;routing_map&lt;/code&gt;函数负责创建这个对象，然后通过遍历所有已安装的模块中的&lt;code&gt;controller&lt;/code&gt;，将所有的路径信息都存放到这个对象中去。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def routing_map(modules, nodb_only, converters=None):
    routing_map = werkzeug.routing.Map(strict_slashes=False, converters=converters)
    ......
    for module in modules:
        for _, cls in controllers_per_module[module]:
            o = cls()
            members = inspect.getmembers(o, inspect.ismethod)
            for _, mv in members:
                ...
                endpoint = EndPoint(mv, routing)
                ...
                routing_map.add(werkzeug.routing.Rule(url, endpoint=endpoint, methods=routing[&#39;methods&#39;], **kw))
    return routing_map
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;附一个&lt;code&gt;werkzeug.routing.Map&lt;/code&gt;的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from werkzeug.routing import Map, Rule, NotFound, RequestRedirect

url_map = Map([
    Rule(&#39;/&#39;, endpoint=&#39;blog/index&#39;),
    Rule(&#39;/&amp;lt;int:year&amp;gt;/&#39;, endpoint=&#39;blog/archive&#39;),
    Rule(&#39;/&amp;lt;int:year&amp;gt;/&amp;lt;int:month&amp;gt;/&#39;, endpoint=&#39;blog/archive&#39;),
    Rule(&#39;/&amp;lt;int:year&amp;gt;/&amp;lt;int:month&amp;gt;/&amp;lt;int:day&amp;gt;/&#39;, endpoint=&#39;blog/archive&#39;),
    Rule(&#39;/&amp;lt;int:year&amp;gt;/&amp;lt;int:month&amp;gt;/&amp;lt;int:day&amp;gt;/&amp;lt;slug&amp;gt;&#39;,
         endpoint=&#39;blog/show_post&#39;),
    Rule(&#39;/about&#39;, endpoint=&#39;blog/about_me&#39;),
    Rule(&#39;/feeds/&#39;, endpoint=&#39;blog/feeds&#39;),
    Rule(&#39;/feeds/&amp;lt;feed_name&amp;gt;.rss&#39;, endpoint=&#39;blog/show_feed&#39;)
])

def application(environ, start_response):
    urls = url_map.bind_to_environ(environ)
    try:
        endpoint, args = urls.match()
    except HTTPException, e:
        return e(environ, start_response)
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/plain&#39;)])
    return [&#39;Rule points to %r with arguments %r&#39; % (endpoint, args)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此我们终于可以将收到的请求，转发到对应的&lt;code&gt;controller&lt;/code&gt;中了。&lt;/p&gt;

&lt;h5 id=&#34;session-管理&#34;&gt;Session 管理&lt;/h5&gt;

&lt;p&gt;在http访问的过程中，session的管理是很重要的。目前在&lt;code&gt;odoo&lt;/code&gt;中，使用了基于&lt;code&gt;werkzeug&lt;/code&gt;的session实现。其中&lt;code&gt;session&lt;/code&gt;的存储使用的是文件存储。不得不说这个对&lt;code&gt;odoo&lt;/code&gt;的高可用是一个小小的障碍。不过现在已经有现成的模块可以将这个基于文件的&lt;code&gt;sessionstore&lt;/code&gt;替换成&lt;code&gt;redisstore&lt;/code&gt;。基本思路就是继承&lt;code&gt;odoo.http.Root&lt;/code&gt;，用一个支持&lt;code&gt;redis&lt;/code&gt;的&lt;code&gt;session_store&lt;/code&gt;函数将原有的函数覆盖掉。&lt;/p&gt;

&lt;p&gt;项目地址：&lt;a href=&#34;https://github.com/keerati/odoo-redis&#34;&gt;https://github.com/keerati/odoo-redis&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class OpenERPSession(werkzeug.contrib.sessions.Session):
    def __init__(self, *args, **kwargs):
    ......
    
class Root(object):
    ......
    @lazy_property
    def session_store(self):
        # Setup http sessions
        path = odoo.tools.config.session_dir
        _logger.debug(&#39;HTTP sessions stored in: %s&#39;, path)
        return werkzeug.contrib.sessions.FilesystemSessionStore(path, session_class=OpenERPSession)
        
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;不算总结的总结&#34;&gt;不算总结的总结&lt;/h3&gt;

&lt;p&gt;经过不断的补充，终于将web server弄完了。现在算是基本弄清了&lt;code&gt;odoo&lt;/code&gt;的启动流程，模块是如何加载安装的，请求是如何被处理的。关于&lt;code&gt;registry&lt;/code&gt;、&lt;code&gt;module&lt;/code&gt;、&lt;code&gt;model&lt;/code&gt;、&lt;code&gt;controller&lt;/code&gt;等会单独开篇去详细研究。&lt;/p&gt;

&lt;p&gt;注意：&lt;br /&gt;
文中大部分的&lt;code&gt;模块加载&lt;/code&gt;仅指&lt;code&gt;import&lt;/code&gt;。&lt;br /&gt;
真正将其实例化，或者说从模块类 -&amp;gt; 模型／模块类实例，是在&lt;code&gt;registry&lt;/code&gt;中创建的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>odoo的命令</title>
      <link>https://asdfsx.github.io/post/odoo/odoo%E7%9A%84%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sat, 24 Dec 2016 20:37:57 +0800</pubDate>
      
      <guid>https://asdfsx.github.io/post/odoo/odoo%E7%9A%84%E5%91%BD%E4%BB%A4/</guid>
      <description>

&lt;p&gt;Odoo命令都在odoo.cli包中&lt;/p&gt;

&lt;h3 id=&#34;元类-commandtype&#34;&gt;元类：CommandType&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;commands = {}

class CommandType(type):
    def __init__(cls, name, bases, attrs):
        super(CommandType, cls).__init__(name, bases, attrs)
        name = getattr(cls, name, cls.__name__.lower())
        cls.name = name
        if name != &#39;command&#39;:
            commands[name] = cls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有使用了这个元类的类，都会注册到包内的全局字典&lt;code&gt;commands&lt;/code&gt;中：类名为key，类为value&lt;/p&gt;

&lt;h3 id=&#34;所有命令的基类-command&#34;&gt;所有命令的基类：Command&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class Command(object):
    &amp;quot;&amp;quot;&amp;quot;Subclass this class to define new odoo subcommands &amp;quot;&amp;quot;&amp;quot;
    __metaclass__ = CommandType

    def run(self, args):
        pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到基类使用&lt;code&gt;CommandType&lt;/code&gt;作为元类。这意味着所有的子类都会注册到全局字典中。&lt;br /&gt;
同时还定义了个函数&lt;code&gt;run&lt;/code&gt;。这算是预定义了要实现功能的函数。&lt;/p&gt;

&lt;h3 id=&#34;命令的实现&#34;&gt;命令的实现&lt;/h3&gt;

&lt;p&gt;以下命令全部都是&lt;code&gt;Command&lt;/code&gt;的子类，所以都使用了原类&lt;code&gt;CommandType&lt;/code&gt;，并实现了父类的&lt;code&gt;run&lt;/code&gt;函数。&lt;/p&gt;

&lt;h4 id=&#34;odoo-cli-command-help&#34;&gt;odoo.cli.command.Help&lt;/h4&gt;

&lt;p&gt;根据其它命令中的内容，生成帮助信息，并输出。&lt;/p&gt;

&lt;h4 id=&#34;odoo-cli-deploy-deploy&#34;&gt;odoo.cli.deploy.Deploy&lt;/h4&gt;

&lt;p&gt;将本地的一个模块部署到指定的服务器上
需要给定本地模块的地址，和远程服务器地址
会将本地模块压缩成zip，然后通过http登录服务器并上传&lt;/p&gt;

&lt;h4 id=&#34;odoo-cli-scaffold-scaffold&#34;&gt;odoo.cli.scaffold.Scaffold&lt;/h4&gt;

&lt;p&gt;用来生成一个模块的骨架。主要为了方便做二次开发。&lt;/p&gt;

&lt;p&gt;默认使用的模版文件就在odoo.cli包内的template目录里&lt;/p&gt;

&lt;h4 id=&#34;odoo-cli-shell-shell&#34;&gt;odoo.cli.shell.Shell&lt;/h4&gt;

&lt;p&gt;启动odoo，然后使用ipython、ptpython、bpython等创建一个交互环境。可以查询运行中的odoo的一些信息。&lt;/p&gt;

&lt;p&gt;个人认为，这个也是方便开发调试的一个工具&lt;/p&gt;

&lt;h4 id=&#34;odoo-cli-start-start&#34;&gt;odoo.cli.start.Start&lt;/h4&gt;

&lt;p&gt;也是一个方便开发调试的工具，官方文档的说明是&lt;code&gt;为你的项目快速启动odoo&lt;/code&gt;。在启动参数中需要指定项目地址；如果不指定会从当前目录查找。&lt;/p&gt;

&lt;h4 id=&#34;odoo-cli-server-server&#34;&gt;odoo.cli.server.Server&lt;/h4&gt;

&lt;p&gt;最重要的命令，启动odoo服务器。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>入新坑  开源python ERP odoo</title>
      <link>https://asdfsx.github.io/post/odoo/%E5%85%A5%E6%96%B0%E5%9D%91--%E5%BC%80%E6%BA%90python%20ERP%20odoo/</link>
      <pubDate>Thu, 22 Dec 2016 19:37:57 +0800</pubDate>
      
      <guid>https://asdfsx.github.io/post/odoo/%E5%85%A5%E6%96%B0%E5%9D%91--%E5%BC%80%E6%BA%90python%20ERP%20odoo/</guid>
      <description>&lt;p&gt;这篇纯粹吹水&lt;/p&gt;

&lt;p&gt;odoo是一套开源的，由python实现的ERP系统。说是系统，更像是一个平台，甚至可以说是生态系统（就像 appstore）。&lt;/p&gt;

&lt;p&gt;首先，它的功能是通过自由组合的各种插件来实现的。其自带的插件就由已经实现了以下功能：客户管理、财务管理、进销存管理、员工管理、审批流程定制，等等。基本上已经覆盖了大部分的企业需求（可能不一定符合特定用户的特定需求，但是它有）。&lt;/p&gt;

&lt;p&gt;其次，它为开源社区提供了插件交易的一个市场。各种收费的免费的插件通过这个市场共享。大幅度的扩展了它的应用范围。受益于此，获得了大量的插件：有免费的、方便汇率更新的小型功能插件，也有收费的提供酒店管理的定制化插件。&lt;/p&gt;

&lt;p&gt;最后，它还不定时的组织线上线下的活动，来进行进行客户培训、产品推广、技术交流（虽然都在国外）。&lt;/p&gt;

&lt;p&gt;最后的最后，完全开源，方便定制化。&lt;/p&gt;

&lt;p&gt;总之，个人感觉它可以算是中小企业的福音了。&lt;/p&gt;

&lt;p&gt;然后最近准备开始深入研究下这个系统，就像之前研究openstack一样，从源码开始，这个总不会比openstack还复杂吧！！！&lt;/p&gt;

&lt;p&gt;以下就直接抄它官网的文字介绍了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;我们认为商业软件应以简单的结构解决复杂的需求。我们的任务是提供直观、功能全面、紧密集成、升级无忧、面向每种业务、每一用户均可平稳运行的软件。

我们的目标是提供一系列易用业务应用程序，形成完整的一套工具，以满足任何业务需求。我们让数百万公司可轻松访问其运营和括大业务所需的软件。

在 Odoo，我们已开发了 30 种主要应用，均会定期更新。此外，我们的社区包括 1,500 多名活跃成员，已另外贡献了 4,500 多款应用，可涵盖大量业务需求。

Odoo 具有“预置型”产品，是全球安装最多的商业软件。从初创公司（1 名用户）到大型企业（300,000 多位用户），全球有 2,000,000 多名用户在使用这款软件。

Odoo 的开源模式让我们可利用无数开发人员和业务专家，在短短数年内，打造数百款应用。

具有强大的技术基础，Odoo 的结构非常独特。其具有 一流的可用性，堪比所有 app。

Odoo 所做的可用性改善会自动应用于我们充分集成的所有应用上。

采用这种方式，Odoo 比其他解决方案发展更快。

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Python的数据模型</title>
      <link>https://asdfsx.github.io/post/python/Python%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Tue, 13 Dec 2016 15:12:39 +0800</pubDate>
      
      <guid>https://asdfsx.github.io/post/python/Python%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</guid>
      <description>

&lt;p&gt;本文基于Python 3.5.2官方文档中数据模型部分完成&lt;/p&gt;

&lt;h1 id=&#34;1-对象-值-和-类型&#34;&gt;1.对象，值 和 类型&lt;/h1&gt;

&lt;p&gt;Python把数据抽象为Objects。Python程序中所有的数据都体现为对象，或者对象之间的关系。(从某种程度上讲，为了与冯.诺伊曼的&lt;code&gt;存储程序型计算机&lt;/code&gt;模型相一致，代码同样也体现为对象。)&lt;/p&gt;

&lt;p&gt;每个对象都有一个标识，一个类型和一个值。对象一旦创建，它的标识就不会变更；你可以理解为它就像对象在内存中的地址。&lt;code&gt;is&lt;/code&gt;操作用来比较两个对象的标识；&lt;code&gt;id()&lt;/code&gt;函数返回一个整数来表示它的标识。&lt;/p&gt;

&lt;p&gt;CPython实现细节：id(x)返回x在内存的存放地址。&lt;/p&gt;

&lt;p&gt;对象的类型决定了对象支持哪些操作（比如，这个对象有长度吗？），同时也定义了对象中可能存在哪些值。&lt;code&gt;type()&lt;/code&gt;函数返回一个对象的类型（类型也是一个对象）。就像它的标识，一个对象的类型也是不可变的。&lt;/p&gt;

&lt;p&gt;一些对象的值是可修改的。可以修改的的对象被称为可变的&lt;code&gt;to be mutable&lt;/code&gt;；创建后不能修改的对象被称为不可变的&lt;code&gt;immutable&lt;/code&gt;。（不可变容器对象的值如果是一个可变对象的引用，那么当后者的值发生改变的时候，前者的值也会改变；但是这个容器仍然被认为是不可变的，因为容器内部包含的对象都没有发生变化。所以，不可变性&lt;code&gt;immutability&lt;/code&gt;并不意味着拥有一个不可修改的值&lt;code&gt;unchangeable&lt;/code&gt;，这很微妙）。一个对象是否可变取决于它的类型；比如：数字、字符串、元组是不可变的，字典和数组是可变的。&lt;/p&gt;

&lt;p&gt;对象不会明确的被销毁；只有当它们不可达的时候，它们才有可能被垃圾回收。只要可达的对象不要被回收掉，如何实现延迟垃圾回收，并统一释放他们，这就是垃圾回收的实现质量问题了。&lt;/p&gt;

&lt;p&gt;CPython实现细节：CPython现在使用引用计数机制和（可选的）循环垃圾延迟检测机制，对象一旦不可达就尽量收集，但是无法保证能回收循环引用的垃圾。查看&lt;code&gt;gc&lt;/code&gt;模块的文档，来了解更多关于如何回收循环引用垃圾的信息。其他的实现可能不一样，而且CPtyhon也可能会改变策略。不要指望对象不可达以后，就会马上会被回收掉（所以你总是应该明确的关闭文件）。&lt;/p&gt;

&lt;p&gt;注意跟踪调试工具会让一些本该回收掉的对象始终可达。同时使用&lt;code&gt;try...except&lt;/code&gt;处理异常也会使对象始终可达。&lt;/p&gt;

&lt;p&gt;一些对象包含对&amp;rdquo;外部&amp;rdquo;资源的引用。我们知道当这些对象被垃圾回收后这些资源也会被释放，但是因为垃圾回收不能保证这些对像会被回收，所以这些对象会提供一个明确方式来释放资源，通常是&lt;code&gt;close()&lt;/code&gt;函数。强烈建议在程序中明确的关闭这样的对象。可以用&lt;code&gt;try...finally&lt;/code&gt;语句和&lt;code&gt;with&lt;/code&gt;语句来方便的执行它。&lt;/p&gt;

&lt;p&gt;一些对象包含对其他对象的应用；这些对象叫做容器&lt;code&gt;containers&lt;/code&gt;。这样的例子有元组、数组和字段。应用是容器的值的一部分。大部分的情况下，当我们说起容器中的值，指的是值，而不是容器内对象的标识；而当我们说容器的可变性，指的是容器中当前对象的标识。所以，一个不可变容器（比如元组）包含一个可变对象的引用，它的值是可变的，当那个可变对象发生变更的时候。&lt;/p&gt;

&lt;p&gt;类型几乎影响了对象的所有行为。在一些场景下甚至影响对象标识的重要性：对于不可变类型，计算新值的操作可能实际返回的是一个已存在的，拥有相同类型和值的对象的引用；而对于可变对象这是不允许的。比如，执行&lt;code&gt;a=1; b=1&lt;/code&gt;，a 和 b 可能（也可能不是）指向同一个包含&lt;code&gt;1&lt;/code&gt;的对象，取决于具体实现; 但是执行&lt;code&gt;c=[];d[]&lt;/code&gt;，c 和 d 保证指向两个完全不同的，独立的，新创建的空数组。（注意，&lt;code&gt;c = d = []&lt;/code&gt; 将同一个对象分配给了c 和 d 。）&lt;/p&gt;

&lt;h1 id=&#34;2-标准类型层级&#34;&gt;2.标准类型层级&lt;/h1&gt;

&lt;p&gt;下边是Python中内建类型列表。扩展模块（由C，Java，或其他语言实现的）会定义附加的类型。未来版本的 Python 可能会在此类型层次中增加新的类型 (例如：有理数，高效存储的整数数组等)，不过这些类型通常是在标准库中定义的。&lt;/p&gt;

&lt;p&gt;以下个别类型描述中可能有介绍&lt;code&gt;特殊属性&lt;/code&gt;的段落，它们是供实现访问的，不作为一般用途。这些定义在未来有可能发生改变：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;None&lt;br /&gt;
这个类型只具有一个值，并且这种类型也只有一个对象，这个对象可以通过内建名字&lt;code&gt;None&lt;/code&gt;访问，在许多场合里它表示无值，例如，没有显式返回值的函数会返回&lt;code&gt;None&lt;/code&gt;。这个对象的真值为假。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NotImplemented&lt;br /&gt;
这个类型只具有一个值，并且这种类型也只有一个对象。这个对象可以通过内建名字&lt;code&gt;NotImplemented&lt;/code&gt;访问。如果操作数没有对应实现，数值方法和复杂比较方法&lt;code&gt;rich comparison method&lt;/code&gt;应该返回这个值 (解释器会尝试反射操作，或者其它操作，根据具体的操作)。它的真值为真。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ellipsis&lt;br /&gt;
这个类型只具有一个值，并且这种类型也只有一个对象。这个对象可以通过字面值 &amp;hellip; 或者内建名字 Ellipsis 访问。它的真值为真。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;numbers.Number&lt;br /&gt;
它们由数值型字面值产生，或者是算术运算符和内建数学函数的返回值。数值型对象是不可变 的，即一旦创建，其值就不可改变。Python 数值型和数学上的数字关系当然是非常密切的，但也受到计算机数值表达能力的限制。&lt;/p&gt;

&lt;p&gt;Python 区分整数，浮点数和复数:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;numbers.Integral&lt;br /&gt;
描述了数学上的整数集 (正负数).&lt;br /&gt;
有两类整数:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Integers (int)&lt;br /&gt;
整数类型。表示不限范围的数字。移位和掩码操作符可以认为整数是这样组织的: 负数用二进制补码的一种变体表示，符号位会扩展至左边无限多位.&lt;/li&gt;
&lt;li&gt;Booleans (bool)&lt;br /&gt;
如此设计整数表示方法的一个目的是，使得负数在移位和掩码操作中能够更有意义.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;numbers.Real (float)&lt;br /&gt;
浮点数。本类型表示了机器级的双精度浮点数。硬件的底层体系结构 (和 C，Java 实现) 对你隐藏了浮点数取值范围和溢出处理的复杂细节。Python不支持单精度浮点数。使用单精度浮点数的原因一般是为了降低CPU负荷和节省内存，但是这个努力会被 Python 的对象处理代价所抵消，因此没有必要同时支持两种浮点数，使 Python 复杂化.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;numbers.Complex (complex)&lt;br /&gt;
复数。本类型用一对机器级的双精度浮点数表示复数。关于浮点数的介绍也适用于复数类型。复数 z 的实部和虚部可以通过属性 z.real 和 z.imag 获得.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sequences&lt;br /&gt;
它们代表了有限有序的集合，并由非负数字作为索引。内建函数&lt;code&gt;len()&lt;/code&gt;返回序列中的元素个数。当序列的长度为&lt;code&gt;n&lt;/code&gt;，索引集合中的数字有&lt;code&gt;0, 1, ... , n-1&lt;/code&gt;。通过&lt;code&gt;a[i]&lt;/code&gt;来访问序列&lt;code&gt;a&lt;/code&gt;中的&lt;code&gt;i&lt;/code&gt;元素。&lt;/p&gt;

&lt;p&gt;序列也支持切片：&lt;code&gt;a[i: j]&lt;/code&gt;表示满足&lt;code&gt;i &amp;lt;= k &amp;lt; j&lt;/code&gt;的所有项 &lt;code&gt;a[k]&lt;/code&gt;。在作为表达式使用时，这个切片与原始的序列类型相同，这隐含着会重新编号索引，即从零开始。&lt;/p&gt;

&lt;p&gt;个别序列还支持有第三个 “步长” 参数的 扩展切片：&lt;code&gt;a[i:j:k]&lt;/code&gt;选择了所有索引&lt;code&gt;x: x = i + n*k, n &amp;gt;= 0&lt;/code&gt;并且&lt;code&gt;i &amp;lt;= x &amp;lt; j&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;序列按照可变性可以分为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Immutable sequences&lt;br /&gt;
一个不可变序列对象一旦创建就不能修改。（如果该对象包含其他对象的引用，其他对象是可以被修改的。但是被一个不可变序列直接引用的对象不能改变。）&lt;br /&gt;
下边都是不可变序列&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Strings&lt;br /&gt;
字符串是一组&lt;code&gt;Unicode code points&lt;/code&gt;组成的序列。所有取值范围在&lt;code&gt;U+0000 - U+10FFFF&lt;/code&gt;的&lt;code&gt;code points&lt;/code&gt;都可以用来组成字符串。Python没有字符类型；取而代之的是字符串中的每个&lt;code&gt;code point&lt;/code&gt;都表示为一个长度为&lt;code&gt;1&lt;/code&gt;的字符串对象。内建函数&lt;code&gt;ord()&lt;/code&gt;可以把一个&lt;code&gt;code point&lt;/code&gt;从它的字符串格式转化为取值范围是&lt;code&gt;0 - 10FFFF&lt;/code&gt;的整型。&lt;code&gt;chr()&lt;/code&gt;把一个取值范围是&lt;code&gt;0 - 10FFFF&lt;/code&gt;的整型数字转化为长度为1的字符串。&lt;code&gt;str.encode()&lt;/code&gt;可以用指定的字符集把一个字符串转变成一个bytes，&lt;code&gt;bytes.decode()&lt;/code&gt;用来做相反的操作。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tuples&lt;br /&gt;
元组的元素是任意的python对象。包含2个或者更多元素的元组的格式是一列被&lt;code&gt;,&lt;/code&gt;分隔的表达式。只包含一个元素的元组的格式是一个以&lt;code&gt;,&lt;/code&gt;号结尾的表达式（一个表达式自己不能创建一个元组，since parentheses must be usable for grouping of expressions）。一个空元组，用&lt;code&gt;()&lt;/code&gt;表示。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bytes&lt;br /&gt;
bytes对象是一个不可修改的数组。元素都是&lt;code&gt;8-bit bytes&lt;/code&gt;, 可以表示为0到256之间的一个整数。&lt;br /&gt;
bytes字面量(比如，&lt;code&gt;b&#39;abc&#39;&lt;/code&gt;）和内建函数&lt;code&gt;bytes()&lt;/code&gt;可以用来创建&lt;code&gt;bytes&lt;/code&gt;对象。另外&lt;code&gt;bytes&lt;/code&gt;对象可以通过函数&lt;code&gt;decode()&lt;/code&gt;解码变成字符串。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mutable sequences&lt;br /&gt;
可变序列在创建后可以被修改。其下标表示和切片表示可以作为赋值语句和&lt;code&gt;del&lt;/code&gt;语句的目标。&lt;br /&gt;
目前有两种自带的可变序列。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Lists&lt;br /&gt;
一个list中的元素可以是任意的python对象。&lt;code&gt;Lists&lt;/code&gt;的格式是在&lt;code&gt;[]&lt;/code&gt;中放置一些由&lt;code&gt;,&lt;/code&gt;隔开的表达式。&lt;/li&gt;
&lt;li&gt;Byte Arrays&lt;br /&gt;
一个&lt;code&gt;bytearray&lt;/code&gt;对象是一个可变的数组。它是由内建函数&lt;code&gt;bytearray()&lt;/code&gt;创建的。除了可变（也因此不可哈希），&lt;code&gt;byte array&lt;/code&gt;还提供了与不可修改的&lt;code&gt;bytes&lt;/code&gt;对象相同的接口和功能。&lt;br /&gt;
扩展模块&lt;code&gt;array&lt;/code&gt;提供了一个额外的可变序列的例子，&lt;code&gt;collections&lt;/code&gt;模块也是如此。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set types&lt;br /&gt;
这个类型描述的是由有限数量的不可变对象构成的无序集合。因此它们不能用任何索引作为下标，但它们可以被迭代，内建函数&lt;code&gt;len()&lt;/code&gt;可以返回集合中的元素总数。集合的常用场合是快速测试某元素是否在集合中, 或者是从一个序列中删除重复元素，或者是做一些数学运算，比如求集合的交集，并集，差和对称差。&lt;br /&gt;
集合的元素与字典键一样，都是不可变性对象。注意，数值类型遵守数值比较的正常规则：如果两个数字相同（例如，1 和 1.0），只有一个能存在于集合中。&lt;br /&gt;
当前有两种内建的集合类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sets
表示一个可变的集合。由内建函数&lt;code&gt;set()&lt;/code&gt;创建，可以被多个函数修改，例如&lt;code&gt;add()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Frozen sets
表示一个不可变的集合。由内建函数&lt;code&gt;frozenset()&lt;/code&gt;创建。因为&lt;code&gt;frozenset&lt;/code&gt;不可变而且可以哈希，它可以作为另外一个集合的元素，也可以作为字典的key
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mappings&lt;br /&gt;
表示由任意类型作索引的有限对象集合。下标记法&lt;code&gt;a[k]&lt;/code&gt;表示在映射类型对象 a 中选择以 k 为索引的项，这该项可以用于表达式，作为赋值语句和&lt;code&gt;del&lt;/code&gt;语句的目标，内建函数&lt;code&gt;len()&lt;/code&gt;返回映射对象的元素数量。&lt;br /&gt;
目前只有一种内建映射类型:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dictionaries&lt;br /&gt;
表示一个有限对象集合，几乎可以用任意值索引其中的对象。包括列表和字典的值可以是值，但不能是键，或者其它通过值比较而不是以对象标识比较的可变对象也不能作为键，其原因是字典的实现效率要求键的散列值保持不变。数值类型遵守数值比较的正常规则：如果两个数字相同（例如，1 和 1.0）那么它们可以作为字典中同一个实体的索引。&lt;br /&gt;
字典是可变的, 可以用 {&amp;hellip;} 语法创建它们。&lt;br /&gt;
扩展模块&lt;code&gt;dbm.ndbm, dbm.gnu, collections&lt;/code&gt;提供了其他映射类型的例子。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Callable types&lt;br /&gt;
下边是函数调用操作可以接受的类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;User-defined functions&lt;br /&gt;
通过函数定义可以创建用户自定义的函数对象（查看函数定义）。在调用它的时候要按照函数定义的参数列表传递相同个数的参数。
特殊属性：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Attribute&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__doc__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;函数的文档字符串, 如果没有为&lt;code&gt;None&lt;/code&gt;; 不会被子类继承&lt;/td&gt;
&lt;td&gt;Writable&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__name__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;函数的名字&lt;/td&gt;
&lt;td&gt;Writable&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__qualname__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;函数的&lt;code&gt;qualified name&lt;/code&gt;，在3.3版中新增的&lt;/td&gt;
&lt;td&gt;Writable&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__module__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;函数所在的模块，如果没有就是&lt;code&gt;None&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Writable&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__defaults__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;一个用来存放默认参数的元组，如果没有默认参值为&lt;code&gt;None&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Writable&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__code__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;函数体经过编译后生成的代码对象&lt;/td&gt;
&lt;td&gt;Writable&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__globals__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指向函数可调用的全局变量的引用-函数所在模块的全局名字空间&lt;/td&gt;
&lt;td&gt;Read-only&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;名字空间，支持任意的函数属性&lt;/td&gt;
&lt;td&gt;Writable&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__closure__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;元组，含有函数自由变量绑定，如果没有自由变量，就为&lt;code&gt;None&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Read-only&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__annotations__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;存储参数注解（annotations）的字典。键为参数名。如果有返回值，返回值的键为&lt;code&gt;return&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Writable&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__kwdefaults__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;存储关键字参数默认值的字典&lt;/td&gt;
&lt;td&gt;Writable&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instance methods&lt;br /&gt;
实例方法对象由类、类的实例、可调用对象（通常是用户自定义函数）组合而成。&lt;/p&gt;

&lt;p&gt;特殊的只读属性：&lt;code&gt;__self__&lt;/code&gt;是类的实例对象；&lt;code&gt;__func__&lt;/code&gt;是函数对象；&lt;code&gt;__doc__&lt;/code&gt;是方法的文档（就像&lt;code&gt;__func__.__doc__&lt;/code&gt;）；&lt;code&gt;__name__&lt;/code&gt;是方法的名字（就像&lt;code&gt;__func__.__name__&lt;/code&gt;）；&lt;code&gt;__module__&lt;/code&gt;是方法所在的模块名字，如果没有就是&lt;code&gt;None&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;方法也支持对底层函数对象任意属性的访问，但不支持设置。&lt;/p&gt;

&lt;p&gt;用户定义方法对象可以通过获取类属性（也可能是通过该类的一个实例）创建，但前提是这个属性是用户定义函数对象，或者类方法对象。&lt;/p&gt;

&lt;p&gt;通过检索一个类实例的用户自定义方法，可以创建实例方法对象&lt;code&gt;instance method object&lt;/code&gt;。实例方法对象的属性&lt;code&gt;__self__&lt;/code&gt;指向该类实例，这个方法称为是&lt;code&gt;被绑定的&lt;/code&gt;。这个方法的属性&lt;code&gt;__func__&lt;/code&gt;指向原来的方法对象。&lt;/p&gt;

&lt;p&gt;通过检索另外一个类或着实例的方法对象，可以创建用户自定义方法对象&lt;code&gt;user-defined method object&lt;/code&gt;。这个操作类似创建方法对象，只不过新的实例等&lt;code&gt;__func__&lt;/code&gt;属性不在指向原来的方法对象，而是自己的&lt;code&gt;__func__&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在类或实例中检索方法对象过程中生成的实例方法对象是，它的&lt;code&gt;__self__&lt;/code&gt;属性就是类本身，它的&lt;code&gt;__func__&lt;/code&gt;属性存放的函数对象就是类中的方法。&lt;/p&gt;

&lt;p&gt;当一个实例的方法对象被调用的时候，它对应的底层函数（&lt;code&gt;__func__&lt;/code&gt;）被调用，类实例（&lt;code&gt;__self__&lt;/code&gt;）被插到参数列表的最前边。例如，类&lt;code&gt;C&lt;/code&gt;由一个函数&lt;code&gt;f()&lt;/code&gt;，&lt;code&gt;x&lt;/code&gt;是&lt;code&gt;C&lt;/code&gt;的一个实例，&lt;code&gt;x.f(1)&lt;/code&gt;的行为其实就是&lt;code&gt;C.f(x, 1)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果一个实例方法对象是由类方法对象中推导出来的，保存&lt;code&gt;类实例&lt;/code&gt;的&lt;code&gt;__self__&lt;/code&gt;其实就是类本身，所以调用&lt;code&gt;x.f(1)&lt;/code&gt;或者&lt;code&gt;C.f(1)&lt;/code&gt;都等于调用&lt;code&gt;f(C,1)&lt;/code&gt;，f是底层函数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generator functions&lt;br /&gt;
生成器函数就是使用了yield语句（请查看yield语句）的函数或者方法。这样的一个函数被调用的时候会返回一个用来执行函数体的迭代器对象：调用这个迭代器的函数&lt;code&gt;iterator.__next__()&lt;/code&gt;就会让这个函数执行，直到遇到yield语句返回一个值。
当函数遇到return语句或者执行到末尾，会抛出一个&lt;code&gt;StopIteration&lt;/code&gt;，而且迭代器将会到达所有返回值的末尾。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Coroutine functions&lt;br /&gt;
一个用&lt;code&gt;async def&lt;/code&gt;来定义的函数或方法，叫做协同程序函数。这样的函数在调用时会返回一个协程对象。它可能包含&lt;code&gt;await&lt;/code&gt;表达式，也可能是&lt;code&gt;async with&lt;/code&gt;和&lt;code&gt;async for&lt;/code&gt;语句。详情查看&lt;code&gt;协程对象&lt;/code&gt;部分&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Built-in functions&lt;br /&gt;
内建函数是对C函数的一个包装。例如&lt;code&gt;len()&lt;/code&gt;, &lt;code&gt;math.sin()&lt;/code&gt;(&lt;code&gt;math&lt;/code&gt;是一个标准的内建模块)。参数的类型和个数是在C函数中定义的。特殊的只读属性：&lt;code&gt;__doc__&lt;/code&gt;是函数的文档字符串，如果没有就是&lt;code&gt;None&lt;/code&gt;；&lt;code&gt;__name__&lt;/code&gt;是函数的名字；&lt;code&gt;__self__&lt;/code&gt;被设置为&lt;code&gt;None&lt;/code&gt;(但是留意下部分)；&lt;code&gt;__module__&lt;/code&gt;是函数所在模块的名字，如果没有那就是&lt;code&gt;None&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Built-in methods&lt;br /&gt;
这其实是一个内建函数的伪装，这次通过一个隐藏的参数将一个对象传给了C函数。例如内建函数&lt;code&gt;alist.append()&lt;/code&gt;，其中&lt;code&gt;alist&lt;/code&gt;是一个数组对象。在这个例子中，一个特殊的只读参数&lt;code&gt;__self__&lt;/code&gt;被传递，它表示&lt;code&gt;alist&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Classes&lt;br /&gt;
类可以被调用。这样的对象就像是自己实例等工厂一样，但是通过覆盖&lt;code&gt;__new__()&lt;/code&gt;可以改变这个行为。调用参数会被传递到&lt;code&gt;__new__()&lt;/code&gt;, 然后在大部分情况下传递给&lt;code&gt;__init__()&lt;/code&gt;来初始化一个实例。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Class Instances&lt;br /&gt;
一个纯Python类的实例可以变成可被调用的，只要在类中实现了方法&lt;code&gt;__call__()&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Modules&lt;br /&gt;
模块是Python代码的基本组织单位，它由导入系统&lt;code&gt;import system&lt;/code&gt;生成，方法有使用import语句，或者调用类似&lt;code&gt;importlib.import_module()&lt;/code&gt;的方法，或者内建函数&lt;code&gt;__import__()&lt;/code&gt;。一个模块对象有一个由字典对象实现的名字空间（模块中定义的函数可以通过&lt;code&gt;__globals__&lt;/code&gt;属性获得这个字典）。模块属性的访问被转换成查找这个字典，例如&lt;code&gt;m.x&lt;/code&gt;等价于&lt;code&gt;m.__dict__[&amp;quot; x&amp;quot; ]&lt;/code&gt;。模块对象不包含初始化该模块的代码对象 (因为初始化完成后就不再需要它了)。
对模块属性的赋值会更新模块的名字空间，例如&lt;code&gt;m.x = 1&lt;/code&gt;等价于&lt;code&gt;m.__dict__[&amp;quot;x&amp;quot;] = 1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;只读特殊属性&lt;code&gt;__dict__&lt;/code&gt;就是模块名字空间的字典对象。&lt;/p&gt;

&lt;p&gt;预定义的可写属性：&lt;code&gt;__name__&lt;/code&gt;是模块名；&lt;code&gt;__doc__&lt;/code&gt;是模块的文档字符串或&lt;code&gt;None&lt;/code&gt;。如果模块是由文件加载的，&lt;code&gt;__file__&lt;/code&gt;是对应文件的路径名，用C语言编写的静态链接进解释器的模块没有这个属性，而对于从共享库加载的模块，这个属性的值就是共享库的路径。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Custom classes&lt;br /&gt;
自定义类类型一般是由类定义创建的。类的名字空间是由字典对象实现的。类的属性都是从这个字典对象中查找的，例如，&lt;code&gt;C.x&lt;/code&gt;其实就是&lt;code&gt;C.__dict__[&amp;quot;x&amp;quot;]&lt;/code&gt;(另外还有很多种机制去定位属性)。当属性名没有在这里找到，会继续到基类中去查找属性。基类中的搜索方法使用C3方法解析顺序, 这种方法即便是多重继承里出现了公共祖先类的 “菱形” 结构也能保持正确行为. 关于Python使用的 C3 MRO 额外细节可以在 2.3 版本的附带文档中找到:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://www.python.org/download/releases/2.3/mro/.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当一个类 (假如是类 C) 的属性引用会产生类方法对象时, 它就会被转换成实例方法对象, 并将这个对象的&lt;code&gt;__self__&lt;/code&gt;属性指向&lt;code&gt;C&lt;/code&gt;. 当要产生静态方法对象时, 它会被转换成用静态方法对象包装的对象. 另一种获取与&lt;code&gt;__dict__&lt;/code&gt;实际内容不同的属性的方法可以参考 实现描述符.&lt;/p&gt;

&lt;p&gt;类属性的赋值会更新类的字典, 而不是基类的字典.&lt;/p&gt;

&lt;p&gt;一个类对象可以被调用 (如上所述), 以产生一个类实例 (下述)。&lt;/p&gt;

&lt;p&gt;特殊属性：&lt;code&gt;__name__&lt;/code&gt;是类名，&lt;code&gt;__module__&lt;/code&gt;是类定义所在的模块名；&lt;code&gt;__dict__&lt;/code&gt;是类的名字空间字典。&lt;code&gt;__bases__&lt;/code&gt;是基类元组 (可能为空或独元)，基类的顺序以定义时基类列表中的排列次序为准。&lt;code&gt;__doc__&lt;/code&gt;是类的文档字符串或者 None。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Class instances&lt;br /&gt;
类实例是用类对象调用创建的。类实例有一个用字典实现的名字空间，它是进行属性搜索的第一个地方。如果属性没在那找到，但实例的类中有那个名字的属性，就继续在类属性中查找。如果找到的是一个用户定义函数对象，它被转换成实例方法对象，这个对象的&lt;code&gt;__self__&lt;/code&gt;属性指向实例本身。静态方法和类方法对象也会按上面&lt;code&gt;Classes&lt;/code&gt;中的介绍那样进行转换。另一种获取与&lt;code&gt;__dict__&lt;/code&gt;实际内容不同的属性的方法可以参考 实现描述符。如果没有找到匹配的类属性，但对象的类提供了&lt;code&gt;__getattr__()&lt;/code&gt;方法，那么最后就会调用它完成属性搜索。&lt;/p&gt;

&lt;p&gt;属性的赋值和删除会更新实例字典，而不是类的字典。如果类具有方法&lt;code&gt;__setattr__()&lt;/code&gt;或者&lt;code&gt;__delattr__()&lt;/code&gt;就会调用它们，而不是直接更新字典。&lt;/p&gt;

&lt;p&gt;如果提供了相应特别方法的定义，类实例可以伪装成数值，序列或者映射类型，参见 特殊方法名。&lt;/p&gt;

&lt;p&gt;特殊属性：&lt;code&gt;__dict__&lt;/code&gt;是属性字典；&lt;code&gt;__class__&lt;/code&gt;是实例的类。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I/O objects (also known as file objects)&lt;br /&gt;
一个文件对象表示一个打开的文件。创建一个文件对像有很多方法：内建函数&lt;code&gt;open()&lt;/code&gt;，还有&lt;code&gt;os.popen()&lt;/code&gt;, &lt;code&gt;os.fdopen()&lt;/code&gt;，还有&lt;code&gt;socket&lt;/code&gt;对象中的&lt;code&gt;makefile()&lt;/code&gt;方法(还有一些扩展模块kennel也会提供一些函数和方法)。&lt;/p&gt;

&lt;p&gt;对象&lt;code&gt;sys.stdin&lt;/code&gt;，&lt;code&gt;sys.stdout&lt;/code&gt;和&lt;code&gt;sys.stderr&lt;/code&gt;被初始化为解释器相应的标准输入流，标准输出流和标准错误输出流。它们都以文本模式打开，因此都遵循抽象类&lt;code&gt;io.TextIOBase&lt;/code&gt;定义的接口。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Internal types&lt;br /&gt;
有少量解释器内部使用的类型是用户可见的，它们的定义可能会在未来版本中改变，出于完整性的考虑这里也会提一下它们。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Code objects&lt;br /&gt;
代码对象表示&lt;code&gt;字节编译&lt;/code&gt;过的可执行Python代码，或者称为&lt;code&gt;bytecode&lt;/code&gt;。代码对象与函数对象的不同在于函数对象包含了函数全局变量的引用（所在模块定义的），而代码对象不包括上下文。默认参数值也保存在函数对象里，而不在代码对象中（因为它们表示的是运行时计算出来的值）。不像函数对象，代码对象是不可变的，并且不包括对可变对象的（直接或间接的）引用。&lt;/p&gt;

&lt;p&gt;特殊的只读属性：&lt;code&gt;co_name&lt;/code&gt;给出了函数名；&lt;code&gt;co_argcount&lt;/code&gt;是位置参数的数目（包括有默认值的参数）；&lt;code&gt;co_nlocals&lt;/code&gt;是函数使用的局部变量的数目（包括参数）。&lt;code&gt;co_varnames&lt;/code&gt;是一个包括局部变量名的元组（从参数的名字开始）。&lt;code&gt;co_cellvars&lt;/code&gt;是一个元组，包括由嵌套函数引用的局部变量名；&lt;code&gt;co_freevals&lt;/code&gt;元组包括了自由变量的名字；&lt;code&gt;co_code&lt;/code&gt;是字节编译后的指令序列的字符串表示；&lt;code&gt;co_consts&lt;/code&gt;元组包括字节码中使用的字面值；&lt;code&gt;co_names&lt;/code&gt;元组包括字节码中使用的名字；&lt;code&gt;co_ﬁlename&lt;/code&gt;记录了字节码来自于什么文件；&lt;code&gt;co_ﬁrstlineno&lt;/code&gt;是函数首行号；&lt;code&gt;co_lnotab&lt;/code&gt;是一个字符串, 它表示从字节码偏移到行号的映射（细节可以在解释器代码中找到）；&lt;code&gt;co_stacksize&lt;/code&gt;是需要的堆栈尺寸（包括局部变量）；&lt;code&gt;co_ﬂags&lt;/code&gt;是一个表示解释器各种标志的整数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;co_ﬂags&lt;/code&gt;定义了如下标志位：如果函数使用了&lt;code&gt;*arguments&lt;/code&gt;语法接收任意数目的位置参数就会把&lt;code&gt;0x04&lt;/code&gt;置位；如果函数使用了&lt;code&gt;**keywords&lt;/code&gt;语法接收任意数量的关键字参数，就会把&lt;code&gt;0x08&lt;/code&gt;置位。如果函数是一个产生器（generator），就会置为&lt;code&gt;0x20&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Future功能声明&lt;code&gt;from __future__ import division&lt;/code&gt;也使用了&lt;code&gt;co_flags&lt;/code&gt;的标志位指出代码对象在编译时是否打开某些特定功能：如果函数是打开了&lt;code&gt;future division&lt;/code&gt;编译的，就会把&lt;code&gt;0x2000&lt;/code&gt;置位；之前版本的Python使用过位&lt;code&gt;0x10&lt;/code&gt;和&lt;code&gt;0x1000&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;co_flags&lt;/code&gt;中其它位由解释器内部保留。&lt;/p&gt;

&lt;p&gt;如果代码对象表示的是函数，那么&lt;code&gt;co_consts&lt;/code&gt;的第一个项是函数的文档字符串，或者为&lt;code&gt;None&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Frame objects&lt;br /&gt;
栈对象表示执行时的栈桢，它们会在回溯对象中出现（下述）。&lt;/p&gt;

&lt;p&gt;特殊的只读属性：属性&lt;code&gt;f_back&lt;/code&gt;指向前一个栈（朝着调用者的方向），如果位于堆栈底部它就是&lt;code&gt;None&lt;/code&gt;；属性&lt;code&gt;f_code&lt;/code&gt;指向在这个栈结构上执行的代码对象。属性&lt;code&gt;f_locals&lt;/code&gt;是用于查找局部变量的字典；属性&lt;code&gt;f_globals&lt;/code&gt;字典用于查找全局变量；属性&lt;code&gt;f_builtins&lt;/code&gt;字典用于查找内建名字；属性&lt;code&gt;lasti&lt;/code&gt;以代码对象里指令字符串的索引的形式给出了精确的指令。&lt;/p&gt;

&lt;p&gt;特殊的可写属性：属性&lt;code&gt;f_trace&lt;/code&gt;如果不是&lt;code&gt;None&lt;/code&gt;，就是这个栈所在函数的名称（用于调试器）。 属性&lt;code&gt;f_lineno&lt;/code&gt;是此栈当前行的行号，在跟踪函数里如果写入这个属性，可以使程序跳转到新行上（只能用于最底部的栈桢），调试器可以这样实现跳转命令（即 “指定下一步” 语句）。&lt;/p&gt;

&lt;p&gt;栈对象支持一个方法：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;frame.clear()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个方法将清除当前栈中所持有的所有本地变量的引用。另外，如果这个栈属于一个生成器，这个生成器也将结束。这有助与打破涉及栈对象的循环依赖（例如获取异常后对它的异常回溯进行排序以便之后使用）。&lt;/p&gt;

&lt;p&gt;如果这个栈当前正在执行中，异常&lt;code&gt;RuntimeError&lt;/code&gt;将被触发。&lt;/p&gt;

&lt;p&gt;3.4版新增。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Traceback objects&lt;br /&gt;
回溯对象是对一个异常的栈回溯。当异常发生时回创建这个对象。当我们在栈桢内搜索异常处理器时，每当要搜索一个栈桢就会把一个回溯对象会插入到当前回溯对象的前面。在进入异常处理器时，程序就可以使用回溯对象了。（参见&lt;code&gt;try&lt;/code&gt;语句）。这些回溯对象可以通过 &lt;code&gt;sys.exc_info()&lt;/code&gt;返回元组的第三项访问。当程序中没有适当的异常处理器，回溯对象就被打印到标准错误输出上。如果工作在交互模式上，也可以通过&lt;code&gt;sys.last_traceback&lt;/code&gt;访问。&lt;br /&gt;
特殊的只读属性：&lt;code&gt;tb_text&lt;/code&gt;是堆栈回溯的下一级（向着发生异常的那个栈桢），或者如果没有下一级就为&lt;code&gt;None&lt;/code&gt;。属性&lt;code&gt;tb_frame&lt;/code&gt;指向当前的栈桢对象；属性&lt;code&gt;tb_lineno&lt;/code&gt;给出发生异常的行号；属性&lt;code&gt;tb_lasti&lt;/code&gt;精确地指出对应的指令。如果异常发生在没有匹配&lt;code&gt;except&lt;/code&gt;或&lt;code&gt;finally&lt;/code&gt;子句的&lt;code&gt;try&lt;/code&gt;语句中，回溯对象中的行号和指令可能与栈桢对象中的行号和指令不同。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Slice objects&lt;br /&gt;
切片对象用于在&lt;code&gt;__getitem__()&lt;/code&gt;方法中表示切片信息，也可以用内建函数&lt;code&gt;slice()&lt;/code&gt;创建。&lt;/p&gt;

&lt;p&gt;特殊的只读属性：&lt;code&gt;start&lt;/code&gt;是下界；&lt;code&gt;stop&lt;/code&gt;是上界；&lt;code&gt;step&lt;/code&gt;是步长，如果忽略任何一个，就取&lt;code&gt;None&lt;/code&gt;值。这些属性可以是任意类型。&lt;/p&gt;

&lt;p&gt;切片对象只支持一个方法：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;slice.indices(self, length)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个方法根据整数参数&lt;code&gt;length&lt;/code&gt;判断切片对象是否能够描述&lt;code&gt;length&lt;/code&gt;长的元素序列。它返回一个包含三个整数的元组，分别是索引&lt;code&gt;start&lt;/code&gt;，&lt;code&gt;stop&lt;/code&gt;和步长&lt;code&gt;step&lt;/code&gt;。对于索引不足或者说越界的情况，返回值提供的是切片对象中能够提供的最大 (最小) 边界索引。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Static method objects&lt;br /&gt;
静态方法对象提供了一种避免上边说过情形的方法，即避免将函数对象转变成方法对象。静态方法对象其实是对任意对象的一个包装，通常是用户自定义函数。当从类或着类的实例中检索一个静态方法对象时，返回的其实就是一个包装过的对象，而且并没有经过之前任何转换。静态方法对象自己时不可调用的，尽管它们包装的都是可调用的。静态方法对象是由内建构造器&lt;code&gt;staticmethod()&lt;/code&gt;创建的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Class method objects&lt;br /&gt;
类方法对象，就像静态方法对象，是另外一个对象的包装，通过这个包装可以改变从类和泪实例中检索对象的行为。检索累方法对象的行为已经在上边描述过，在&lt;code&gt;User-defined methods&lt;/code&gt;部分。类方法对象是由内建构造器&lt;code&gt;classmethod()&lt;/code&gt;创建的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;3-特殊名字的方法&#34;&gt;3.特殊名字的方法&lt;/h1&gt;

&lt;p&gt;通过定义名字特殊的方法，一个类能够实现特殊语法所调用的操作（例如算术运算，下标及切片操作）。这是Python式的运算符重载&lt;code&gt;operator overloading&lt;/code&gt;，让类可以定义自己的行为并充分利用语言中的操作符。例如，一个类如果定义了方法&lt;code&gt;__getitem__()&lt;/code&gt;，然后&lt;code&gt;x&lt;/code&gt;是这个类的实例，那么&lt;code&gt;x[i]&lt;/code&gt;基本上就等于&lt;code&gt;type(x).__getitem__(x, i)&lt;/code&gt;。除非特别标示，在没有适当定义方法的类上执行操作会导致抛出异常，一般是&lt;code&gt;AttributeError&lt;/code&gt;或者&lt;code&gt;TypeError&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在实现要模拟任意内建类型的类时，需要特别指出的是 “模拟” 只是达到了满足使用的程度，这点需要特别指出。例如，获取某些序列的单个元素是正常的，但使用切片却是没有意义的（一个例子是在W3C文档对象模型中的&lt;code&gt;NodeList&lt;/code&gt;接口。）&lt;/p&gt;

&lt;h4 id=&#34;3-1-基础定制&#34;&gt;3.1 基础定制&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;object.__new__(cls[, &amp;hellip;])&lt;br /&gt;
调用时创建类&lt;code&gt;cls&lt;/code&gt;的实例。&lt;code&gt;__new()&lt;/code&gt;是一个静态方法（特殊函数所以你不需要定义），第一个参数是需要创建实例等类。其余的参数会创递给实例构造器（调用类）。&lt;code&gt;__new__()&lt;/code&gt;的返回值是类的新对象实例（通常是&lt;code&gt;cls&lt;/code&gt;的实例）。&lt;/p&gt;

&lt;p&gt;常见的情况下是通过&lt;code&gt;super(currentclass, cls).__new__(cls[, ...])&lt;/code&gt;的方式，传递对应的参数调用父类的&lt;code&gt;__new__()&lt;/code&gt;的来实现创建一个类的新实例，然后再返回实例之前根据需求对实例进行相应的修改。&lt;/p&gt;

&lt;p&gt;如果&lt;code&gt;__new__()&lt;/code&gt;返回类&lt;code&gt;cls&lt;/code&gt;的新实例，那么新实例的&lt;code&gt;__init__()&lt;/code&gt;方法将会被调用&lt;code&gt;__init__(self[, ...])&lt;/code&gt;，&lt;code&gt;self&lt;/code&gt;就是新实例自己，其余参数就是传递给&lt;code&gt;__new__()&lt;/code&gt;的参数。&lt;/p&gt;

&lt;p&gt;如果&lt;code&gt;__new__()&lt;/code&gt;返回的不是类&lt;code&gt;cls&lt;/code&gt;的实例，那么新实例的&lt;code&gt;__init__&lt;/code&gt;方法不会被调用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;__new__&lt;/code&gt;方法主要用于让不可变类型的子类（比如：int，str，tuple）可以定制化实例的创建。在自定义&lt;code&gt;metaclass&lt;/code&gt;的时候，这个函数也经常被覆盖，以定制类的创建。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__init__(self[, &amp;hellip;])&lt;br /&gt;
实例被&lt;code&gt;__new__()&lt;/code&gt;创建以后，并在返回调用者之前被调用。参数就是那些传递给类构造表达式的值。如果基类有&lt;code&gt;__init__()&lt;/code&gt;方法，推断类的&lt;code&gt;__init__()&lt;/code&gt;方法，如果有，必须显示的调用它来确保新实例中基类的部分被正确的初始化；比如：&lt;code&gt;BaseClass.__init__(self, [args...])&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;因为&lt;code&gt;__new__()&lt;/code&gt;和&lt;code&gt;__init__()&lt;/code&gt;在构建对象的时候共同工作（&lt;code&gt;__new__()&lt;/code&gt;创建对象，&lt;code&gt;__init__()定制对象&lt;/code&gt;），&lt;code&gt;__init__()&lt;/code&gt;不会返回任何值；这样做会在运行时导致&lt;code&gt;TypeError&lt;/code&gt;异常。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__del__(self)&lt;br /&gt;
当实例要被销毁的时候被调用。这个方法也可以被叫做销毁器。如果基类有&lt;code&gt;__del__()&lt;/code&gt;方法，推断类里是否有&lt;code&gt;__del__()&lt;/code&gt;方法，如果有，必须显式调用这个函数确保实例中基类部分被正确的销毁。注意：在&lt;code&gt;__del__()&lt;/code&gt;里可以创建本对象的新引用来达到推迟删除的目的，但这并不是推荐做法。&lt;code&gt;__del__()&lt;/code&gt;方法在删除最后一个引用后不久调用。但不能保证，在解释器退出时所有存活对象的&lt;code&gt;__del__()&lt;/code&gt;方法都能被调用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Note：`del x`并不直接调用`x.__del__()`——— 前者将引用计数减一，而后者只有在引用计数减到零时才被调用。引用计数无法达到零的一些常见情况有：对象之间的循环引用 （例如，一个双链表或一个具有父子指针的树状数据结构)；对出现异常的函式的栈桢上对象的引用`(sys.ext_info()[2]`中的回溯对象保证了栈桢不会被删除）；或者交互模式下出现未拦截异常的栈桢上的对象的引用（`sys.last_traceback`中的回溯对象保证了栈桢不会被删除）。第一种情况只有能通过地打破循环才能解决。后两种情况，可以通过将 `sys.last_traceback`赋予`None`解决。只有在打开循环检查器选项时（这是默认的），循环引用才能被垃圾回收机制发现，但前提是Python脚本中的`__del__()`方法不要参与进来。关于`__del__()`与循环检查器是如何相互影响的详细信息，可以参见`gc`模块的介绍，尤其是其中的 garbage 值的描述。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Warning：因为调用`__del__()`方法时环境的不确定性，它执行时产生的异常会被忽略掉，只是在`sys.stderr`打印警告信息。另外，当因为删除模块而调用`__del__()`方法时（例如，程序退出时），有些`__del__()`所引用的全局名字可能已经删除了，或者正在删除（例如，正在清理`import`关系）。 由于这些原因，`__del__()`方法对外部不变式的要求应该保持最小。从Python1.5开始，Python可以保证以单下划线开始的全局名字一定在其它全局名字之前从该模块中删除，如果没有其它对这种全局名字的引用，这个功能有助于保证导入的模块在调用`__del__()`时还是有效的。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__repr__(self)&lt;br /&gt;
有内建函数&lt;code&gt;repr()&lt;/code&gt;调用，来获得一个对象的“正式的”表达字符串。如果可能的话，这个字符串是一个可用的python表达式，可以用来重新创建一个具有相同值的对象。如果不可能，会返回一个格式为&lt;code&gt;&amp;lt;...有用的描述...&amp;gt;&lt;/code&gt;的字符串。返回值必须是一个字符串对象。如果一个类只定义了&lt;code&gt;__repr__()&lt;/code&gt;而没有&lt;code&gt;__str__()&lt;/code&gt;，&lt;code&gt;__repr__()&lt;/code&gt;会同样用来获得一个这个类的实例的“非正式”表达字符串。&lt;/p&gt;

&lt;p&gt;这个通常用于调试，所以描述字符串的信息丰富性和无歧义性是很重要的.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__str__(self)&lt;br /&gt;
由&lt;code&gt;str(object)&lt;/code&gt;调用，也可以由内建函数&lt;code&gt;format()&lt;/code&gt;和&lt;code&gt;print()&lt;/code&gt;调用，来得到一个&lt;code&gt;非正规的&lt;/code&gt;、容易打印的、表示这个对象的字符串。返回值必须是一个字符串对象。&lt;/p&gt;

&lt;p&gt;这个方法与&lt;code&gt;object.__repr__()&lt;/code&gt;的不同之处在于，&lt;code&gt;__str__()&lt;/code&gt;不一定会返回一个可用的python表达式，返回的是更简单易用的表示。&lt;/p&gt;

&lt;p&gt;默认的实现是由内建类型&lt;code&gt;object&lt;/code&gt;定义的：调用&lt;code&gt;object.__repr__()&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__bytes__(self)&lt;br /&gt;
由函数&lt;code&gt;bytes()&lt;/code&gt;调用，来得到一个用来表示对像的一个字节字符串。这会返回一个字节对像。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__format__(self, format_spec)&lt;br /&gt;
由内建函数&lt;code&gt;format()&lt;/code&gt;（和&lt;code&gt;str&lt;/code&gt;类的方法&lt;code&gt;format()&lt;/code&gt;）调用，用来构造对象的“格式化”字符串描述。&lt;code&gt;format_spec&lt;/code&gt;参数是描述格式选项的字符串。&lt;code&gt;format_spec&lt;/code&gt;的解释依赖于实现&lt;code&gt;__format__()&lt;/code&gt;的类型，但一般来说，大多数类要么把格式化任务委托（转交）给某个内建类型，或者使用与内建类型类似的格式化选项。&lt;/p&gt;

&lt;p&gt;关于标准格式语法的描述，可以参考&lt;code&gt;Format Specification Mini-Language&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;返回值必须是字符串对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在Python 3.4版发生的变化：
如果传递任意的非空字符给`__format__`方法，会产生`TypeError`异常。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__lt__(self, other)&lt;br /&gt;
object.__le__(self, other)&lt;br /&gt;
object.__eq__(self, other)&lt;br /&gt;
object.__ne__(self, other)&lt;br /&gt;
object.__gt__(self, other)&lt;br /&gt;
object.__ge__(self, other)&lt;br /&gt;
它们称为“富比较”方法。运算符与方法名的对应关系如下：&lt;code&gt;x&amp;lt;y&lt;/code&gt;调用&lt;code&gt;x.__lt__(y)&lt;/code&gt;，&lt;code&gt;x&amp;lt;=y&lt;/code&gt;调用&lt;code&gt;x.__le__(y)&lt;/code&gt;，&lt;code&gt;x==y&lt;/code&gt;调用&lt;code&gt;x.__eq__(y)&lt;/code&gt;，&lt;code&gt;x!=y&lt;/code&gt;调用&lt;code&gt;x.__ne__(y)&lt;/code&gt;，&lt;code&gt;x&amp;gt;y&lt;/code&gt;调用&lt;code&gt;x.__gt__(y)&lt;/code&gt;，&lt;code&gt;x&amp;gt;=y&lt;/code&gt;调用&lt;code&gt;x.__ge__(y)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;不是所有厚比较方法都要同时实现的，如果个别厚比较方法没有实现，可以直接返回 NotImplemented。从习惯上讲，一次成功的比较应该返回&lt;code&gt;False&lt;/code&gt;或&lt;code&gt;True&lt;/code&gt;。但是这些方法也可以返回任何值，所以如果比较运算发生在布尔上下文中（例如&lt;code&gt;if&lt;/code&gt;语句中的条件测试），Python会在返回值上调用函式&lt;code&gt;bool()&lt;/code&gt;确定返回值的真值。&lt;/p&gt;

&lt;p&gt;在比较运算符之间并没有潜在的相互关系。&lt;code&gt;x==y&lt;/code&gt;为真并不意味着&lt;code&gt;x!=y&lt;/code&gt;为假。因此，如果定义了方法&lt;code&gt;__eq__()&lt;/code&gt;，那么也应该定义&lt;code&gt;__ne__()&lt;/code&gt;，这样才可以得到期望的效果。关于如何创建可以作为字典键使用的&lt;code&gt;hashable&lt;/code&gt;对象，还需要参考&lt;code&gt;__hash__()&lt;/code&gt;的介绍。&lt;/p&gt;

&lt;p&gt;没有参数交换版本的方法定义（这可以用于当左边参数不支持操作，但右边参数支持的情况）。&lt;code&gt;__lt__()&lt;/code&gt;和&lt;code&gt;__gt__()&lt;/code&gt;相互反射（即互为参数交换版本）；&lt;code&gt;__le__()&lt;/code&gt;和&lt;code&gt;__ge__()&lt;/code&gt;相互反射；&lt;code&gt;__eq__()&lt;/code&gt;和&lt;code&gt;__ne__()&lt;/code&gt;相互反射。&lt;/p&gt;

&lt;p&gt;传递给厚比较方法的参数不能是被自动强制类型转换的（coerced）。&lt;/p&gt;

&lt;p&gt;关于如何从一个根操作自动生成顺序判定操作，可以参考 &lt;code&gt;functools.total_ordering()&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__hash__(self)&lt;br /&gt;
由内建函式&lt;code&gt;hash()&lt;/code&gt;，或者是在可散列集合（&lt;code&gt;hashed collections&lt;/code&gt;，包括 set，frozenset，dict）成员上的操作调用。这个方法应该返回一个整数。只有一个要求，具有相同值的对象应该有相同的散列值。应该考虑以某种方式（例如排斥或）把在对象比较中起作用的部分与散列值关联起来。&lt;/p&gt;

&lt;p&gt;如果类没有定义&lt;code&gt;__eq__()&lt;/code&gt;方法，那么它也不应该定义&lt;code&gt;__hash__()&lt;/code&gt;方法；如果一个类只定义了&lt;code&gt;__eq__()&lt;/code&gt;方法，那么它是不适合作散列键的。如果可变对象实现了&lt;code&gt;__eq__()&lt;/code&gt;方法，它也不应该实现&lt;code&gt;__hash__()&lt;/code&gt;方法，因为可散列集合要求键值是不可变的(如果对象的散列值发生了改变，它会被放在错误的桶（bucket）中）。&lt;/p&gt;

&lt;p&gt;所有用户定义类默认都定义了方法&lt;code&gt;__eq__()&lt;/code&gt;和&lt;code&gt;__hash__()&lt;/code&gt;，这样，所有对象都可以进行相等比较（除了与自身比较）。&lt;code&gt;x.__hash__()&lt;/code&gt;返回&lt;code&gt;id(x)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果子类从父类继承了方法&lt;code&gt;__hash__()&lt;/code&gt;，但修改了&lt;code&gt;__eq__()&lt;/code&gt;，这时子类继承的散列值就不再正确了（例如，可能从默认的标识相等的比较切换成了值相等的比较），这时在在类定义时显式地将&lt;code&gt;__hash__()&lt;/code&gt;设置成&lt;code&gt;None&lt;/code&gt;就行了。这样，在使用这个子类对象作为散列键时就会抛出&lt;code&gt;TypeError&lt;/code&gt;异常，或者也可以使用常规的可散列检查&lt;code&gt;isinstance(obj, collections.Hashable)&lt;/code&gt;确定它的不可散列性（使用这种检查方式时，这种达到不可散列的方法与在&lt;code&gt;__hash__()&lt;/code&gt;中显式抛出异常的方法是的计算结果就不一样了）。&lt;/p&gt;

&lt;p&gt;如果子类修改了&lt;code&gt;__eq__()&lt;/code&gt;方法，但需要保留父类的&lt;code&gt;__hash__()&lt;/code&gt;，它必须显式地告诉解释器&lt;code&gt;__hash__ = &amp;lt;ParentClass&amp;gt;.__hash__&lt;/code&gt;，否则&lt;code&gt;__hash__()&lt;/code&gt;的继承会被阻止，就像设置&lt;code&gt;__hash__&lt;/code&gt;为&lt;code&gt;None&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__bool__(self)&lt;br /&gt;
在实现真值测试和内建操作&lt;code&gt;bool()&lt;/code&gt;中调用，应该返回&lt;code&gt;False&lt;/code&gt;和&lt;code&gt;True&lt;/code&gt;。如果没有这个定义方法，转而使用&lt;code&gt;__len__()&lt;/code&gt;。非零返回值，当作“真”。如果这两个方法都没有定义，就认为该实例为“真”。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-2-定制访问属性&#34;&gt;3.2 定制访问属性&lt;/h4&gt;

&lt;p&gt;以下方法可以用于定制访问类实例属性的含义（例如，赋值，或删除&lt;code&gt;x.name&lt;/code&gt;）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;object.__getattr__(self, name)&lt;br /&gt;
在正常方式访问属性无法成功时（就是说，self属性既不是实例的，在类树结构中找不到）使用。&lt;code&gt;name&lt;/code&gt;是属性名。应该返回一个计算好的属性值，或抛出一个&lt;code&gt;AttributeError&lt;/code&gt;异常。&lt;/p&gt;

&lt;p&gt;注意，如果属性可以通过正常方法访问，&lt;code&gt;__getattr__()&lt;/code&gt;是不会被调用的（是有意将&lt;code&gt;__getattr__()&lt;/code&gt;和&lt;code&gt;__setattr__()&lt;/code&gt;设计成不对称的）。这样做的原因是基于效率的考虑，并且这样也不会让&lt;code&gt;__getattr__()&lt;/code&gt;干涉正常属性。注意，至少对于类实例而言，不必非要更新实例字典伪装属性（但可以将它们插入到其它对象中）。需要全面控制属性访问，可以参考以下&lt;code&gt;__getattribute__()&lt;/code&gt;的介绍。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__getattribute__(self, name)&lt;br /&gt;
在访问类实例的属性时无条件调用这个方法。如果类也定义了方法 &lt;code&gt;__getattr__()&lt;/code&gt;，那么除非&lt;code&gt;__getattribute__()&lt;/code&gt;显式地调用了它，或者抛出了&lt;code&gt;AttributeError&lt;/code&gt;异常，否则它就不会被调用。这个方法应该返回一个计算好的属性值，或者抛出异常&lt;code&gt;AttributeError&lt;/code&gt;。为了避免无穷递归，对于任何它需要访问的属性，这个方法应该调用基类的同名方法，例如，&lt;code&gt;object.__getattribute__(self, name)&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Note：但是，通过特定语法或者内建函式，做隐式调用搜索特殊方法时，这个方法可能会被跳过。参见 搜索特殊方法。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__setattr__(self, name, value)&lt;br /&gt;
在属性要被赋值时调用。这会替代正常机制（即把值保存在实例字典中）。&lt;code&gt;name&lt;/code&gt;是属性名，&lt;code&gt;vaule&lt;/code&gt;是要赋的值。&lt;/p&gt;

&lt;p&gt;如果在&lt;code&gt;__setattr__()&lt;/code&gt;里要对一个实例属性赋值，它应该调用父类的同名方法，例如，&lt;code&gt;object.__setattr__(self, name, value)&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__delattr__(self, name)&lt;br /&gt;
与&lt;code&gt;__setattr__()&lt;/code&gt;类似，但它的功能是删除属性。当&lt;code&gt;del obj.name&lt;/code&gt;对对象有意义时，才需要实现它。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__dir__(self)&lt;br /&gt;
在对象上调用&lt;code&gt;dir()&lt;/code&gt;时调用，它需要返回一个序列。&lt;code&gt;dir()&lt;/code&gt;会将返回的序列转成一个列表，并进行排序。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;3-2-1-实现描述符&#34;&gt;3.2.1 实现描述符&lt;/h5&gt;

&lt;p&gt;含有所有者类&lt;code&gt;owner class&lt;/code&gt;中的方法的类被叫做描述符类，下边的方法只会出现在描述符类的实例中。描述符要么在所有者的类字典中，或者在他们父类的类字典中。在下面的例子里，“属性”指名字出现在所有者类&lt;code&gt;__dict__&lt;/code&gt;中的属性。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;object.__get__(self, instance, owner)
调用这个方法可以获得所有者类中的属性（获取类属性）也可以获取类的实例的属性（获取实例属性）。&lt;code&gt;owner&lt;/code&gt;是所有者类，当&lt;code&gt;instance&lt;/code&gt;是&lt;code&gt;None&lt;/code&gt;时从&lt;code&gt;owner&lt;/code&gt;中获取属性，当&lt;code&gt;instance&lt;/code&gt;是一个实例时从&lt;code&gt;instance&lt;/code&gt;中获取属性。这个方法应该返回属性值，或者产生&lt;code&gt;AttributeError&lt;/code&gt;异常。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__set__(self, instance, value)&lt;br /&gt;
调用这个方法可以为所有者类的实例&lt;code&gt;instance&lt;/code&gt;的属性设置新值&lt;code&gt;value&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__delete__(self, instance)&lt;br /&gt;
调用这个方法来删除所有者类实例&lt;code&gt;instance&lt;/code&gt;中的属性。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;3-2-2-使用描述&#34;&gt;3.2.2 使用描述&lt;/h5&gt;

&lt;h5 id=&#34;3-2-3-slots&#34;&gt;3.2.3 __slots__&lt;/h5&gt;

&lt;p&gt;默认情况下，类实例使用字典管理属性。在对象只有少量实例变量时这就会占用不少空间。当有大量实例时，空间消耗会变得更为严重。&lt;/p&gt;

&lt;p&gt;这个默认行为可以通过在类定义中定义&lt;code&gt;__slots__&lt;/code&gt;修改。&lt;code&gt;__slots__&lt;/code&gt;声明只为该类的所有实例预留刚刚够用的空间。因为不会为每个实例创建&lt;code&gt;__dict__&lt;/code&gt;，因此空间节省下来了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;object.__slots__&lt;br /&gt;
这个类变量可以赋值为一个字符串，一个可迭代对象。或者一个字符串序列（每个字符串表示实例所用的变量名）。如果定义了&lt;code&gt;__slots__&lt;/code&gt;，Python就会为实例预留出存储声明变量的空间，并且不会为每个实例自动创建&lt;code&gt;__dict__&lt;/code&gt;和&lt;code&gt;__weakref__&lt;/code&gt;。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;3-2-3-1-使用-slots-的注意事项&#34;&gt;3.2.3.1 使用__slots__的注意事项&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;如果从一个没有定义&lt;code&gt;__slots__&lt;/code&gt;的基类继承，子类一定存在&lt;code&gt;__dict__&lt;/code&gt;属性。所以，在这种子类中定义&lt;code&gt;__slots__&lt;/code&gt;是没有意义的。&lt;/li&gt;
&lt;li&gt;没有定义&lt;code&gt;__dict__&lt;/code&gt;的实例不支持对不在&lt;code&gt;__slot__&lt;/code&gt;中的属性赋值。如果需要支持这个功能, 可以把&lt;code&gt;__dict__&lt;/code&gt;放到&lt;code&gt;__slots__&lt;/code&gt;声明中。&lt;/li&gt;
&lt;li&gt;没有定义&lt;code&gt;__weakref__&lt;/code&gt;的，使用&lt;code&gt;__slot__&lt;/code&gt;的实例不支持对它的 “弱引用”。如果需要支持弱引用，可以把&lt;code&gt;__weakref__&lt;/code&gt;放到&lt;code&gt;__slots__&lt;/code&gt;声明中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__slots__&lt;/code&gt;是在类这一级实现的，通过为每个实例创建描述符 (实现描述符)。因此，不能使用类属性为实例的&lt;code&gt;__slots__&lt;/code&gt;中定义的属性设置默认值。否则，类属性会覆盖描述符的赋值操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__slots__&lt;/code&gt;声明的行为只限于其定义所在的类。因此，如果子类没有定义自己的&lt;code&gt;__slots__&lt;/code&gt;(它必须只包括那些 额外的&lt;code&gt;slots&lt;/code&gt;)，子类仍然会使用&lt;code&gt;__dict__&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果类定义的&lt;code&gt;slot&lt;/code&gt;与父类中的相同，那么父类&lt;code&gt;slot&lt;/code&gt;中的变量将成为不可访问的 (除非直接从基类中获取描述符)。这使得程序行为变得有一点模糊，以后可能会增加一个防止出现这种情况的检查。&lt;/li&gt;
&lt;li&gt;从“变长”内建类型，例如&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;str&lt;/code&gt;和&lt;code&gt;tuple&lt;/code&gt;继承的子类的非空&lt;code&gt;__slots__&lt;/code&gt;不会起作用。&lt;/li&gt;
&lt;li&gt;任何非字符串可迭代对象都可以赋给&lt;code&gt;__slots__&lt;/code&gt;。映射类型也是允许的，但是，以后版本的Python可能给 “键” 赋予特殊意义。&lt;/li&gt;
&lt;li&gt;只有在两个类的&lt;code&gt;__slots__&lt;/code&gt;相同时，&lt;code&gt;__class__&lt;/code&gt;赋值才会正常工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-3-定制类的生成&#34;&gt;3.3 定制类的生成&lt;/h4&gt;

&lt;p&gt;默认情况下，类是由&lt;code&gt;type()&lt;/code&gt;来构建的。类的实体是在新的名字空间中执行，而且类的名字是与&lt;code&gt;type(name, bases, namespace)&lt;/code&gt;的结果绑定的。&lt;br /&gt;
类的创建过程可以通过在类声明的时候指定&lt;code&gt;metaclass&lt;/code&gt;定制，也可以通过继承已有的、包含这个参数的类来实现。在下边的例子中&lt;code&gt;MyClass&lt;/code&gt;和&lt;code&gt;MySubclass&lt;/code&gt;都是&lt;code&gt;Meta&lt;/code&gt;的实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Meta(type):
    pass

class MyClass(metaclass=Meta):
    pass

class MySubclass(MyClass):
    pass  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他在类定义中使用到的关键字变量，都会被传递到下边描述的所有的&lt;code&gt;metaclass&lt;/code&gt;操作中。&lt;br /&gt;
当一个类定义执行时，会执行如下操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;选择合适的metaclass&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;准备类的名字空间&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;执行类的内容（body）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;创建类对象&lt;br /&gt;

&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;3-3-1-选择合适的-metaclass&#34;&gt;3.3.1 选择合适的&lt;code&gt;Metaclass&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;下面定义了什么样的的&lt;code&gt;metaclass&lt;/code&gt;对于一个类定义来说是合适的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果没有定义基类，也没有特别指定&lt;code&gt;metaclass&lt;/code&gt;，那么就使用&lt;code&gt;type()&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果给定一个&lt;code&gt;metaclass&lt;/code&gt;，而且它不是&lt;code&gt;type()&lt;/code&gt;的实例，那么它就被直接用作&lt;code&gt;metaclass&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果给定一个&lt;code&gt;type()&lt;/code&gt;的实例作为&lt;code&gt;metaclass&lt;/code&gt;，或者定义了基类, 那就使用最底层的&lt;code&gt;metaclass&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;底层&lt;code&gt;metaclass&lt;/code&gt;是从给定的&lt;code&gt;metaclass&lt;/code&gt;和所有基类的metaclass中选出的。底层&lt;code&gt;metaclass&lt;/code&gt;是所有候选&lt;code&gt;metaclass&lt;/code&gt;的子类型。如果候选&lt;code&gt;metaclass&lt;/code&gt;中没有一个满足条件，那么类定义就会失败，并抛出&lt;code&gt;TypeError&lt;/code&gt;异常。&lt;/p&gt;

&lt;h5 id=&#34;3-3-2-准备类的名字空间&#34;&gt;3.3.2 准备类的名字空间&lt;/h5&gt;

&lt;p&gt;一旦合适的&lt;code&gt;metaclass&lt;/code&gt;被确认后，类的名字空间就准备好了。如果&lt;code&gt;metaclass&lt;/code&gt;有&lt;code&gt;__prepare__&lt;/code&gt;属性，就执行&lt;code&gt;namespace = metaclass.__prepare__(name, bases, **kwds)&lt;/code&gt;(其中的关键字参数，是来自类定义里的)。&lt;/p&gt;

&lt;p&gt;如果&lt;code&gt;metaclass&lt;/code&gt;没有&lt;code&gt;__prepare__&lt;/code&gt;属性，那么类的名字空间就被初始化为一个空的字典实例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;See also
PEP 3115 - Metaclasses in Python 3000
Introduced the __prepare__ namespace hook
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;3-3-3-执行类的内容-body&#34;&gt;3.3.3 执行类的内容（body）&lt;/h5&gt;

&lt;p&gt;类的&lt;code&gt;body&lt;/code&gt;是以类似&lt;code&gt;exec(body, globals(), namespace)&lt;/code&gt;的方式执行的。与普通调用&lt;code&gt;exec()&lt;/code&gt;的主要区别在于，当类定义发生在一个函数内部时，词法作用域允许类的&lt;code&gt;body&lt;/code&gt;（包括任何的函数）引用任何当前或者外部作用域的名称。&lt;/p&gt;

&lt;p&gt;尽管里的定义发生在&lt;code&gt;exec&lt;/code&gt;函数里，但是类中定义的方法仍然无法看到类中的其它名字。如果要使用类的变量必须通过实例或类方法的第一个参数，而且不能被静态静态方法使用。&lt;/p&gt;

&lt;h5 id=&#34;3-3-4-创建类对象&#34;&gt;3.3.4 创建类对象&lt;/h5&gt;

&lt;p&gt;当类的内容被执行，并构成了类的名字空间后，类对象就通过调用&lt;code&gt;metaclass(name, bases, namespace, **kwds)&lt;/code&gt;创建好了(传递到这里的关键字变量与传递到&lt;code&gt;__prepare__&lt;/code&gt;中的一样)。&lt;/p&gt;

&lt;p&gt;一个类对象的引用保存在不含参的&lt;code&gt;super().__class__&lt;/code&gt;里，它是一个由编译器创建的隐藏的闭包，任何类&lt;code&gt;body&lt;/code&gt;中的方法都可以被&lt;code&gt;__class__&lt;/code&gt;或者&lt;code&gt;super&lt;/code&gt;引用。这样的话，如果当前的调用需要使用传递到方法中的第一个参数来识别类或对象时，执行调用的类或者实例这样无参的&lt;code&gt;super()&lt;/code&gt;就可以正确的识别那些在词法作用域定义的类。&lt;/p&gt;

&lt;p&gt;当类对象被创建后，它被传递给类中的的装饰器，作为结果的类对象会被绑定在本地名字空间中作为定义好的类。&lt;/p&gt;

&lt;p&gt;当一个新的类通过&lt;code&gt;type.__new__&lt;/code&gt;被创建，新的类对象将名字空间参数复制到一个标准的Python字典中，然后将原始的类对象抛弃。新复制的字典成为类对象的&lt;code&gt;__dict__&lt;/code&gt;属性。&lt;/p&gt;

&lt;h5 id=&#34;3-3-5-metaclass-实例&#34;&gt;3.3.5 &lt;code&gt;Metaclass&lt;/code&gt;实例&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;metaclass&lt;/code&gt;的使用方式是五花八门的。有些方法已经被验证过了比如，日志、接口检查、自动授权、自动创建参数、代理、框架、自动资源锁／同步。&lt;/p&gt;

&lt;p&gt;这里给出一个&lt;code&gt;metaclass&lt;/code&gt;的例子，使用&lt;code&gt;collections.OrderedDict&lt;/code&gt;来记录类中的变量被创建的顺序。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class OrderedClass(type):  
    @classmethod  
    def __prepare__(metacls, name, bases, **kwds):  
        return collections.OrderedDict()  

    def __new__(cls, name, bases, namespace, **kwds):  
        result = type.__new__(cls, name, bases, dict(namespace))  
        result.members = tuple(namespace)  
        return result  

class A(metaclass=OrderedClass):  
    def one(self): pass  
    def two(self): pass  
    def three(self): pass  
    def four(self): pass  

&amp;gt;&amp;gt;&amp;gt; A.members  
(&#39;__module__&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当执行&lt;code&gt;A&lt;/code&gt;的类定义时，首先执行&lt;code&gt;metaclass&lt;/code&gt;的&lt;code&gt;__prepare__()&lt;/code&gt;方法，这个方法返回一个空的&lt;code&gt;collections.OrderedDict&lt;/code&gt;。这个字典会记录类&lt;code&gt;A&lt;/code&gt;中定义的方法和属性。当这些定义执行完，这个有序字段就成为类的一部分，然后&lt;code&gt;__new__()&lt;/code&gt;开始被调用。这个方法会创建新的&lt;code&gt;type&lt;/code&gt;类型，将有序字典的&lt;code&gt;key&lt;/code&gt;保存到这个类型的属性&lt;code&gt;memebers&lt;/code&gt;中。&lt;/p&gt;

&lt;h4 id=&#34;3-4-定制实例和子类的检查&#34;&gt;3.4 定制实例和子类的检查&lt;/h4&gt;

&lt;p&gt;以下函数可以用于定制内建函式&lt;code&gt;isinstance()&lt;/code&gt;和&lt;code&gt;issubclass()&lt;/code&gt;的默认行为。&lt;/p&gt;

&lt;p&gt;具体地，元类&lt;code&gt;abc.ABCMeta&lt;/code&gt;实现了这些方法，以允许把抽象基类（ABC）作为任何类或者类型（包括内建类型），也包括其他ABC的“虚拟基类”。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;class.__instancecheck__(self, instance)&lt;br /&gt;
如果&lt;code&gt;instance&lt;/code&gt;应该被看作&lt;code&gt;class&lt;/code&gt;的一个直接或者间接的实例，就返回真。如果定义了这个方法, 它就会被用于实现&lt;code&gt;isinstance(instance, class)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;class.__subclasscheck__(self, subclass)&lt;br /&gt;
如果&lt;code&gt;subclass&lt;/code&gt;应该被看作是&lt;code&gt;class&lt;/code&gt;的一个直接或者间接的基类，就返回真。如果定义了这个方法，它就会被用于实现&lt;code&gt;issubclass(subclass, class)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意，这个方法会在一个类的类型（元类）中查找。它们不能作为一个类方法在类中定义。这个机制，与在实例上查找要调用的特殊方法的机制是一致的，因为在这个情况下实例本身就是一个类。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;See also:
PEP 3119 - Introducing Abstract Base Classes　 (抽象基类介绍)
包括定制通过 __instancecheck__() 和 __subclasscheck__()　定制 isinstance() 和 issubclass() 行为的规范，以及在语言上增加抽象基类 (见 abc 模块) 这个背景设置这个功能的动机。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-5-模拟可调用对象&#34;&gt;3.5 模拟可调用对象&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;object.__call__(self[, args&amp;hellip;])&lt;br /&gt;
当实例作为函式使用时调用本方法。如果定义了这个方法，&lt;code&gt;x(arg1, arg2,...)&lt;/code&gt;就相当于&lt;code&gt;x.__call__(arg1, arg2,...)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-6-模拟容器类型&#34;&gt;3.6 模拟容器类型&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;object.__len__(self)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;object.__length_hint__(self)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;object.__getitem__(self, key)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;object.__missing__(self, key)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;object.__setitem__(self, key, value)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;object.__delitem__(self, key)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;object.__iter__(self)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;object.__reversed__(self)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;object.__contains__(self, item)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-7-模拟数字类型&#34;&gt;3.7 模拟数字类型&lt;/h4&gt;

&lt;p&gt;以下方法用于模拟数值类型。不同数值类型所支持的操作符并不完全相同，如果一个类型不支持某些操作符（例如非整数值上的位运算），对应的方法就不应该被实现。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;object.__add__(self, other)&lt;br /&gt;
object.__sub__(self, other)&lt;br /&gt;
object.__mul__(self, other)&lt;br /&gt;
object.__matmul__(self, other)&lt;br /&gt;
object.__truediv__(self, other)&lt;br /&gt;
object.__floordiv__(self, other)&lt;br /&gt;
object.__mod__(self, other)&lt;br /&gt;
object.__divmod__(self, other)&lt;br /&gt;
object.__pow__(self, other[, modulo])&lt;br /&gt;
object.__lshift__(self, other)&lt;br /&gt;
object.__rshift__(self, other)&lt;br /&gt;
object.__and__(self, other)&lt;br /&gt;
object.__xor__(self, other)&lt;br /&gt;
object.__or__(self, other)&lt;br /&gt;
这些方法用于二元算术操作（+，-，*，/，//，%，divmod()，pow()，**，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;，&amp;amp;，^，|）。 例如，在计算表达式&lt;code&gt;x + y&lt;/code&gt;时,&lt;code&gt;x&lt;/code&gt;是一个定义了&lt;code&gt;__add__()&lt;/code&gt;的类的实例，那么就会调用&lt;code&gt;x.__add__(y)&lt;/code&gt;。方法&lt;code&gt;__divmod__()&lt;/code&gt;应该与使用 &lt;code&gt;__floordiv__()&lt;/code&gt;和&lt;code&gt;__mod__()&lt;/code&gt;的结果相同，但应该与&lt;code&gt;__truediv__()&lt;/code&gt;无关。注意如果要支持三参数版本的内建函式&lt;code&gt;pow()&lt;/code&gt;的话，方法&lt;code&gt;__pow__()&lt;/code&gt;应该被定义成可以接受第三个可选参数的。&lt;/p&gt;

&lt;p&gt;如果以上任一方法无法处理根据参数完成计算的话，就应该返回&lt;code&gt;NotImplemented&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__radd__(self, other)&lt;br /&gt;
object.__rsub__(self, other)&lt;br /&gt;
object.__rmul__(self, other)&lt;br /&gt;
object.__rmatmul__(self, other)&lt;br /&gt;
object.__rtruediv__(self, other)&lt;br /&gt;
object.__rfloordiv__(self, other)&lt;br /&gt;
object.__rmod__(self, other)&lt;br /&gt;
object.__rdivmod__(self, other)&lt;br /&gt;
object.__rpow__(self, other)&lt;br /&gt;
object.__rlshift__(self, other)&lt;br /&gt;
object.__rrshift__(self, other)&lt;br /&gt;
object.__rand__(self, other)&lt;br /&gt;
object.__rxor__(self, other)&lt;br /&gt;
object.__ror__(self, other)&lt;br /&gt;
这些方法用于实现二元算术操作（+，-，*，/，//，%，divmod()，pow()，**，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;，&amp;amp;，^，|），但用于操作数反射（即参数顺序是相反的）。这些函式只有在左操作数不支持相应操作，并且是参数是不同类型时才会被使用。例如，计算表达式&lt;code&gt;x - y&lt;/code&gt;，&lt;code&gt;y&lt;/code&gt;是一个定义了方法&lt;code&gt;__rsub__()&lt;/code&gt;的类实例，那么在 x.&lt;strong&gt;sub&lt;/strong&gt;(y) 返回&lt;code&gt;NotImplemented&lt;/code&gt;时才会调用&lt;code&gt;y.__rsub__(x)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;注意三参数版本的&lt;code&gt;pow()&lt;/code&gt;不会试图调用&lt;code&gt;__rpow__()&lt;/code&gt;。（这会导致类型自动转换规则过于复杂）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__iadd__(self, other)&lt;br /&gt;
object.__isub__(self, other)&lt;br /&gt;
object.__imul__(self, other)&lt;br /&gt;
object.__imatmul__(self, other)&lt;br /&gt;
object.__itruediv__(self, other)&lt;br /&gt;
object.__ifloordiv__(self, other)&lt;br /&gt;
object.__imod__(self, other)&lt;br /&gt;
object.__ipow__(self, other[, modulo])&lt;br /&gt;
object.__ilshift__(self, other)&lt;br /&gt;
object.__irshift__(self, other)&lt;br /&gt;
object.__iand__(self, other)&lt;br /&gt;
object.__ixor__(self, other)&lt;br /&gt;
object.__ior__(self, other)&lt;br /&gt;
这些方法用于实现参数化算术赋值操作（+=，-=，*=，/=，//=，%=，**=，&amp;lt;&amp;lt;=，&amp;gt;&amp;gt;=，&amp;amp;=，^=，|=）。这些方法应该是就地操作的（即直接修改&lt;code&gt;self&lt;/code&gt;）并返回结果（一般来讲，这里应该是对&lt;code&gt;self&lt;/code&gt;直接操作，但并不是一定要求如此）。如果没有实现某个对应方法的话，参数化赋值会蜕化为正常方法。例如，执行语句&lt;code&gt;x += y&lt;/code&gt;时，&lt;code&gt;x&lt;/code&gt;是一个实现了 &lt;code&gt;__iadd__()&lt;/code&gt;方法的实例，&lt;code&gt;x.__iadd__(y)&lt;/code&gt;就会被调用。如果&lt;code&gt;x&lt;/code&gt;没有定义 &lt;code&gt;__iadd__()&lt;/code&gt;，就会选择&lt;code&gt;x.__add__(y)&lt;/code&gt;或者&lt;code&gt;y.__radd__(x)&lt;/code&gt;，与&lt;code&gt;x + y&lt;/code&gt;类似。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__neg__(self)&lt;br /&gt;
object.__pos__(self)&lt;br /&gt;
object.__abs__(self)&lt;br /&gt;
object.__invert__(self)&lt;br /&gt;
用于实现一元算术操作（-，+，&lt;code&gt;abs()&lt;/code&gt;和~）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__complex__(self)&lt;br /&gt;
object.__int__(self)&lt;br /&gt;
object.__float__(self)&lt;br /&gt;
object.__round__(self[, n])&lt;br /&gt;
用于实现内建函式&lt;code&gt;complex()&lt;/code&gt;，&lt;code&gt;int()&lt;/code&gt;，&lt;code&gt;float()&lt;/code&gt;和&lt;code&gt;round()&lt;/code&gt;。应该返回对应的类型值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__index__(self)&lt;br /&gt;
用于实现函式&lt;code&gt;operator.index()&lt;/code&gt;，或者在Python需要一个整数对象时调用（例如在分片时（slicing），或者在内建函式函式&lt;code&gt;bin()&lt;/code&gt;，&lt;code&gt;hex()&lt;/code&gt;和&lt;code&gt;oct()&lt;/code&gt;中）。这个方法必须返回一个整数。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-8-with语句和上下文管理器&#34;&gt;3.8 With语句和上下文管理器&lt;/h4&gt;

&lt;p&gt;上下文管理器&lt;code&gt;context manager&lt;/code&gt;是一个对象，这个对象定义了执行&lt;code&gt;with&lt;/code&gt;语句时要建立的运行时上下文。上下文管理器负责处理执行某代码块时对应的运行时上下文进入和退出。运行时上下文的使用一般通过&lt;code&gt;with&lt;/code&gt;语句（参见&lt;code&gt;with&lt;/code&gt;语句），但也可以直接调用它的方法。&lt;/p&gt;

&lt;p&gt;上下文管理器的典型用途包括保存和恢复各种全局状态，锁定和解锁资源，关闭打开的文件等等。&lt;/p&gt;

&lt;p&gt;关于上下文管理的更多信息，可以参考 Context Manager Types。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;object.__enter__(self)&lt;br /&gt;
进入与这个对象关联的运行时上下文。&lt;code&gt;with&lt;/code&gt;语句会把这个方法的返回值与&lt;code&gt;as&lt;/code&gt;子句指定的目标绑定在一起 (如果指定了的话)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.__exit__(self, exc_type, exc_value, traceback)&lt;br /&gt;
退出与这个对象相关的运行时上下文。参数描述了导致上下文退出的异常，如果是无异常退出，则这三个参数都为&lt;code&gt;None&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果给出了一个异常，而这个方法决定要压制它（即防止它把传播出去），那么它应该返回真。否则，在退出这个方法时，这个异常会按正常方式处理。&lt;/p&gt;

&lt;p&gt;注意方法&lt;code&gt;__exit__()&lt;/code&gt;不应该把传入的异常重新抛出，这是调用者的责任。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;See also
PEP 0343 - The “with” statement（“with” 语句）
Python with 语句的规范，背景和例子。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-9-搜索特殊方法&#34;&gt;3.9 搜索特殊方法&lt;/h4&gt;

&lt;p&gt;对于定制类，只有在对象类型的字典里定义好，才能保证成功调用特殊方法。这是以下代码发生异常的原因：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class C:
...     pass
...
&amp;gt;&amp;gt;&amp;gt; c = C()
&amp;gt;&amp;gt;&amp;gt; c.__len__ = lambda: 5
&amp;gt;&amp;gt;&amp;gt; len(c)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: object of type &#39;C&#39; has no len()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个行为的原因在于，有不少特殊方法在所有对象中都得到了实现，例如&lt;code&gt;__hash__()&lt;/code&gt;和&lt;code&gt;__repr__()&lt;/code&gt;。如果按照常规的搜索过程搜索这些方法，在涉及到类型对象时就会出错。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 1.__hash__() == hash(1)
True
&amp;gt;&amp;gt;&amp;gt; int.__hash__() == hash(int)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: descriptor &#39;__hash__&#39; of &#39;int&#39; object needs an argument
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;试图以这种错误方式调用一个类的未绑定方法有时叫作&lt;code&gt;metaclass confusion&lt;/code&gt;，可以通过在搜索特殊方法时跳过实例避免：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; type(1).__hash__(1) == hash(1)
True
&amp;gt;&amp;gt;&amp;gt; type(int).__hash__(int) == hash(int)
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了因为正确性的原因而跳过实例属性之外，特殊方法搜索也会跳过&lt;code&gt;__getattribute__()&lt;/code&gt;方法，甚至是元类中的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Meta(type):
...    def __getattribute__(*args):
...       print(&amp;quot;Metaclass getattribute invoked&amp;quot;)
...       return type.__getattribute__(*args)
...
&amp;gt;&amp;gt;&amp;gt; class C(object, metaclass=Meta):
...     def __len__(self):
...         return 10
...     def __getattribute__(*args):
...         print(&amp;quot;Class getattribute invoked&amp;quot;)
...         return object.__getattribute__(*args)
...
&amp;gt;&amp;gt;&amp;gt; c = C()
&amp;gt;&amp;gt;&amp;gt; c.__len__()                 # Explicit lookup via instance
Class getattribute invoked
10
&amp;gt;&amp;gt;&amp;gt; type(c).__len__(c)          # Explicit lookup via type
Metaclass getattribute invoked
10
&amp;gt;&amp;gt;&amp;gt; len(c)                      # Implicit lookup
10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种跳过&lt;code&gt;__getattribute__()&lt;/code&gt;的机制为解释器的时间性能优化提供了充分的余地，代价是牺牲了处理特殊方法时的部分灵活性（为了保持与解释器的一致，特殊方法必须在类对象中定义）。&lt;/p&gt;

&lt;h1 id=&#34;4-coroutines&#34;&gt;4. Coroutines&lt;/h1&gt;

&lt;h6 id=&#34;4-1-可等待对象&#34;&gt;4.1. 可等待对象&lt;/h6&gt;

&lt;p&gt;一个可等待对象一般会实现方法&lt;code&gt;__await__()&lt;/code&gt;。由&lt;code&gt;async def&lt;/code&gt;函数返回的&lt;code&gt;coroutine&lt;/code&gt;对象都是可等待的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;注意：被`types.coroutine()`或者`asyncio.coroutine()`修饰的，由生成器创建的迭代器对象也是可等待的。但是它并没有实现`__await__()`
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;object.&lt;strong&gt;await&lt;/strong&gt;(self)&lt;br /&gt;
必须返回一个迭代器。用来实现可等待对象。对于实例，&lt;code&gt;asyncio.Future&lt;/code&gt;实现了这个方法，来兼容等待表达式。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在Python 3.5版中中新增。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```
See also PEP 492 for additional information about awaitable objects.
```
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;4-2-协程对象&#34;&gt;4.2. 协程对象&lt;/h6&gt;

&lt;p&gt;协程对象都是可等待对象。一个协程的执行是可以通过&lt;code&gt;__await__()&lt;/code&gt;和遍历结果集来控制的。当协程结束并返回时，迭代器抛出&lt;code&gt;StopIteration&lt;/code&gt;异常，异常的值属性就是这个返回值。如果协程抛出异常，它会通过迭代器传播。协程不应该直接抛出未经捕获的&lt;code&gt;StopIteration&lt;/code&gt;异常。&lt;/p&gt;

&lt;p&gt;就像生成器一样，协程还有下边这些方法（详情查看，生成器-迭代器方法）。但是和生成器不一样，协程不能直接支持迭代操作。&lt;/p&gt;

&lt;p&gt;在Python 3.5.2中的修改：&lt;code&gt;RuntimeError&lt;/code&gt;会多次等待协程。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;coroutine.send(value)&lt;br /&gt;
开始或者恢复协程的运行。如果&lt;code&gt;value&lt;/code&gt;为&lt;code&gt;None&lt;/code&gt;。如果&lt;code&gt;value&lt;/code&gt;不是&lt;code&gt;None&lt;/code&gt;，这个方法会调用导致这个协程挂起的迭代器的&lt;code&gt;send()&lt;/code&gt;方法。结果（返回值、&lt;code&gt;StopIteration&lt;/code&gt;、或其它异常）与迭代时&lt;code&gt;__await__()&lt;/code&gt;的返回值时一样的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;coroutine.throw(type[, value[, traceback]])&lt;br /&gt;
在协程中抛出指定异常。这个方法会调用造成协程挂起的迭代器的&lt;code&gt;throw&lt;/code&gt;方法，如果这个迭代器有这个方法。否则就在挂起位置抛出异常。结果（返回值、&lt;code&gt;StopIteration&lt;/code&gt;、或其它异常）与迭代时&lt;code&gt;__await__()&lt;/code&gt;的返回值时一样的。如果协程中没有捕获异常，它会传递给调用者。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;coroutine.close()&lt;br /&gt;
调用这个方法将导致协程被清理并退出。如果协程已被挂起，要先执行造成协程挂起的迭代器的&lt;code&gt;close&lt;/code&gt;函数，如果迭代器有这个函数的话。然后它会在挂起位置抛出&lt;code&gt;GeneratorExit&lt;/code&gt;异常，这会造成协程立刻清理自己。最后，这个协程被标记为已完成，哪怕它从来没有执行过。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;4-3-异步迭代器&#34;&gt;4.3. 异步迭代器&lt;/h6&gt;

&lt;p&gt;一个异步迭代器可以调用在实现它的&lt;code&gt;__aiter__&lt;/code&gt;时，调用异步代码，一个异步迭代器可以在它的&lt;code&gt;__anext__&lt;/code&gt;方法里调用异步代码。&lt;/p&gt;

&lt;p&gt;异步迭代器可以在&lt;code&gt;async for&lt;/code&gt;语句中使用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;object.&lt;strong&gt;aiter&lt;/strong&gt;(self)&lt;br /&gt;
必须返回一个异步迭代器对象。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.&lt;strong&gt;anext&lt;/strong&gt;(self)&lt;br /&gt;
迭代器返回的下一个值必须是一个可等待的，当迭代操作结束时会抛出一个&lt;code&gt;StopAsyncIteration&lt;/code&gt;错误。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;异步迭代器的例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Reader:
    async def readline(self):
        ...

    def __aiter__(self):
        return self

    async def __anext__(self):
        val = await self.readline()
        if val == b&#39;&#39;:
            raise StopAsyncIteration
        return val
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Python 3.5版中中新增。&lt;/p&gt;

&lt;h6 id=&#34;4-4-异步上下文管理器&#34;&gt;4.4. 异步上下文管理器&lt;/h6&gt;

&lt;p&gt;异步上下文管理器可以在它的&lt;code&gt;__aenter__&lt;/code&gt;和&lt;code&gt;__aexit__&lt;/code&gt;方法中延迟执行。&lt;/p&gt;

&lt;p&gt;异步上下文管理器可以在&lt;code&gt;async with&lt;/code&gt;语句中使用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;object.&lt;strong&gt;aenter&lt;/strong&gt;(self)&lt;br /&gt;
这个方法在语义上与&lt;code&gt;__enter__()&lt;/code&gt;类似，唯一的区别就是它必须返回一个可等待对象。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;object.&lt;strong&gt;aexit&lt;/strong&gt;(self, exc_type, exc_value, traceback)&lt;br /&gt;
这个方法在语义上与&lt;code&gt;__exit__()&lt;/code&gt;类似，唯一的区别就是它必须返回一个可等待对象。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;异步上下文管理器的例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AsyncContextManager:
    async def __aenter__(self):
        await log(&#39;entering context&#39;)

    async def __aexit__(self, exc_type, exc, tb):
        await log(&#39;exiting context&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Python 3.5版中中新增。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;注意：
在Python 3.5.2版中的修改: 从CPython 3.5.2开始，__aiter__ 可以返回异步迭代器。返回一个可等待对象会导致 PendingDeprecationWarning 。

在CPython 3.5.x中为了保证向后兼容，推荐继续返回可等待对象在 __aiter__ 中。如果你想避免 PendingDeprecationWarning 同时也想保持向后兼容，可以用下边的装饰器：

import functools
import sys

if sys.version_info &amp;lt; (3, 5, 2):
    def aiter_compat(func):
        @functools.wraps(func)
        async def wrapper(self):
            return func(self)
        return wrapper
else:
    def aiter_compat(func):
        return func

例子：

class AsyncIterator:

    @aiter_compat
    def __aiter__(self):
        return self

    async def __anext__(self):
        ...
	
从CPython 3.6开始，PendingDeprecationWarning 将被 DeprecationWarning 替换。在CPython 3.7中，从 __aiter__ 返回一个可等待对象将会导致 RuntimeError。

&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;半抄袭，半翻译，一点点完善把。&lt;br /&gt;
其实新版文档已经更新了很多内容，抄袭过来的东西反而有可能有问题。&lt;br /&gt;
而自己翻译的内容～～～反正metaclass那部分，有几段我自己都看晕了。&lt;br /&gt;
不管怎么说，至少是帮助自己深入的了解了一下Python。&lt;br /&gt;
自己凑合着看吧。&lt;br /&gt;
&lt;a href=&#34;https://docs.python.org/3/reference/datamodel.html&#34;&gt;https://docs.python.org/3/reference/datamodel.html&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://docspy3zh.readthedocs.io/en/latest/reference/datamodel.html&#34;&gt;http://docspy3zh.readthedocs.io/en/latest/reference/datamodel.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>