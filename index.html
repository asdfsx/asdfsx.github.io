<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.19-DEV" />

  <title>asdfsx</title>

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://asdfsx.github.io/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://asdfsx.github.io/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="https://asdfsx.github.io/css/blackburn.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  
  <link rel="alternate" type="application/rss+xml" title="asdfsx" href="https://asdfsx.github.io/index.xml" />
  

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/androidstudio.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="https://asdfsx.github.io/img/favicon.ico" type="image/x-icon" />

  
    <link rel="stylesheet" href="https://asdfsx.github.io/css/my.css">
  
  
    <script src="https://asdfsx.github.io/js/my.js"></script>
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  
  <a class="pure-menu-heading brand" href="https://asdfsx.github.io/">asdfsx</a>


  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://asdfsx.github.io/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://asdfsx.github.io/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://asdfsx.github.io/tags/"><i class='fa fa-list fa-fw'></i>Tags</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://asdfsx.github.io/about/"><i class='fa fa-user fa-fw'></i>About</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://asdfsx.github.io/contact/"><i class='fa fa-phone fa-fw'></i>Contact</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://asdfsx.github.io/index.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
    </li>
    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://plus.google.com/+asdfsx" target="_blank"><i class="fa fa-google-plus-square fa-fw"></i>Google+</a>
    </li>
    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="http://weibo.com/*" target="_blank"><i class="fa fa-weibo fa-fw"></i>Weibo</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/asdfsx" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://bitbucket.org/asdfsx" target="_blank"><i class="fa fa-bitbucket-square fa-fw"></i>Bitbucket</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2016. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>asdfsx</h1>
  <h2>sam&#39;s bodega</h2>
</div>

<div class="content">
  
    <article>
  <header>
    <h2><a href="https://asdfsx.github.io/post/golang/Golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">Golang单元测试</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>12 May 2018, 00:01</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="https://asdfsx.github.io/topics/topic-1">topic 1</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/golang">golang</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  参考几篇文章后，简单的进行了实践。感觉可以作为以后使用 golang 开发时，单元测试的固定套路。
首先介绍下这几个库
 goconvey
可以作为单元测试框架。提供web界面管理测试，不仅可以看到单元测试的成功失败，还可以看到测试的覆盖率。而且启动goconvey以后，可以在文件修改后，自动进行测试。  gostub 在测试过程中，根据需求动态修改全局变量的值（比如，使用测试专用的配置文件），根据需求指定某个函数的返回值。（专业术语叫打桩？？？） gomock 专门用来测试接口的工具。可以根据接口定义来生成一个实现了接口的mock结构体。不过这个mock结构体上接口的每个函数返回值都需要根据测试来指定，这个mock结构体，可以在测试中使用。  goconvey 安装
go get github.com/smartystreets/goconvey  启动测试框架
cd $GOPATH/src/github.com/asdfsx/codility goconvey  通过浏览器访问 http://127.0.0.1:8080/ 可以看到测试结果。更改上面的地址可以对不同目录下的代码进行测试。
goconvey 可以直接支持 golang 的 testing 模块。但是为了获得更好的输出，可以使用goconvey的api对测试进行包装
import( . &quot;github.com/smartystreets/goconvey/convey&quot; &quot;testing&quot; ) func TestDB2(t *testing.T){ ... Convey(&quot;CreateConnection&quot;, t, func(){ dbConn, err = CreateConnection() So(err, ShouldEqual, nil) }) ... )  gostub 安装
go get github.com/prashantv/gostub  在测试的过程中，需要根据情况调整配置和一些全局变量，gostub 就是用来做这个的（打桩？）。
import ( &quot;testing&quot; . &quot;github.com/prashantv/gostub&quot; ) var ( MYSQLUSER string MYSQLPASSWORD string MYSQLADDR string MYSQLPORT int DATABASENAME string ) func Test1(t *testing.
  </p>

  
  <footer>
    <a href="https://asdfsx.github.io/post/golang/Golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://asdfsx.github.io/post/golang/Golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Golang的类型</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>25 Feb 2017, 20:15</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="https://asdfsx.github.io/topics/topic-1">topic 1</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/golang">golang</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  两个月前给自己挖的坑，就这么算是填上了吧。其实最重要的还是多看代码、多写代码。本文参考 Golang Specification 和 The way to go。
常量 常量声明 const Pi float64 = 3.14159265358979323846 const zero = 0.0 // untyped floating-point constant const ( size int64 = 1024 eof = -1 // untyped integer constant ) const a, b, c = 3, 4, &quot;foo&quot; // a = 3, b = 4, c = &quot;foo&quot;, untyped integer and string constants const u, v float32 = 0, 3 // u = 0.
  </p>

  
  <footer>
    <a href="https://asdfsx.github.io/post/golang/Golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://asdfsx.github.io/post/docker/%E4%BD%BF%E7%94%A8swarm%E5%9C%A8mac%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">使用swarm在mac上搭建开发环境</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>18 Feb 2017, 10:12</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="https://asdfsx.github.io/topics/topic-1">topic 1</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/docker">docker</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/swarm">swarm</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/golang">golang</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/kafka">kafka</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  源起 docker并不是新技术。作为 golang 社区内的旗舰级的项目，从诞生之初就吸引了很多人的瞩目，甚至可以说是获得了所有 golang 社区的人多瞩目吧。同时对推广 golang 也起了很大的作用。作为从一直关注着 golang 的人，大概2年前就开始尝试使用它了。不过由于其依赖 linux 的多项特性，导致在 mac 上使用必须要借助虚拟机，体验总是要差一点。最近经人提醒发现新的 docker for mac 可以不借助虚拟机就可以在 mac 上提供与 linux 上同样的体验，大喜！遂卸载虚拟机，打算用新软件搭个测试环境玩耍一下。
安装 超级简单，照着说明来就好。顺便装上了 kitematic。这个确实也非常好用。
目标 将一套以前用 python 实现的 kafka producer程序，移植到 golang 上。测试新程序的异常情况处理（特指连接失败的处理）。 然后就被坑掉了。
坑1 网络的问题 最初只是想通过 docker 启动一个单点的 kafka，程序通过本地网络直接访问就可以了。通过之前安装的 kitematic 从 hub.docker.com 上下载了 spotify/kafka 镜像，并直接启动容器。通过kitematic连接到容器内，各项命令执行正常。但是执行程序的时候却发现，总是第一次连接成功后，后边的所有连接都是失败的。通过日志发现程序在第一次成功连接 kafka 之后，连接地址发生了变更，变成了容器内部的地址（直观的现象就是，端口从 kitematic 随机生成的 12345 变成了 9092）。然后又尝试了手动用 &ndash;net=host 方式启动，结果彻底连不上了。
在对 github.com/shopify/sarama 简单的分析以后，发现它的连接过程是这样的：
 首次连接，根据配置信息连接服务器
 连接成功后，从服务器获取broker信息 根据获得到的broker信息，连接其余的broker  问题就出现在最后一步上，服务器返回的broker信息中，网络地址都是容器内部的网络，没有办法从容器网络外部直接连接的。
通过在github上查 issue， google 上查资料，有了以下不负责任的猜想：
  </p>

  
  <footer>
    <a href="https://asdfsx.github.io/post/docker/%E4%BD%BF%E7%94%A8swarm%E5%9C%A8mac%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://asdfsx.github.io/post/odoo/odoo%E7%AE%80%E5%8C%96%E7%89%88refrence/">odoo简化版refrence</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>05 Feb 2017, 12:17</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="https://asdfsx.github.io/topics/topic-1">topic 1</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/python">python</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/odoo">odoo</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  原文地址：https://www.odoo.com/documentation/10.0/index.html
整理一下，捡重点的来弄。
 Odoo Guidelines  模块结构  目录结构 命名规则  XML files Python  Idiomatics Python Programming Programming in Odoo   Module Web Controllers ORM API  Recordsets Environment Common ORM methods Creating Models Compatibility between new API and old API Model Reference Method decorators Fields  Data Files QWeb Views  Odoo Guidelines 模块结构 目录结构 主要目录： * data/ : demo and data xml * models/ : models definition * controllers/ : contains controllers (HTTP routes).
  </p>

  
  <footer>
    <a href="https://asdfsx.github.io/post/odoo/odoo%E7%AE%80%E5%8C%96%E7%89%88refrence/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://asdfsx.github.io/post/odoo/odoo%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/">odoo自定义模块</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>13 Jan 2017, 11:46</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="https://asdfsx.github.io/topics/topic-1">topic 1</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/python">python</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/odoo">odoo</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  复制 http://blog.sunansheng.com/python/odoo/odoo.html 中的请假单例子，创建一个带工作流的例子，工作环境是odoo 10.0。
PS：在这个版本中官方自带的请假模块删掉了工作流～～何等的卧槽！
创建模块模版： python odoo/odoo-bin scaffold qingjia odoo_dev/  在odoo_dev目录中可以找到新创建的模块，进入目录以后可以看到如下的目录结构
controllers demo __init__.py __manifest__.py models security views  __init__.py不需要修改
__manifest__.py需要增加一点东西
&quot;application&quot;: True,  创建模型 修改models/model.py文件。添加新的模型
# -*- coding: utf-8 -*- from odoo import models, fields, api class Qingjd(models.Model): _name = 'qingjia.qingjd' name = fields.Many2one('res.users', string=&quot;申请人&quot;, required=True) days = fields.Float(string=&quot;天数&quot;, required=True) startdate = fields.Date(string=&quot;开始日期&quot;, required=True) reason = fields.Text(string=&quot;请假事由&quot;) def send_qingjd(self): self.sended = True return self.sended def confirm_qingjd(self): self.
  </p>

  
  <footer>
    <a href="https://asdfsx.github.io/post/odoo/odoo%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://asdfsx.github.io/post/python/python%E7%9A%84%E5%AF%BC%E5%85%A5%E7%B3%BB%E7%BB%9F/">python的导入系统</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>11 Jan 2017, 12:01</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="https://asdfsx.github.io/topics/topic-1">topic 1</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/python">python</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/import">import</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  一个模块中的Python代码通过导入的过程获得对另一个模块中的代码的访问。import语句是调用导入机制的最常用方法，但它不是唯一的方法。诸如importlib.import_module()和内置__import__()之类的函数也可以用于调用导入机制。
import语句组合两个操作；它搜索指定的模块，然后将该搜索的结果绑定到本地作用域中的名称。import语句的搜索操作被定义为使用适当的参数调用__import__()函数。__import__()的返回值用于执行import语句的名称绑定操作。有关该名称绑定操作的确切详细信息，请参见import语句。
直接调用__import__()只执行模块搜索，如果找到，则执行模块创建操作。虽然可能会发生某些副作用，例如导入父包以及更新各种缓存（包括sys.modules），但只有import语句会执行名称绑定操作。
当调用__import__()作为import语句的一部分时，将调用标准的内置__import__()。用于调用导入系统的其他机制（例如importlib.import_module()）可以选择颠覆__import__()并使用其自己的解决方案来实现导入语义。
首次导入模块时，Python会搜索模块，如果找到，它会创建一个模块对象[1]，并初始化它。如果找不到指定的模块，则会引发ImportError。当执行导入机制时，Python实现各种策略来搜索命名的模块。这些策略可以通过使用下面部分中描述的各种钩子来修改和扩展。
在版本3.3中更改：导入系统更新成完全实现 PEP 302的第二阶段。不再有任何隐式导入机制 - 完整导入系统通过sys.meta_path暴露。此外，已实现原生命名空间包支持（参见 PEP 420）。
1. importlib importlib模块提供了一个丰富的API，用于与导入系统进行交互。例如importlib.import_module()提供了一个比内置的__import__()更简单的API来调用导入机制。有关其他详细信息，请参阅importlib库文档。
2. 包Packages Python只有一种模块对象，所有的模块都是这种类型，不管这个模块是否是用Python，C，或者其他语言实现。为了帮助组织模块并提供命名层次结构，Python有一个概念：包。
你可以认为包是文件系统中的一个目录并且模块作为文件存放于目录中，但是不要做这种太字面化的类比因为包和模块不需要源于文件系统。从这篇文档的目的是我们用目录和文件这个方便的类比来解释包和模块。和文件系统一样，包有有层次的组织着，并且包本身也会包含子包，规则的模块也一样。
重要的是请注意所有的包都是模块，但不是所有的模块都是包。换句话说，包只是一种特殊形式的模块。具体来说，包含__path__属性的任何模块都被视为包。
所有的模块都有名字。子模块的名字是通过点号从父模块中分离出来的，和Python标准的属性访问语法相似。因此，您可能有一个名为sys的模块和一个名为email的软件包，其中包含一个名为email.mime的子包，名为email.mime.text的子包。
2.1 普通包 Python defines two types of packages, regular packages and namespace packages. Regular packages are traditional packages as they existed in Python 3.2 and earlier. A regular package is typically implemented as a directory containing an init.py file. When a regular package is imported, this init.py file is executed, and the objects it defines are bound to names in the package’s namespace.
  </p>

  
  <footer>
    <a href="https://asdfsx.github.io/post/python/python%E7%9A%84%E5%AF%BC%E5%85%A5%E7%B3%BB%E7%BB%9F/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://asdfsx.github.io/post/odoo/odoo%E4%B8%AD%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E6%88%90/">odoo中页面的生成</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>09 Jan 2017, 17:40</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="https://asdfsx.github.io/topics/topic-1">topic 1</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/python">python</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/odoo">odoo</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  在请求的处理中，已经知道在请求处理的最后，会调用Response的render来生成页面。这里来研究下页面是如何形成的。
以入口地址的处理为例：
 处理/请求的controller为addon.web.controllers.main.Home，定义在web模块中，处理方式是直接跳转到/web。
 处理/web请求的controller同上，使用web.webclient_bootstrap这个模版来生成页面。
class Home(http.Controller): @http.route('/', type='http', auth=&quot;none&quot;) def index(self, s_action=None, db=None, **kw): return http.local_redirect('/web', query=request.params, keep_hash=True) @http.route('/web', type='http', auth=&quot;none&quot;) def web_client(self, s_action=None, **kw): ensure_db() if not request.session.uid: return werkzeug.utils.redirect('/web/login', 303) if kw.get('redirect'): return werkzeug.utils.redirect(kw.get('redirect'), 303) request.uid = request.session.uid context = request.env['ir.http'].webclient_rendering_context() return request.render('web.webclient_bootstrap', qcontext=context)   在介绍页面生成之前，先熟悉下可能会用到的模型
模型 odoo.addons.base.ir.ir_ui_view.View 在response.render函数中，需要用到ir.ui.view模型来生成页面。下边就是这个模型的定义。从中我们可以知道在数据库中一定会有一张表ir_ui_view，同时这个模型会在ir_model注册，模型的字段会在ir_model_fields中记录。其中一个特殊的字段是type，从定义猜测View的种类就是列表中的那几种。
View模型还提供了如下功能：
 根据模版生成页面 render_template（仅仅算是入口函数） 查询模版ID get_view_id
select ir_model_data.id from ir_model_data where module='web' and name='webclient_bootstrap'  模版读取 read_template、read_template、read_combined
  </p>

  
  <footer>
    <a href="https://asdfsx.github.io/post/odoo/odoo%E4%B8%AD%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E6%88%90/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://asdfsx.github.io/post/odoo/odoo%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/">odoo的阶段性总结：服务器的启动、模块的加载、请求处理、页面生成</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>05 Jan 2017, 15:32</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="https://asdfsx.github.io/topics/topic-1">topic 1</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/python">python</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/odoo">odoo</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  经过漫长的阅读代码，搞清了启动的过程。先简单做个总结。如有遗漏之后再做补充。
系统的启动，模块的加载 结合之前研究过的registry，系统启动时会发生如下动作：
 首先加载全局模块web，web_kanban。（在没有确定数据库地址之前，只能显示数据库选择页面。所以这个时候只需要这两个模块就可以了）  在import controller时，由于元类的作用，controller类会自动加载到解释器中  根据配置创建web服务器（线程的、进程的），所有的服务器都使用odoo.service.wsgi_server.application来处理请求。  具体处理请求的是odoo.http.Root  根据需要看要不要再次加载插件 只有当首次接收请求的时候，才会执行加载插件   启动服务器  在启动web服务器之前，首先创建registry。（在进程的实现中，registry会在进程fork之前创建，fork之后registry会被拷贝到各个进程的内存空间中） 当数据库选定之后，registry会根据配置去加载模块  先加载base模块  先创建base模块的依赖关系图graph 使用graph加载base  获取模块中的所有模型 组装配置模型类  根据模型的属性，创建新的模型类，并将模型类注册到registry中 根据模型的属性，为新的模型类添加字段，关联关系等  初始化模型  根据模型类，创建模型类对应的表  装载定义在__manifast__.py中的模块的数据  获取文件列表 调用odoo.tools.convert.convert_file装载文件。  判断文件类型，根据文件类型使用不同的方法解析 根据情况将数据写入ir.model.data 根据情况将数据写入模型自己的数据表中     根据配置标注其它需要加载的模块 根据标注加载模块  使用graph进行模块的记载（下边以web模块为例，看一下模块数据的加载）  获取数据文件：views/webclient_templates.xml 调用odoo.tools.convert.convert_file装载文件  创建xml专用的解析器对象xml_import 解析xml文件  遍历整个xml文档树，根据节点的类型调用不同的函数来进行处理。具体到views/webclient_templates.xml，这个文件由template组成，对应的函数是_tag_template。这个函数在结尾调用_tag_record，这个函数会将数据文件里的内容写入ir_model_data表中。      模块加载完毕后，服务器开始运行。等待处理请求。   请求处理  首次接受到请求  odoo.
  </p>

  
  <footer>
    <a href="https://asdfsx.github.io/post/odoo/odoo%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://asdfsx.github.io/post/odoo/odoo%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84Field/">odoo模型中的Field</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>05 Jan 2017, 12:39</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="https://asdfsx.github.io/topics/topic-1">topic 1</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/python">python</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/odoo">odoo</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  Odoo的定义了自己的一套ORM系统。其中的一个重要组成部分就是字段的处理。这部分的内容都在odoo.field中。和其他模块一样，也大量使用了python的特殊语法，如：元类、__slots__、特殊函数，等。
元类：odoo.fields.MetaField 所有的字段类型的元类。如果一个字段类型使用了这个类，那么在创建这个类型时元类会扫描类中是否有_slots属性。如果有的话，会将_slots中的东西放到__slots__中。然后在初始化这个类型的时候，会把这个新创建的类型放在MetaField的by_type字典中。
注：__slots__的作用是用来存放类实例中的属性。默认，python中的实例是存放在__dict__中的；如果声明了__slots__就不会创建__dict__；__slots__应该比 __dict__节省空间。
class MetaField(type): &quot;&quot;&quot; Metaclass for field classes. &quot;&quot;&quot; by_type = {} def __new__(meta, name, bases, attrs): &quot;&quot;&quot; Combine the ``_slots`` dict from parent classes, and determine ``__slots__`` for them on the new class. &quot;&quot;&quot; base_slots = {} for base in reversed(bases): base_slots.update(getattr(base, '_slots', ())) slots = dict(base_slots) slots.update(attrs.get('_slots', ())) attrs['__slots__'] = set(slots) - set(base_slots) attrs['_slots'] = slots return type.__new__(meta, name, bases, attrs) def __init__(cls, name, bases, attrs): super(MetaField, cls).
  </p>

  
  <footer>
    <a href="https://asdfsx.github.io/post/odoo/odoo%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84Field/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://asdfsx.github.io/post/odoo/odoo%E7%9A%84model/">odoo的模型 Model</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>30 Dec 2016, 14:31</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="https://asdfsx.github.io/topics/topic-1">topic 1</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/python">python</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://asdfsx.github.io/tags/odoo">odoo</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  model是odoo中最重要的部分之一。主要负责各种功能的实现，crm之类的业务模块中的功能姑且不论，页面渲染、工作流引擎、定时任务等核心的功能，也都是基于模型来实现。
元类的基础：odoo.api.Meta 检查要创建的类中的所有函数，然后根据各函数_api属性进行特殊处理。处理完成后再创建该类型。
class Meta(type): &quot;&quot;&quot; Metaclass that automatically decorates traditional-style methods by guessing their API. It also implements the inheritance of the :func:`returns` decorators. &quot;&quot;&quot; def __new__(meta, name, bases, attrs): # dummy parent class to catch overridden methods decorated with 'returns' parent = type.__new__(meta, name, bases, {}) for key, value in attrs.items(): if not key.startswith('__') and callable(value): # make the method inherit from decorators value = propagate(getattr(parent, key, None), value) # guess calling convention if none is given if not hasattr(value, '_api'): try: value = guess(value) except TypeError: pass if (getattr(value, '_api', None) or '').
  </p>

  
  <footer>
    <a href="https://asdfsx.github.io/post/odoo/odoo%E7%9A%84model/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  

  


<nav class="pagination" role="pagination">
  
  <i class="fa fa-chevron-left"></i>
  
  <span>&nbsp;1 / 3&nbsp;</span>
  
  <a href="https://asdfsx.github.io/page/2/"><i class="fa fa-chevron-right"></i></a>
  
</nav>



</div>

</div>
</div>
<script src="https://asdfsx.github.io/js/ui.js"></script>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'Your Google Analytics tracking ID', 'auto');
  ga('send', 'pageview');

</script>



</body>
</html>

